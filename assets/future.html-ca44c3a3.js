import{_ as e,V as a,W as r,Z as t}from"./framework-e5d7a6b2.js";const i={},n=t('<h1 id="异步编程" tabindex="-1"><a class="header-anchor" href="#异步编程" aria-hidden="true">#</a> 异步编程</h1><h2 id="future" tabindex="-1"><a class="header-anchor" href="#future" aria-hidden="true">#</a> Future</h2><h3 id="同步与异步的概念" tabindex="-1"><a class="header-anchor" href="#同步与异步的概念" aria-hidden="true">#</a> 同步与异步的概念</h3><ul><li><strong>同步</strong> ： 发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong> ：调用在发出之后，不用等待返回结果，该调用直接返回。</li></ul><h3 id="阻塞与非阻塞的概念" tabindex="-1"><a class="header-anchor" href="#阻塞与非阻塞的概念" aria-hidden="true">#</a> 阻塞与非阻塞的概念</h3><p>阻塞和非阻塞指的是：当前接口数据还未准备就绪时，线程是否被阻塞挂起。</p><p>何为阻塞挂起？就是当前线程还处于 CPU 时间片当中，调用了阻塞的方法，由于数据未准备就绪，则时间片还未到就让出 CPU。</p><p>所以阻塞和同步看起来都是等，但是本质上它们不一样，同步的时候可没有让出 CPU。</p><p>而非阻塞就是当前接口数据还未准备就绪时，线程不会被阻塞挂起，可以不断轮询请求接口，看看数据是否已经准备就绪。</p><p>至此我们可以得到一个结论：</p><ul><li>同步&amp;异步指：当数据还未处理完成时，代码的逻辑处理方式不同。</li><li>阻塞&amp;非阻塞指：当数据还未处理完成时(未就绪)，线程的状态。</li></ul><p>所以同步&amp;异步其实是处于框架这种高层次维度来看待的，而阻塞&amp;非阻塞往往针对底层的系统调用方面来抉择，也就是说两者是从不同维度来考虑的。</p><p>没有返回值的：runAsync</p><p>有返回值的：submitAsync</p>',14),h=[n];function s(d,c){return a(),r("div",null,h)}const u=e(i,[["render",s],["__file","future.html.vue"]]);export{u as default};
