import{_ as i,V as e,W as l,Z as d}from"./framework-e5d7a6b2.js";const a={},s=d('<h1 id="trace-note" tabindex="-1"><a class="header-anchor" href="#trace-note" aria-hidden="true">#</a> Trace Note</h1><h3 id="技术选型" tabindex="-1"><a class="header-anchor" href="#技术选型" aria-hidden="true">#</a> 技术选型</h3><p>后端：</p><ul><li>Spring Boot 2.8, Spring AOP</li><li>MySQL, Redis, Redisson</li><li>hutool</li><li>RabbitMQ, Spring AMQP</li><li>文档：knife4j</li></ul><p>前端：</p><ul><li>SwiftUI</li><li>ARKit</li></ul><h3 id="系统业务" tabindex="-1"><a class="header-anchor" href="#系统业务" aria-hidden="true">#</a> 系统业务</h3><h3 id="人员分工" tabindex="-1"><a class="header-anchor" href="#人员分工" aria-hidden="true">#</a> 人员分工</h3><ul><li>3个同学，1人全职文案和海报，2位开发同学客户端和后端共同负责</li><li>2人客户端、SwiftUI主要界面、ARKit场景交互页面</li><li>2人后端、</li></ul><h3 id="项目亮点" tabindex="-1"><a class="header-anchor" href="#项目亮点" aria-hidden="true">#</a> 项目亮点</h3><ol><li>利用AOP实现注解校验用户登陆状态及用户权限。使用 Redis 实现分布式 Session，解决集群间登录态同步问题；</li><li>使用 Redis 对高频访问 Trace 进行缓存，降低 DB 压力同时提升 90% 的数据查询性能。</li><li>使用模版模式实现了通用缓存访问静态方法，并解决了缓存雪崩、缓存穿透和缓存击穿的问题。</li><li>使用 Redis 的 Geo 数据结构存储附近 Trace，并使用 Geo Search 命令实现高性能 Trace 查询及按距离排序。</li><li>使用 Redis ZSet 数据结构存储用户点赞信息，保证用户只能点赞一次，并可以展示记录点赞的先后排序。</li><li>使用 Redis Set 数据结构实现用户关注、共同关注功能，并使用 Redis AOF 持久化防止关注数据丢失。</li><li>使用 Redis BitMap 实现用户连续签到统计功能，提高存储的效率并减少内存的占用。</li><li>基于推模式实现关注 Feed 流，保证了新点评消息的及时可达，并减少用户访问的等待时间。</li><li>使用 Lua 脚本实现库存预检解决了超卖问题、实现一人一单。通过 RabbitMQ 实现异步订单创建、超时取消订单。</li></ol><p>列举一些该项目可以扩展的点，有能力的同学可以自己尝试实现（注意，没有自己实现过千万别写到简历上！！！做没做过一问便知）：</p><ol><li><p>使用 Redis + Token 机制实现单点登录（补充到上述第 1 点中）</p></li><li><p>对 Redis 的所有 key 设置 N + n 的过期时间，从而合理使用内存并防止缓存雪崩；针对热点店铺缓存，使用逻辑过期（或自动续期）机制解决缓存击穿问题，防止数据库宕机。</p></li><li><p>使用 Redis 的 Geo + Hash 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及按距离排序，实测相对于传统 DB 查询 + 业务层计算的方式，性能提升 xx%。</p></li><li><p>使用 Redis Set 数据结构实现用户关注、共同关注功能（交集），实测相对于 DB 查询性能提升 xx%，并使用 Redis AOF + 业务层日志防止关注数据丢失。（理解 AOF 和 RDB 持久化机制后再写这点）</p></li><li><p>基于 Spring Scheduler 实现对热点数据的定期检测和缓存预加载，提升用户的访问体验，并通过 Redisson 分布式锁保证集群中同一时刻的定时任务只执行一次。</p></li><li><p>关注 Feed 流可以改为推拉结合模式（活跃用户用推、普通用户用拉）</p></li><li><p>使用哨兵集群来提升 Redis 的读并发量、可用性和稳定性；或者使用 Redis 分片集群来提升 Redis 读写并发量、总存储容量，保障可用性和稳定性。</p></li><li><p>随着系统用户增多，使用 Redis HyperLogLog 代替 DB 来实现店铺和点评的 UV 统计，提高 xx% 的查询分析性能并解决 xx% 的内存空间。</p></li><li><p>利用AOP实现注解校验用户登陆状态及用户权限。使用 Redis 实现分布式 Session，解决集群间登录态同步问题；</p></li><li><p>使用 Redis 对高频访问 Trace 进行缓存，降低 DB 压力同时提升 90% 的数据查询性能。</p></li><li><p>使用模版模式实现了通用缓存访问静态方法，并解决了缓存雪崩、缓存穿透和缓存击穿的问题。</p></li><li><p>使用 Redis 的 Geo + Hash 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及按距离排序。</p></li><li><p>使用 Redis ZSet 数据结构存储用户点赞信息，保证用户只能点赞一次，并基于 ZSet 记录点赞的时间。</p></li><li><p>使用 Redis Set 数据结构实现用户关注、共同关注功能（交集），实测相对于 DB 查询性能提升 xx%，并使用 Redis AOF + 业务层日志防止关注数据丢失。</p></li><li><p>使用 Redis BitMap 实现用户连续签到统计功能。</p></li><li><p>基于推模式实现关注 Feed 流，保证了新点评消息的及时可达，并减少用户访问的等待时间。</p></li><li><p>个性饰品抢购：使用 Lua 脚本实现库存预检解决了超卖问题、实现一人一单。通过 RabbitMQ 实现异步订单创建，流量削峰。</p><p>使用 Redis + Lua 脚本实现库存预检，并通过 RabbitMQ 实现订单的异步创建，解决了超卖问题、实现一人一单。实现相比传统数据库，秒杀性能提高了 xx%。</p></li></ol><p>再列举一些该项目可以扩展的点，有能力的同学可以自己尝试实现（注意，没有自己实现过千万别写到简历上！！！做没做过一问便知）：</p><ol><li>使用 Redis + Token 机制实现单点登录（补充到上述第 1 点中）</li><li>对 Redis 的所有 key 设置 N + n 的过期时间，从而合理使用内存并防止缓存雪崩；针对热点店铺缓存，使用逻辑过期（或自动续期）机制解决缓存击穿问题，防止数据库宕机。</li><li>使用 Redis 的 Geo + Hash 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及按距离排序，实测相对于传统 DB 查询 + 业务层计算的方式，性能提升 xx%。</li><li>使用 Redis Set 数据结构实现用户关注、共同关注功能（交集），实测相对于 DB 查询性能提升 xx%，并使用 Redis AOF + 业务层日志防止关注数据丢失。（理解 AOF 和 RDB 持久化机制后再写这点）</li><li>基于 Spring Scheduler 实现对热点数据的定期检测和缓存预加载，提升用户的访问体验，并通过 Redisson 分布式锁保证集群中同一时刻的定时任务只执行一次。</li><li>关注 Feed 流可以改为推拉结合模式（活跃用户用推、普通用户用拉）</li><li>使用哨兵集群来提升 Redis 的读并发量、可用性和稳定性；或者使用 Redis 分片集群来提升 Redis 读写并发量、总存储容量，保障可用性和稳定性。</li><li>随着系统用户增多，使用 Redis HyperLogLog 代替 DB 来实现店铺和点评的 UV 统计，提高 xx% 的查询分析性能并解决 xx% 的内存空间。</li></ol>',15),p=[s];function r(t,o){return e(),l("div",null,p)}const n=i(a,[["render",r],["__file","雁过留痕.html.vue"]]);export{n as default};
