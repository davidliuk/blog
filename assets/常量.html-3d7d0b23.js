import{_ as t,V as o,W as a,Z as e}from"./framework-e5d7a6b2.js";const l={},i=e('<h1 id="类定义和接口定义常量对比" tabindex="-1"><a class="header-anchor" href="#类定义和接口定义常量对比" aria-hidden="true">#</a> 类定义和接口定义常量对比</h1><p>类定义常量和接口定义常量:</p><ol><li>类定义常量, 需要定义成final且定义一个private的构造方法, 这样做是为了不让其他类继承, 禁止实例化此类,</li></ol><p>调用时直接以&quot;类.常量&quot;的方式调用.</p><ol start="2"><li>接口中定义的&quot;变量&quot;, 其实就是常量, 接口中的&quot;变量&quot;默认都是 &quot;public static final&quot;类型, 即为常量,</li></ol><p>因此接口可以省略&quot;public static final&quot;而直接写成 &quot;type variable&quot;.</p><ol start="3"><li><p>用如上的类定义常量, 不能实例化也不能被继承, 看起了完美无缺;</p></li><li><p>接口定义常量, 虽不能实例化, 确可以被其他类实现;</p></li></ol><p>因此有这么一种设计模式&quot;The constant interface pattern&quot;. 所谓的&quot;常量接口模式&quot;, 就是其他类要使用接口中定义的常量,</p><p>就实现该接口. 我认为这是对接口的烂用. 接口中定义的常量应为所有类频繁使用的常量, 但并不是每个类都使用了接口中定义的所有常量,</p><p>因而导入了不必要的常量到这个类中, 并且导入后这个类的子类也会基础导入的常量, 这样会导致混乱, 应当避免此种用法.</p><ol start="5"><li>在interface和class中定义相同的常量, interface生成的class文件比class生成的class文件会更小, 而且更简洁, 效率更高</li></ol><p>所以我更喜欢把常量定义在接口中。</p>',12),c=[i];function s(p,r){return o(),a("div",null,c)}const u=t(l,[["render",s],["__file","常量.html.vue"]]);export{u as default};
