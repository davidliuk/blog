import{_ as i,V as o,W as c,X as a,Y as n,Z as e,a0 as t,E as l}from"./framework-705b829b.js";const r={},p=t(`<h1 id="消息丢失" tabindex="-1"><a class="header-anchor" href="#消息丢失" aria-hidden="true">#</a> 消息丢失</h1><h2 id="产生原因" tabindex="-1"><a class="header-anchor" href="#产生原因" aria-hidden="true">#</a> 产生原因</h2><p>消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。</p><ul><li>第一种：生产者弄丢了数据。生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题或服务器宕机等。</li><li>第二种：RabbitMQ 弄丢了数据。MQ还没有持久化自己挂了</li><li>第三种：消费端弄丢了数据。刚消费到，还没处理，结果进程挂了，比如重启了。</li></ul><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h2><ul><li>生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。</li><li>RabbitMQ 自身：持久化、集群、普通模式、镜像模式。</li><li>RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/截屏2023-03-13 17.48.04.png" alt="截屏2023-03-13 17.48.04" loading="lazy"></p><h3 id="针对生产者" tabindex="-1"><a class="header-anchor" href="#针对生产者" aria-hidden="true">#</a> 针对生产者</h3><h4 id="方案1-开启rabbitmq事务" tabindex="-1"><a class="header-anchor" href="#方案1-开启rabbitmq事务" aria-hidden="true">#</a> 方案1 ：开启RabbitMQ事务</h4><p>可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 开启事务</span>
channel<span class="token punctuation">.</span>txSelect
<span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">// 这里发送消息</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      channel<span class="token punctuation">.</span>txRollback

<span class="token comment">// 这里再次重发这条消息</span>

<span class="token punctuation">}</span>

<span class="token comment">// 提交事务</span>
channel<span class="token punctuation">.</span>txCommit
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>缺点： RabbitMQ 事务机制是同步的，你提交一个事务之后会阻塞在那儿，采用这种方式基本上吞吐量会下来，因为太耗性能。</p><h4 id="方案2-使用confirm机制" tabindex="-1"><a class="header-anchor" href="#方案2-使用confirm机制" aria-hidden="true">#</a> 方案2： 使用confirm机制</h4><p>事务机制和 confirm 机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是 confirm 机制是异步的</p><p>在生产者开启了confirm模式之后，每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq之中，rabbitmq会给你回传一个ack消息，告诉你这个消息发送OK了；如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息失败了，你可以进行重试。而且你可以结合这个机制知道自己在内存里维护每个消息的id，如果超过一定时间还没接收到这个消息的回调，那么你可以进行重发。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//开启confirm</span>
channel<span class="token punctuation">.</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//发送成功回调</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ack</span><span class="token punctuation">(</span><span class="token class-name">String</span> messageId<span class="token punctuation">)</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token comment">// 发送失败回调</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">nack</span><span class="token punctuation">(</span><span class="token class-name">String</span> messageId<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//重发该消息</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="针对rabbitmq" tabindex="-1"><a class="header-anchor" href="#针对rabbitmq" aria-hidden="true">#</a> 针对RabbitMQ</h3><p><strong>说三点：</strong></p>`,18),d=a("li",null,"要保证rabbitMQ不丢失消息，那么就需要开启rabbitMQ的持久化机制，即把消息持久化到硬盘上，这样即使rabbitMQ挂掉在重启后仍然可以从硬盘读取消息；",-1),u={href:"https://so.csdn.net/so/search?q=HAPROXY&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},b=a("li",null,"如果硬盘坏掉怎么保证消息不丢失",-1),h=a("h4",{id:"消息持久化",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#消息持久化","aria-hidden":"true"},"#"),n(" 消息持久化")],-1),m={href:"https://so.csdn.net/so/search?q=crash&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},k=t('<p>所以就要对消息进行持久化处理。如何持久化，下面具体说明下：</p><p>要想做到消息持久化，必须满足以下三个条件，缺一不可。</p><ul><li>Exchange 设置持久化</li><li>Queue 设置持久化</li><li>Message持久化发送：发送消息设置发送模式deliveryMode=2，代表持久化消息</li></ul><h4 id="设置集群镜像模式" tabindex="-1"><a class="header-anchor" href="#设置集群镜像模式" aria-hidden="true">#</a> 设置集群镜像模式</h4><p>我们先来介绍下RabbitMQ三种部署模式：</p><ol><li>单节点模式：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。</li><li>普通模式：消息只会存在与当前节点中，并不会同步到其他节点，当前节点宕机，有影响的业务会瘫痪，只能等待节点恢复重启可用（必须持久化消息情况下）。</li><li>镜像模式：消息会同步到其他节点上，可以设置同步的节点个数，但吞吐量会下降。属于RabbitMQ的HA方案</li></ol><p>为什么设置镜像模式集群，因为队列的内容仅仅存在某一个节点上面，不会存在所有节点上面，所有节点仅仅存放消息结构和元数据。下面自己画了一张图介绍普通集群丢失消息情况：</p><p>如果想解决上面途中问题，保证消息不丢失，需要采用HA 镜像模式队列。</p><p>下面介绍下三种HA策略模式：</p><p>1）同步至所有的 2）同步最多N个机器 3）只同步至符合指定名称的nodes</p><p>命令处理HA策略模版：rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority]</p><p>1）为每个以“rock.wechat”开头的队列设置所有节点的镜像，并且设置为自动同步模式 rabbitmqctl set_policy ha-all &quot;^rock.wechat&quot; &#39;{&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;}&#39; rabbitmqctl set_policy -p rock ha-all &quot;^rock.wechat&quot; &#39;{&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;}&#39;</p><p>2）为每个以“rock.wechat.”开头的队列设置两个节点的镜像，并且设置为自动同步模式 rabbitmqctl set_policy -p rock ha-exacly &quot;^rock.wechat&quot; <br> &#39;{&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;}&#39;</p><p>3）为每个以“node.”开头的队列分配指定的节点做镜像 rabbitmqctl set_policy ha-nodes &quot;^nodes.&quot; <br> &#39;{&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;rabbit@nodeA&quot;, &quot;rabbit@nodeB&quot;]}&#39;</p><p>但是：HA 镜像队列有一个很大的缺点就是： 系统的吞吐量会有所下降.</p><h4 id="消息补偿机制" tabindex="-1"><a class="header-anchor" href="#消息补偿机制" aria-hidden="true">#</a> 消息补偿机制</h4><p>为什么还要消息补偿机制呢？难道消息还会丢失，没错，系统是在一个复杂的环境，不要想的太简单了，虽然以上的三种方案，基本可以保证消息的高可用不丢失的问题，</p><p>但是作为有追求的程序员来讲，要绝对保证我的系统的稳定性，有一种危机意识。</p><p>比如：持久化的消息，保存到硬盘过程中，当前队列节点挂了，存储节点硬盘又坏了，消息丢了，怎么办？</p><p>1）生产端首先将业务数据以及消息数据入库，需要在同一个事务中，消息数据入库失败，则整体回滚。</p><h3 id="针对消费者" tabindex="-1"><a class="header-anchor" href="#针对消费者" aria-hidden="true">#</a> 针对消费者</h3><h4 id="方案一-ack确认机制" tabindex="-1"><a class="header-anchor" href="#方案一-ack确认机制" aria-hidden="true">#</a> 方案一：ACK确认机制</h4><p>多个消费者同时收取消息，比如消息接收到一半的时候，一个消费者死掉了(逻辑复杂时间太长，超时了或者消费被停机或者网络断开链接)，如何保证消息不丢？</p><p>使用rabbitmq提供的ack机制，服务端首先关闭rabbitmq的自动ack，然后每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。才把消息从内存删除。</p><p>这样就解决了，即使一个消费者出了问题，但不会同步消息给服务端，会有其他的消费端去消费，保证了消息不丢的case。</p><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU3VuQWx3YXlzT25saW5l,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img" loading="lazy"></p>',26);function v(q,_){const s=l("ExternalLinkIcon");return o(),c("div",null,[p,a("ol",null,[d,a("li",null,[n("如果rabbitMQ单点故障怎么办，这种情况倒不会造成消息丢失，这里就要提到rabbitMQ的3种安装模式，单机模式、普通集群模式、镜像集群模式，这里要保证rabbitMQ的高可用就要配合"),a("a",u,[n("HAPROXY"),e(s)]),n("做镜像集群模式")]),b]),h,a("p",null,[n("RabbitMQ 的消息默认存放在内存上面，如果不特别声明设置，消息不会持久化保存到硬盘上面的，如果节点重启或者意外"),a("a",m,[n("crash"),e(s)]),n("掉，消息就会丢失。")]),k])}const x=i(r,[["render",v],["__file","消息丢失.html.vue"]]);export{x as default};
