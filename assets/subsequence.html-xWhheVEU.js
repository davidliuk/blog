import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as n,o as s}from"./app-TGRQBxvj.js";const e={};function o(r,t){return s(),i("div",null,t[0]||(t[0]=[n(`<h1 id="subsequence" tabindex="-1"><a class="header-anchor" href="#subsequence"><span>Subsequence</span></a></h1><blockquote><p>Continuous Subsequence 即 Subarray，参考 Subarray 问题</p></blockquote><p><strong>子序列问题核心在于元素顺序保持、不要求连续</strong>，解法大体可分为：</p><ul><li><strong>DP</strong>（LIS / LCS / 编辑距离 / 子序列计数）</li><li><strong>贪心 + 二分</strong>（LIS）</li><li><strong>双指针</strong>（匹配子序列）</li><li><strong>递归 + 状态压缩 / 记忆化</strong>（组合 / 多条件子序列）</li></ul><h2 id="_1️⃣-子序列问题分类" tabindex="-1"><a class="header-anchor" href="#_1️⃣-子序列问题分类"><span><strong>1️⃣ 子序列问题分类</strong></span></a></h2><p>子序列是 <strong>原数组/字符串中删除若干元素（可为 0）后形成的新序列</strong>，元素相对顺序不变。按题目特征，可分为以下几类：</p><table><thead><tr><th>类别</th><th>典型题</th><th>核心思路</th></tr></thead><tbody><tr><td><strong>最长递增/非递增子序列</strong></td><td>300. Longest Increasing Subsequence, 674. Longest Continuous Increasing Subsequence</td><td>DP（状态 dp[i] 表示以 i 结尾的 LIS）/ 二分优化 O(n log n)</td></tr><tr><td><strong>最长公共子序列</strong></td><td>1143. Longest Common Subsequence, 1092. Shortest Common Supersequence</td><td>DP[i][j] 表示 s1[0..i-1] 和 s2[0..j-1] 的 LCS 长度</td></tr><tr><td><strong>最大和 / 最优子序列</strong></td><td>53. Maximum Subarray（连续子数组）→ 子序列变体</td><td>DP / 贪心（sum 最优）</td></tr><tr><td><strong>特定和 / 条件子序列</strong></td><td>646. Maximum Length of Pair Chain, 1048. Longest String Chain</td><td>DP + 排序 / 贪心</td></tr><tr><td><strong>子序列计数</strong></td><td>115. Distinct Subsequences</td><td>DP[i][j] 表示 s1 前 i 个匹配 s2 前 j 个的方式数</td></tr><tr><td><strong>子序列匹配 / 编辑距离</strong></td><td>72. Edit Distance, 392. Is Subsequence</td><td>双指针 / DP</td></tr><tr><td><strong>特殊序列问题（位操作/状态压缩）</strong></td><td>879. Profitable Schemes, 691. Stickers to Spell Word</td><td>DP + 状态压缩 / bitmask</td></tr></tbody></table><hr><h2 id="_2️⃣-常用算法-技术" tabindex="-1"><a class="header-anchor" href="#_2️⃣-常用算法-技术"><span><strong>2️⃣ 常用算法 / 技术</strong></span></a></h2><table><thead><tr><th>技术</th><th>使用场景</th><th>特点</th></tr></thead><tbody><tr><td><strong>动态规划（DP）</strong></td><td>LIS / LCS / 编辑距离 / 子序列计数</td><td>核心：定义 dp[i] 或 dp[i][j] → 状态转移</td></tr><tr><td><strong>贪心 + 二分优化</strong></td><td>LIS / 最大递增链</td><td>O(n log n) 时间优化 LIS</td></tr><tr><td><strong>双指针</strong></td><td>判断子序列 / 匹配子序列</td><td>s2 是 s1 的子序列，指针 i,j 同步移动</td></tr><tr><td><strong>状态压缩 / 位运算</strong></td><td>多维状态 / 多条件约束</td><td>用 bitmask 记录使用状态</td></tr><tr><td><strong>递归 + 记忆化</strong></td><td>子序列计数 / 匹配问题</td><td>避免重复计算，复杂度从指数降到多项式</td></tr></tbody></table><hr><h2 id="_3️⃣-常见模式总结" tabindex="-1"><a class="header-anchor" href="#_3️⃣-常见模式总结"><span><strong>3️⃣ 常见模式总结</strong></span></a></h2><ol><li><strong>最长递增子序列（LIS）模式</strong></li></ol><ul><li><strong>问题</strong>：求长度、最大和、或实际序列</li><li><strong>思路</strong>： <ol><li>DP[i] = LIS 以 nums[i] 结尾的长度</li><li>状态转移：<code>dp[i] = max(dp[j] + 1 | j &lt; i &amp;&amp; nums[j] &lt; nums[i])</code></li></ol></li><li><strong>优化</strong>：维护一个递增数组 tails + 二分 → O(n log n)</li><li><strong>题型</strong>： <ul><li><ol start="300"><li>LIS</li></ol></li><li><ol><li>Longest Continuous Increasing Subsequence</li></ol></li><li><ol><li>Maximum Length of Pair Chain</li></ol></li></ul></li></ul><hr><ol><li><strong>最长公共子序列（LCS）模式</strong></li></ol><ul><li><p><strong>问题</strong>：求两个序列的最长公共子序列</p></li><li><p><strong>思路</strong>：</p><ul><li><p>dp[i][j] = LCS(s1[0..i-1], s2[0..j-1])</p></li><li><p>转移：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>if s1[i-1] == s2[j-1]:</span></span>
<span class="line"><span>    dp[i][j] = dp[i-1][j-1] + 1</span></span>
<span class="line"><span>else:</span></span>
<span class="line"><span>    dp[i][j] = max(dp[i-1][j], dp[i][j-1])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>空间优化</strong>：滚动数组 → O(min(m,n))</p></li><li><p><strong>题型</strong>：</p><ul><li><ol start="1143"><li>LCS</li></ol></li><li><ol><li>Shortest Common Supersequence</li></ol></li><li><ol><li>Distinct Subsequences</li></ol></li></ul></li></ul><hr><ol><li><strong>子序列计数 / 匹配模式</strong></li></ol><ul><li><strong>问题</strong>：统计子序列数量或判断是否匹配</li><li><strong>思路</strong>： <ul><li>DP[i][j] = 前 i 个 s1 匹配前 j 个 s2 的方法数</li><li>遍历 s1，更新 dp</li></ul></li><li><strong>题型</strong>： <ul><li><ol start="115"><li>Distinct Subsequences</li></ol></li><li><ol><li>Is Subsequence（双指针）</li></ol></li></ul></li></ul><hr><ol><li><strong>连续子序列 / 滑动窗口模式</strong></li></ol><ul><li><strong>问题</strong>：求连续子序列满足某条件（长度 / sum / max）</li><li><strong>思路</strong>： <ul><li>滑动窗口 → expand / shrink</li><li>可用单调队列维护最值或 sum</li></ul></li><li><strong>题型</strong>： <ul><li><ol start="674"><li>Longest Continuous Increasing Subsequence</li></ol></li><li><ol><li>Shortest Subarray with Sum at Least K（连续）</li></ol></li></ul></li></ul><hr><ol><li><strong>递归 + 状态压缩模式</strong></li></ol><ul><li><strong>问题</strong>：多条件约束、组合子序列</li><li><strong>思路</strong>： <ul><li>递归枚举选择/不选择</li><li>记忆化或 bitmask 压缩状态</li></ul></li><li><strong>题型</strong>： <ul><li><ol start="879"><li>Profitable Schemes</li></ol></li><li><ol><li>Stickers to Spell Word</li></ol></li></ul></li></ul><hr><h2 id="_4️⃣-实战技巧" tabindex="-1"><a class="header-anchor" href="#_4️⃣-实战技巧"><span><strong>4️⃣ 实战技巧</strong></span></a></h2><ol><li><strong>先明确连续 vs 不连续</strong><ul><li>连续 → 滑动窗口 / 单调队列 / DP</li><li>不连续 → LIS / LCS / 子序列计数 DP</li></ul></li><li><strong>确定目标</strong><ul><li>长度 → LIS / LCS / DP</li><li>数量 → 子序列计数 / HashMap</li><li>匹配 → 双指针或 DP</li></ul></li><li><strong>优化思路</strong><ul><li>LIS → 二分优化 O(n log n)</li><li>LCS → 滚动数组节省空间</li><li>子序列计数 → 递归 + 记忆化</li><li>连续条件 → 滑动窗口 / 单调队列</li></ul></li></ol><p>我可以帮你画一张 <strong>子序列问题解法图</strong>，把 <strong>题型 → 技术 → 模板 → 典型题</strong> 全部整理成一张图表，非常适合面试复盘。</p><p>你希望我画吗？</p>`,31)]))}const u=l(e,[["render",o],["__file","subsequence.html.vue"]]),g=JSON.parse(`{"path":"/algo/faq/list/subsequence.html","title":"Subsequence","lang":"en-US","frontmatter":{"description":"Subsequence Continuous Subsequence 即 Subarray，参考 Subarray 问题 子序列问题核心在于元素顺序保持、不要求连续，解法大体可分为： DP（LIS / LCS / 编辑距离 / 子序列计数） 贪心 + 二分（LIS） 双指针（匹配子序列） 递归 + 状态压缩 / 记忆化（组合 / 多条件子序列） 1️⃣...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/faq/list/subsequence.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"Subsequence"}],["meta",{"property":"og:description","content":"Subsequence Continuous Subsequence 即 Subarray，参考 Subarray 问题 子序列问题核心在于元素顺序保持、不要求连续，解法大体可分为： DP（LIS / LCS / 编辑距离 / 子序列计数） 贪心 + 二分（LIS） 双指针（匹配子序列） 递归 + 状态压缩 / 记忆化（组合 / 多条件子序列） 1️⃣..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-11-17T00:30:37.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-17T00:30:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Subsequence\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-11-17T00:30:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"1️⃣ 子序列问题分类","slug":"_1️⃣-子序列问题分类","link":"#_1️⃣-子序列问题分类","children":[]},{"level":2,"title":"2️⃣ 常用算法 / 技术","slug":"_2️⃣-常用算法-技术","link":"#_2️⃣-常用算法-技术","children":[]},{"level":2,"title":"3️⃣ 常见模式总结","slug":"_3️⃣-常见模式总结","link":"#_3️⃣-常见模式总结","children":[]},{"level":2,"title":"4️⃣ 实战技巧","slug":"_4️⃣-实战技巧","link":"#_4️⃣-实战技巧","children":[]}],"git":{"createdTime":1763339437000,"updatedTime":1763339437000,"contributors":[{"name":"dawei.liu","email":"dawei.liu@bytedance.com","commits":1}]},"readingTime":{"minutes":3.49,"words":1046},"filePathRelative":"algo/faq/list/subsequence.md","localizedDate":"November 17, 2025","excerpt":"\\n<blockquote>\\n<p>Continuous Subsequence 即 Subarray，参考 Subarray 问题</p>\\n</blockquote>\\n<p><strong>子序列问题核心在于元素顺序保持、不要求连续</strong>，解法大体可分为：</p>\\n<ul>\\n<li><strong>DP</strong>（LIS / LCS / 编辑距离 / 子序列计数）</li>\\n<li><strong>贪心 + 二分</strong>（LIS）</li>\\n<li><strong>双指针</strong>（匹配子序列）</li>\\n<li><strong>递归 + 状态压缩 / 记忆化</strong>（组合 / 多条件子序列）</li>\\n</ul>","autoDesc":true}`);export{u as comp,g as data};
