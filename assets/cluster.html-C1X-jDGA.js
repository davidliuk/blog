import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as i,o as a}from"./app-B6aCd_WP.js";const r={};function s(n,l){return a(),t("div",null,l[0]||(l[0]=[i('<h1 id="聚类召回" tabindex="-1"><a class="header-anchor" href="#聚类召回"><span>聚类召回</span></a></h1><p>基本思想</p><ul><li>如果用户喜欢一篇笔记，那么他会喜欢内容相似的笔记。</li><li>事先训练一个神经网络，基于笔记的类目和图文内容，把笔记映射到向量。</li><li>对笔记向量做聚类，划分为1000 cluster,记录每个 cluster的中心方向。(k-means聚类，用余弦相似度。)</li></ul><p>线上召回</p><ul><li>给定用户ID,找到他的last-n交互的笔记列表，把这些笔记作为种子笔记。</li><li>把每篇种子笔记映射到向量，寻找最相似的cluster (知道了用户对哪些cluster感兴趣)</li><li>从每个cluster的笔记列表中，取回最新的m篇笔记。</li><li>最多取回mn篇新笔记。</li></ul><p>内容相似度模型</p><p><img src="https://gcore.jsdelivr.net/gh/davidliuk/images@master/image-20250825102804585.png" alt="image-20250825102804585" loading="lazy"></p><p>模型的训练</p><p><img src="https://gcore.jsdelivr.net/gh/davidliuk/images@master/image-20250825102913327.png" alt="image-20250825102913327" loading="lazy"></p><p>基本想法：鼓励cos(a,b+)大于cos(a,b-)</p><ul><li>Triplet hinge loss: <ul><li>L(a,bt,b)=max{0,cos(a,b)+m-cos(a,b+)3.</li></ul></li><li>Triplet logistic loss: <ul><li>L(a,bf,b)=log(1+exp(cos(a,b)-cos(a,b+))).</li></ul></li></ul><p>正样本</p><ul><li>方法一：人工标注二元组的相似度</li><li>方法二：算法自动选正样本 <ul><li>筛选条件： <ul><li>·只用高曝光笔记作为二元组（因为有充足的用户交互信息）</li><li>·两篇笔记有相同的二级类目，比如都是“菜谱教程”。</li></ul></li><li>用ItemCF的物品相似度选正样本。</li></ul></li></ul><p>负样本</p><ul><li>从全体笔记中随机选出满足条件的： <ul><li>字数较多（神经网络提取的文本信息有效)</li><li>·笔记质量高，避免图文无关。</li></ul></li></ul><p>总结：</p><ul><li>基本思想：根据用户的点赞、收藏、转发记录，推荐内容相似的笔记。</li><li>线下训练：多模态神经网络把图文内容映射到向量。</li><li>线上服务：用户喜欢的笔记→特征向量最近的Cluster→新笔记</li></ul>',17)]))}const p=e(r,[["render",s],["__file","cluster.html.vue"]]),u=JSON.parse(`{"path":"/ai/rec/cold-start/cluster.html","title":"聚类召回","lang":"en-US","frontmatter":{"description":"聚类召回 基本思想 如果用户喜欢一篇笔记，那么他会喜欢内容相似的笔记。 事先训练一个神经网络，基于笔记的类目和图文内容，把笔记映射到向量。 对笔记向量做聚类，划分为1000 cluster,记录每个 cluster的中心方向。(k-means聚类，用余弦相似度。) 线上召回 给定用户ID,找到他的last-n交互的笔记列表，把这些笔记作为种子笔记。 把...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/ai/rec/cold-start/cluster.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"聚类召回"}],["meta",{"property":"og:description","content":"聚类召回 基本思想 如果用户喜欢一篇笔记，那么他会喜欢内容相似的笔记。 事先训练一个神经网络，基于笔记的类目和图文内容，把笔记映射到向量。 对笔记向量做聚类，划分为1000 cluster,记录每个 cluster的中心方向。(k-means聚类，用余弦相似度。) 线上召回 给定用户ID,找到他的last-n交互的笔记列表，把这些笔记作为种子笔记。 把..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://gcore.jsdelivr.net/gh/davidliuk/images@master/image-20250825102804585.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-08-31T05:52:07.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-31T05:52:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"聚类召回\\",\\"image\\":[\\"https://gcore.jsdelivr.net/gh/davidliuk/images@master/image-20250825102804585.png\\",\\"https://gcore.jsdelivr.net/gh/davidliuk/images@master/image-20250825102913327.png\\"],\\"dateModified\\":\\"2025-08-31T05:52:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[],"git":{"createdTime":1756619527000,"updatedTime":1756619527000,"contributors":[{"name":"dawei.liu","email":"dawei.liu@bytedance.com","commits":1}]},"readingTime":{"minutes":1.54,"words":461},"filePathRelative":"ai/rec/cold-start/cluster.md","localizedDate":"August 31, 2025","excerpt":"\\n<p>基本思想</p>\\n<ul>\\n<li>如果用户喜欢一篇笔记，那么他会喜欢内容相似的笔记。</li>\\n<li>事先训练一个神经网络，基于笔记的类目和图文内容，把笔记映射到向量。</li>\\n<li>对笔记向量做聚类，划分为1000 cluster,记录每个 cluster的中心方向。(k-means聚类，用余弦相似度。)</li>\\n</ul>\\n<p>线上召回</p>\\n<ul>\\n<li>给定用户ID,找到他的last-n交互的笔记列表，把这些笔记作为种子笔记。</li>\\n<li>把每篇种子笔记映射到向量，寻找最相似的cluster (知道了用户对哪些cluster感兴趣)</li>\\n<li>从每个cluster的笔记列表中，取回最新的m篇笔记。</li>\\n<li>最多取回mn篇新笔记。</li>\\n</ul>","autoDesc":true}`);export{p as comp,u as data};
