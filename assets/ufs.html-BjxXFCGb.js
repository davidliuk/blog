import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as n,o}from"./app-DIqbhby7.js";const a={};function p(r,t){return o(),i("div",null,t[0]||(t[0]=[n('<h1 id="union-find-set" tabindex="-1"><a class="header-anchor" href="#union-find-set"><span>Union Find Set</span></a></h1><p>连通性，用一个集合中的某个元素来代表这个集合</p><p>是一种树形的数据结构，用于解决不相交（disjoint）集合的合并及查询问题。</p><ol><li>一般是无向无权图的连通分量，</li><li>也可以拓展至有向带权图（需要一个额外dist数组，如除法求值）</li></ol><p>并查集是树形结构，它用一棵树来表示一个集合，不同的集合其实就构成了一个森林。</p><p>优化方法：</p><ol><li>按秩合并</li><li>路径压缩</li></ol><p>路径压缩会破坏树的结构，在一些情况下是不能使用的，按秩合并则不会</p><p>两种优化可以同时进行，查询操作几乎可以降到O1</p><hr><p>我们可以将每一个变量看作图中的一个节点，把相等的关系 == 看作是连接两个节点的边，那么由于表示相等关系的等式方程具有传递性，即如果 <code>a==b</code> 和 <code>b==c</code> 成立，则 <code>a==c</code> 也成立。也就是说，所有相等的变量属于同一个连通分量。因此，我们可以使用并查集来维护这种连通分量的关系。</p>',11)]))}const s=e(a,[["render",p],["__file","ufs.html.vue"]]),c=JSON.parse(`{"path":"/algo/summary/structure/graph/ufs.html","title":"Union Find Set","lang":"en-US","frontmatter":{"description":"Union Find Set 连通性，用一个集合中的某个元素来代表这个集合 是一种树形的数据结构，用于解决不相交（disjoint）集合的合并及查询问题。 一般是无向无权图的连通分量， 也可以拓展至有向带权图（需要一个额外dist数组，如除法求值） 并查集是树形结构，它用一棵树来表示一个集合，不同的集合其实就构成了一个森林。 优化方法： 按秩合并 路径...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/summary/structure/graph/ufs.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"Union Find Set"}],["meta",{"property":"og:description","content":"Union Find Set 连通性，用一个集合中的某个元素来代表这个集合 是一种树形的数据结构，用于解决不相交（disjoint）集合的合并及查询问题。 一般是无向无权图的连通分量， 也可以拓展至有向带权图（需要一个额外dist数组，如除法求值） 并查集是树形结构，它用一棵树来表示一个集合，不同的集合其实就构成了一个森林。 优化方法： 按秩合并 路径..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-22T03:05:37.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-22T03:05:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Union Find Set\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-22T03:05:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[],"git":{"createdTime":1732244737000,"updatedTime":1732244737000,"contributors":[{"name":"David Liu","email":"liudawei@seas.upenn.edu","commits":1}]},"readingTime":{"minutes":1.02,"words":307},"filePathRelative":"algo/summary/structure/graph/ufs.md","localizedDate":"November 22, 2024","excerpt":"\\n<p>连通性，用一个集合中的某个元素来代表这个集合</p>\\n<p>是一种树形的数据结构，用于解决不相交（disjoint）集合的合并及查询问题。</p>\\n<ol>\\n<li>一般是无向无权图的连通分量，</li>\\n<li>也可以拓展至有向带权图（需要一个额外dist数组，如除法求值）</li>\\n</ol>\\n<p>并查集是树形结构，它用一棵树来表示一个集合，不同的集合其实就构成了一个森林。</p>\\n<p>优化方法：</p>\\n<ol>\\n<li>按秩合并</li>\\n<li>路径压缩</li>\\n</ol>\\n<p>路径压缩会破坏树的结构，在一些情况下是不能使用的，按秩合并则不会</p>\\n<p>两种优化可以同时进行，查询操作几乎可以降到O1</p>","autoDesc":true}`);export{s as comp,c as data};
