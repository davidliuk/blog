import{_ as a,V as e,W as i,a0 as r}from"./framework-705b829b.js";const h={},t=r('<h1 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap" aria-hidden="true">#</a> HashMap</h1><p>capacity，factor</p><p>capacity是元素个数，factor只有构造的时候考虑（容量初始设置比capacity/factor大的第一个2^n），后面还是按3/4</p><h3 id="扩容" tabindex="-1"><a class="header-anchor" href="#扩容" aria-hidden="true">#</a> 扩容</h3><ul><li>1.8及以后，满3/4时就扩容</li><li>1.8以前，超3/4时扩容</li></ul><p>扩容的时候，从后往前迁移</p><p>迁移的时候划分区间来迁移</p><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。</p><h3 id="resize" tabindex="-1"><a class="header-anchor" href="#resize" aria-hidden="true">#</a> Resize</h3><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p><h3 id="treeifybin" tabindex="-1"><a class="header-anchor" href="#treeifybin" aria-hidden="true">#</a> treeifyBin</h3>',11),c=[t];function s(d,n){return e(),i("div",null,c)}const p=a(h,[["render",s],["__file","HashMap.html.vue"]]);export{p as default};
