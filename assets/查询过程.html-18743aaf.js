import{_ as e,V as l,W as o,Z as t}from"./framework-e5d7a6b2.js";const i={},r=t('<h1 id="查询过程" tabindex="-1"><a class="header-anchor" href="#查询过程" aria-hidden="true">#</a> 查询过程</h1><ul><li><p>查询语句的执行流程如下：</p><p>权限校验（如果命中缓存）---&gt;查询缓存---&gt;分析器---&gt;优化器---&gt;权限校验---&gt;执行器---&gt;引擎</p></li><li><p>更新语句执行流程如下：</p><p>分析器----&gt;权限校验----&gt;执行器---&gt;引擎---redo log(prepare 状态)---&gt;binlog---&gt;redo log(commit 状态)</p></li></ul><p>权限校验的时机</p><ul><li><p>连接器</p></li><li><p>命中缓存时</p></li><li><p>执行器、优化器完毕后</p><p>如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p></li></ul><p>更新语句涉及的两阶段提交</p><p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p><ul><li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li><li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li></ul><p>这样就解决了数据一致性的问题。</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h2>',9),p=[r];function a(d,g){return l(),o("div",null,p)}const c=e(i,[["render",a],["__file","查询过程.html.vue"]]);export{c as default};
