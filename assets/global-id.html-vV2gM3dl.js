import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,a as t,o as a}from"./app-wjKRSZHj.js";const d={};function n(p,i){return a(),l("div",null,i[0]||(i[0]=[t('<h1 id="全局-id-生成器" tabindex="-1"><a class="header-anchor" href="#全局-id-生成器"><span>全局 ID 生成器</span></a></h1><h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h2><h3 id="数据库自增主键的问题" tabindex="-1"><a class="header-anchor" href="#数据库自增主键的问题"><span>数据库自增主键的问题</span></a></h3><ul><li>会泄露一些信息，如每天有多少单</li><li>可能会分库分表（分布式存储），如果是数据库的自增主键，那就无法保证 iid 的唯一性了</li></ul><h3 id="全局-id-生成器的特性" tabindex="-1"><a class="header-anchor" href="#全局-id-生成器的特性"><span>全局 ID 生成器的特性</span></a></h3><p>分布式系统下用来生成全局唯一的 ID 的工具，要满足如下特性：</p><ul><li>唯一性</li><li>高可用：什么时候要 id 都能给</li><li>高性能</li><li>递增性：同时还可以有一个统计的效果</li><li>安全性：为增加安全性，我们加入一些其他信息防止被猜出来</li></ul><h3 id="全局唯一-id-生成策略" tabindex="-1"><a class="header-anchor" href="#全局唯一-id-生成策略"><span>全局唯一 ID 生成策略</span></a></h3><ul><li><p>UUID</p><ul><li><p>16 进制，字符串结构</p></li><li><p>缺点：没有自增性质</p></li></ul></li><li><p>Redis 自增</p><p>构造：时间戳+自增 id</p><p>每天一个 key，方便统计订单量，且防止整数溢出</p></li><li><p>数据库自增</p><p>单独一张表，专门负责做自增，分库分表的地方都从他这里取 id</p><p>原理上和 redis 自增一样，只是性能更差，一般不采用这个，如果使用的话，一般是批量获取 id，然后放入内存缓存起来，来提高性能</p></li><li><p>snowflake 算法</p><p>与我们 Redis 的实现方案思路类似，但是 id 自增是机器内部的 id 的自增，需要维护机器内部的 id，分布式系统下比较麻烦，一般还是采用 redis 的方案</p><p>优点：不依赖于 redis，单体的性能会更好</p><p>缺点：对于时钟依赖比较高，如果时间不准确会出现问题</p></li></ul>',9)]))}const s=e(d,[["render",n],["__file","global-id.html.vue"]]),c=JSON.parse(`{"path":"/cs/database/redis/practice/design/global-id.html","title":"全局 ID 生成器","lang":"en-US","frontmatter":{"description":"全局 ID 生成器 基本概念 数据库自增主键的问题 会泄露一些信息，如每天有多少单 可能会分库分表（分布式存储），如果是数据库的自增主键，那就无法保证 iid 的唯一性了 全局 ID 生成器的特性 分布式系统下用来生成全局唯一的 ID 的工具，要满足如下特性： 唯一性 高可用：什么时候要 id 都能给 高性能 递增性：同时还可以有一个统计的效果 安全性...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/cs/database/redis/practice/design/global-id.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"全局 ID 生成器"}],["meta",{"property":"og:description","content":"全局 ID 生成器 基本概念 数据库自增主键的问题 会泄露一些信息，如每天有多少单 可能会分库分表（分布式存储），如果是数据库的自增主键，那就无法保证 iid 的唯一性了 全局 ID 生成器的特性 分布式系统下用来生成全局唯一的 ID 的工具，要满足如下特性： 唯一性 高可用：什么时候要 id 都能给 高性能 递增性：同时还可以有一个统计的效果 安全性..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-27T01:21:47.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-27T01:21:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"全局 ID 生成器\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-27T01:21:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[{"level":3,"title":"数据库自增主键的问题","slug":"数据库自增主键的问题","link":"#数据库自增主键的问题","children":[]},{"level":3,"title":"全局 ID 生成器的特性","slug":"全局-id-生成器的特性","link":"#全局-id-生成器的特性","children":[]},{"level":3,"title":"全局唯一 ID 生成策略","slug":"全局唯一-id-生成策略","link":"#全局唯一-id-生成策略","children":[]}]}],"git":{"createdTime":1680090419000,"updatedTime":1719451307000,"contributors":[{"name":"davidliuk","email":"l729641074@163.com","commits":1},{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":1}]},"readingTime":{"minutes":1.33,"words":400},"filePathRelative":"cs/database/redis/practice/design/global-id.md","localizedDate":"March 29, 2023","excerpt":"\\n<h2>基本概念</h2>\\n<h3>数据库自增主键的问题</h3>\\n<ul>\\n<li>会泄露一些信息，如每天有多少单</li>\\n<li>可能会分库分表（分布式存储），如果是数据库的自增主键，那就无法保证 iid 的唯一性了</li>\\n</ul>\\n<h3>全局 ID 生成器的特性</h3>\\n<p>分布式系统下用来生成全局唯一的 ID 的工具，要满足如下特性：</p>\\n<ul>\\n<li>唯一性</li>\\n<li>高可用：什么时候要 id 都能给</li>\\n<li>高性能</li>\\n<li>递增性：同时还可以有一个统计的效果</li>\\n<li>安全性：为增加安全性，我们加入一些其他信息防止被猜出来</li>\\n</ul>","autoDesc":true}`);export{s as comp,c as data};
