import{_ as s,V as e,W as n,Z as a}from"./framework-e5d7a6b2.js";const i={},r=a(`<h1 id="性能分析" tabindex="-1"><a class="header-anchor" href="#性能分析" aria-hidden="true">#</a> 性能分析</h1><p>索引优化</p><h3 id="sql执行频率" tabindex="-1"><a class="header-anchor" href="#sql执行频率" aria-hidden="true">#</a> SQL执行频率</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> <span class="token punctuation">[</span><span class="token keyword">global</span> <span class="token operator">|</span> <span class="token keyword">session</span><span class="token punctuation">]</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">&#39;Com_______&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以查出来sql的执行频率，来确认数据库中哪个用的最多</p><h3 id="慢查询日志" tabindex="-1"><a class="header-anchor" href="#慢查询日志" aria-hidden="true">#</a> 慢查询日志</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2022-07-28 22.24.40.png" alt="截屏2022-07-28 22.24.40" loading="lazy"></p><p>可以定位执行效率低的SQL</p><h3 id="profile-详情" tabindex="-1"><a class="header-anchor" href="#profile-详情" aria-hidden="true">#</a> profile 详情</h3><p>可以看到所有sql时间耗费在哪</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> @<span class="token variable">@have_profiling</span>
<span class="token keyword">set</span> profiling <span class="token operator">=</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> profiles<span class="token punctuation">;</span>

<span class="token keyword">show</span> profile <span class="token keyword">for</span> query querty_id<span class="token punctuation">;</span>

<span class="token keyword">show</span> profile cpu <span class="token keyword">for</span> query querty_id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="explain-执行计划" tabindex="-1"><a class="header-anchor" href="#explain-执行计划" aria-hidden="true">#</a> explain 执行计划</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2022-07-28 22.30.48.png" alt="截屏2022-07-28 22.30.48" loading="lazy"></p><h2 id="什么是执行计划" tabindex="-1"><a class="header-anchor" href="#什么是执行计划" aria-hidden="true">#</a> 什么是执行计划？</h2><p><strong>执行计划</strong> 是指一条 SQL 语句在经过 <strong>MySQL 查询优化器</strong> 的优化会后，具体的执行方式。</p><p>执行计划通常用于 SQL 性能分析、优化等场景。通过 <code>EXPLAIN</code> 的结果，可以了解到如数据表的查询顺序、数据查询操作的操作类型、哪些索引可以被命中、哪些索引实际会命中、每个数据表有多少行记录被查询等信息。</p><h3 id="type-重要" tabindex="-1"><a class="header-anchor" href="#type-重要" aria-hidden="true">#</a> type（重要）</h3><p>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>常见的几种类型具体含义如下：</p><ul><li><strong>system</strong>：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</li><li><strong>const</strong>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li><li><strong>eq_ref</strong>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</li><li><strong>ref</strong>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li><li><strong>index_merge</strong>：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</li><li><strong>range</strong>：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</li><li><strong>index</strong>：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li><li><strong>ALL</strong>：全表扫描。</li></ul><h3 id="key-重要" tabindex="-1"><a class="header-anchor" href="#key-重要" aria-hidden="true">#</a> key（重要）</h3><p>key 列表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引。</p><h3 id="extra-重要" tabindex="-1"><a class="header-anchor" href="#extra-重要" aria-hidden="true">#</a> Extra（重要）</h3><p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p><ul><li><strong>Using filesort</strong>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li><li><strong>Using temporary</strong>：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</li><li><strong>Using index</strong>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li><li><strong>Using index condition</strong>：表示查询优化器选择使用了索引条件下推这个特性。</li><li><strong>Using where</strong>：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li><li><strong>Using join buffer (Block Nested Loop)</strong>：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</li></ul><p>这里提醒下，当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p>`,27),t=[r];function l(o,d){return e(),n("div",null,t)}const c=s(i,[["render",l],["__file","3. 性能分析.html.vue"]]);export{c as default};
