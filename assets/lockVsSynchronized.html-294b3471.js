const e=JSON.parse(`{"key":"v-55ad3dc0","path":"/se/lang/java/JUC/lock/lockVsSynchronized.html","title":"lock vs sychronized","lang":"en-US","frontmatter":{"description":"lock vs sychronized 语法层面 synchronized是关键字，源码在jvm中，用c++实现 Lock是接口，源码由jdk提供，用java语言实现 使用synchronized时，退出同步代码块锁会自动释放，而使用Lock时，需要手动调用unlock方法释放锁 功能层面 二者均属于悲观锁，都具备基本的互斥、同步、锁重入功能 互斥：就是只有一个拿着锁 同步： synchronize：wait，notify Lock：利用条件变量提供的：await，signal 锁重入：是否可以对已经加上锁的对象加上第二道、第三道锁，到时候解锁也需要解多道 Lock提供了许多synchronized不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量 公平锁：先来先得（吞吐量不如非公平的高），非公平锁：可以插队 可打断、可超时： Lock有适合不同场景的实现，如ReentrantLock，ReentrantReadWriteLock","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/se/lang/java/JUC/lock/lockVsSynchronized.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"lock vs sychronized"}],["meta",{"property":"og:description","content":"lock vs sychronized 语法层面 synchronized是关键字，源码在jvm中，用c++实现 Lock是接口，源码由jdk提供，用java语言实现 使用synchronized时，退出同步代码块锁会自动释放，而使用Lock时，需要手动调用unlock方法释放锁 功能层面 二者均属于悲观锁，都具备基本的互斥、同步、锁重入功能 互斥：就是只有一个拿着锁 同步： synchronize：wait，notify Lock：利用条件变量提供的：await，signal 锁重入：是否可以对已经加上锁的对象加上第二道、第三道锁，到时候解锁也需要解多道 Lock提供了许多synchronized不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量 公平锁：先来先得（吞吐量不如非公平的高），非公平锁：可以插队 可打断、可超时： Lock有适合不同场景的实现，如ReentrantLock，ReentrantReadWriteLock"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-02-03T07:46:32.000Z"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2023-02-03T07:46:32.000Z"}],["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://davidliuk.github.io/blog/blog/zh/se/lang/java/JUC/lock/lockVsSynchronized.html"}]]},"headers":[{"level":2,"title":"语法层面","slug":"语法层面","link":"#语法层面","children":[]},{"level":2,"title":"功能层面","slug":"功能层面","link":"#功能层面","children":[]},{"level":2,"title":"性能层面","slug":"性能层面","link":"#性能层面","children":[]}],"git":{"createdTime":1675410392000,"updatedTime":1675410392000,"contributors":[{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":1}]},"readingTime":{"minutes":0.97,"words":290},"localizedDate":"February 3, 2023","filePathRelative":"se/lang/java/JUC/lock/lockVsSynchronized.md","excerpt":"<h1> lock vs sychronized</h1>\\n<h2> 语法层面</h2>\\n<ul>\\n<li>synchronized是关键字，源码在jvm中，用c++实现</li>\\n<li>Lock是接口，源码由jdk提供，用java语言实现</li>\\n<li>使用synchronized时，退出同步代码块锁会自动释放，而使用Lock时，需要手动调用unlock方法释放锁</li>\\n</ul>\\n<h2> 功能层面</h2>\\n<ul>\\n<li>\\n<p>二者均属于悲观锁，都具备基本的互斥、同步、锁重入功能</p>\\n<p>互斥：就是只有一个拿着锁</p>\\n<p>同步：</p>\\n<ul>\\n<li>synchronize：wait，notify</li>\\n<li>Lock：利用条件变量提供的：await，signal</li>\\n</ul>\\n<p>锁重入：是否可以对已经加上锁的对象加上第二道、第三道锁，到时候解锁也需要解多道</p>\\n</li>\\n<li>\\n<p>Lock提供了许多synchronized不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</p>\\n<p>公平锁：先来先得（吞吐量不如非公平的高），非公平锁：可以插队</p>\\n<p>可打断、可超时：</p>\\n</li>\\n<li>\\n<p>Lock有适合不同场景的实现，如ReentrantLock，ReentrantReadWriteLock</p>\\n</li>\\n</ul>","autoDesc":true}`);export{e as data};
