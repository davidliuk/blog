import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as p,o as i}from"./app-z8Dpj-As.js";const a={};function o(r,e){return i(),n("div",null,e[0]||(e[0]=[p('<h1 id="综合型" tabindex="-1"><a class="header-anchor" href="#综合型"><span>综合型</span></a></h1><p>综合型动态规划<br> 需要辅助数据结构算法（字母树，哈希表，二分查找）的动态规划<br> 万变不离其宗</p><hr><p>Minimum Adjustment Cost</p><p>最后一步：将A改成B,A[n-1]改成X,这一步代价是A[n-1]-X</p><p>需要确保X-B[n-2]&lt;=Target</p><p>前面n-1个元素A[0.n-2]改成B[0.n-2],需要知道最小代价，并确保B[0.n-2]中任意两个相邻的元素的差不超过Target子问题</p><p>但是有一个问题，改A[n-1]时不知道Bn-2]是多少</p><ul><li>只有知道了B[n-2],才能确定A[n-1]能改成B[n-2]-Target&lt;=X&lt;=B[n-2]+Target</li></ul><p>不知道是多少就记录下来：序列加状态</p><p>状态：<code>f[i][j]</code>将A中前i个元素修改成B的最小代价，确保前i个改好的元素中任意两个相邻的元素的差不超过Target，并且A[i-1]改成j</p><p>转移：<code>f[i][j]=min_{j-t&lt;=k&lt;=j+t}{f[i-1][k]}+|j-A[i-1]|</code></p><p>边界：<code>f[1][j]=|j-a[0|</code></p><hr><p>K Sum</p><p>给定数组A，包含n个互不相等的正整数，K个数和是t</p><p>背包，带物品个数限制</p><p>状态：<code>f[i][k][s]</code>表示前i个数中选出k个，使他们的和是s的方案数</p><p>转移：<code>f[i][k][s]=f[i-1][k][s]+f[i-1][k-1][s-a[i-1]|s&gt;=a[i-1]</code></p><p>边界：<code>f[0][0][0]=1,f[0][0][s]=0</code></p><hr><p>LIS</p><p>要是求优化</p><p>最后变成那个卡牌了</p><hr><p>K Edit Distance</p><p>trie 树上dp（状态转移的路径在树上）</p><p>dp只依赖于之前的一条递归路径，所以可以无需额外怎么穿一个大状态的f数组，f数组跟着dfs带着跑，放在一个状态里</p><p>写起来思路和二叉树上打家劫舍比较像</p><hr><p>frog jump</p><p>坐标+状态型DP</p><p>状态：<code>f[i][j]</code>表示是否能最后一跳j到a[i]</p><p>转移：<code>f[i][j]=f[k][j-1] || f[k][j] || f[k][j+1] | a[k]=a[i]-j</code></p><p>设上一块石头是ak=ai-j,可以通过一个哈希表(ak→k)快速找到k</p><p>边界：<code>f[1][1]=true | a[1]-a[0]=1</code></p>',36)]))}const c=t(a,[["render",o],["__file","难题.html.vue"]]),l=JSON.parse(`{"path":"/algo/summary/optimise/dynamic-programming/%E8%BF%9B%E9%98%B6/%E9%9A%BE%E9%A2%98.html","title":"综合型","lang":"en-US","frontmatter":{"description":"综合型 综合型动态规划 需要辅助数据结构算法（字母树，哈希表，二分查找）的动态规划 万变不离其宗 Minimum Adjustment Cost 最后一步：将A改成B,A[n-1]改成X,这一步代价是A[n-1]-X 需要确保X-B[n-2]<=Target 前面n-1个元素A[0.n-2]改成B[0.n-2],需要知道最小代价，并确保B[0.n-2]...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/summary/optimise/dynamic-programming/%E8%BF%9B%E9%98%B6/%E9%9A%BE%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"综合型"}],["meta",{"property":"og:description","content":"综合型 综合型动态规划 需要辅助数据结构算法（字母树，哈希表，二分查找）的动态规划 万变不离其宗 Minimum Adjustment Cost 最后一步：将A改成B,A[n-1]改成X,这一步代价是A[n-1]-X 需要确保X-B[n-2]<=Target 前面n-1个元素A[0.n-2]改成B[0.n-2],需要知道最小代价，并确保B[0.n-2]..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-01-01T21:36:31.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-01T21:36:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"综合型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-01T21:36:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[],"git":{"createdTime":1732244737000,"updatedTime":1735767391000,"contributors":[{"name":"David Liu","email":"liudawei@seas.upenn.edu","commits":1},{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro-3.local","commits":1}]},"readingTime":{"minutes":1.84,"words":553},"filePathRelative":"algo/summary/optimise/dynamic-programming/进阶/难题.md","localizedDate":"November 22, 2024","excerpt":"\\n<p>综合型动态规划<br>\\n需要辅助数据结构算法（字母树，哈希表，二分查找）的动态规划<br>\\n万变不离其宗</p>\\n<hr>\\n<p>Minimum Adjustment Cost</p>\\n<p>最后一步：将A改成B,A[n-1]改成X,这一步代价是A[n-1]-X</p>\\n<p>需要确保X-B[n-2]&lt;=Target</p>\\n<p>前面n-1个元素A[0.n-2]改成B[0.n-2],需要知道最小代价，并确保B[0.n-2]中任意两个相邻的元素的差不超过Target子问题</p>\\n<p>但是有一个问题，改A[n-1]时不知道Bn-2]是多少</p>\\n<ul>\\n<li>只有知道了B[n-2],才能确定A[n-1]能改成B[n-2]-Target&lt;=X&lt;=B[n-2]+Target</li>\\n</ul>","autoDesc":true}`);export{c as comp,l as data};
