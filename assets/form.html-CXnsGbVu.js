import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a,o as i}from"./app-TGRQBxvj.js";const l={};function o(r,e){return i(),n("div",null,e[0]||(e[0]=[a('<h1 id="form" tabindex="-1"><a class="header-anchor" href="#form"><span>Form</span></a></h1><p>数据库范式有 4 种：</p><ul><li>1NF(第一范式)：属性不可再分。</li><li>2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li><li>3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖</li><li>BCNF</li></ul><hr><ul><li>属性：对应于表中的字段</li><li>主属性：在一个关系中，如果一个属性是构成某一个候选关键字（候选码）的属性集中的一个属性，则称它为主属性。</li></ul><h3 id="_1nf" tabindex="-1"><a class="header-anchor" href="#_1nf"><span>1NF</span></a></h3><p>属性不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。</p><p><strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p><p>mysql表中，只要每个字段对应一个属性，那么就符合第一范式。当然，也有不符合第一范式的例子。比如某个字段是json数据（json对象不是又可以分为多个key-value么，这多个key-value就相当于切割成多个属性了，所以不符合第一范式。</p><p>所以说为什么NoSql大多不符合第一范式，因为redis或者mongodb存的基本是各种嵌套json）</p><h3 id="_2nf" tabindex="-1"><a class="header-anchor" href="#_2nf"><span>2NF</span></a></h3><p>在 1NF 的基础上，消除非主属性对主码的部分函数依赖（非码属性必须完全依赖于候选码）</p><p>如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p><h3 id="_3nf" tabindex="-1"><a class="header-anchor" href="#_3nf"><span>3NF</span></a></h3><p>在 2NF 基础上，消除传递依赖（任何非主属性不依赖于其它非主属性）</p><h3 id="bcnf" tabindex="-1"><a class="header-anchor" href="#bcnf"><span>BCNF</span></a></h3><p>在 3NF 基础上，任何主属性不能对主键子集依赖（消除主属性对主码子集的依赖）</p>',17)]))}const c=t(l,[["render",o],["__file","form.html.vue"]]),d=JSON.parse(`{"path":"/cs/database/sql/design/form.html","title":"Form","lang":"en-US","frontmatter":{"description":"Form 数据库范式有 4 种： 1NF(第一范式)：属性不可再分。 2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。 3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 BCNF 属性：对应于表中的字段 主属性：在一个关系中，如果一个属性是构成某一个候选关键字（候选码）的属性集中的一个属...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/cs/database/sql/design/form.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"Form"}],["meta",{"property":"og:description","content":"Form 数据库范式有 4 种： 1NF(第一范式)：属性不可再分。 2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。 3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 BCNF 属性：对应于表中的字段 主属性：在一个关系中，如果一个属性是构成某一个候选关键字（候选码）的属性集中的一个属..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-05-28T07:57:19.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-28T07:57:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Form\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-28T07:57:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":3,"title":"1NF","slug":"_1nf","link":"#_1nf","children":[]},{"level":3,"title":"2NF","slug":"_2nf","link":"#_2nf","children":[]},{"level":3,"title":"3NF","slug":"_3nf","link":"#_3nf","children":[]},{"level":3,"title":"BCNF","slug":"bcnf","link":"#bcnf","children":[]}],"git":{"createdTime":1715153702000,"updatedTime":1748419039000,"contributors":[{"name":"dawei.liu","email":"dawei.liu@bytedance.com","commits":1}]},"readingTime":{"minutes":1.61,"words":484},"filePathRelative":"cs/database/sql/design/form.md","localizedDate":"May 8, 2024","excerpt":"\\n<p>数据库范式有 4 种：</p>\\n<ul>\\n<li>1NF(第一范式)：属性不可再分。</li>\\n<li>2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li>\\n<li>3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖</li>\\n<li>BCNF</li>\\n</ul>\\n<hr>\\n<ul>\\n<li>属性：对应于表中的字段</li>\\n<li>主属性：在一个关系中，如果一个属性是构成某一个候选关键字（候选码）的属性集中的一个属性，则称它为主属性。</li>\\n</ul>\\n<h3>1NF</h3>\\n<p>属性不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。</p>","autoDesc":true}`);export{c as comp,d as data};
