import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as e,d as a}from"./app-9107e99b.js";const t={},r=a('<h1 id="线程安全" tabindex="-1"><a class="header-anchor" href="#线程安全" aria-hidden="true">#</a> 线程安全</h1><h2 id="并发编程三要素" tabindex="-1"><a class="header-anchor" href="#并发编程三要素" aria-hidden="true">#</a> 并发编程三要素</h2><ul><li>可见性，一个线程对共享变量修改，另外的线程能立即看到最新值。</li><li>有序性，一个线程内代码按编写顺序执行（多线程下不能）由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</li><li>原子性，一个线程内多行代码以一个整体运行，期间不难有其他线程的代码插队</li></ul><h3 id="原子性" tabindex="-1"><a class="header-anchor" href="#原子性" aria-hidden="true">#</a> <strong>原子性</strong></h3><ul><li>起因：多线程下，不同线程的<strong>指令发生了交错</strong>导致的共享变量的读写混乱</li><li>解决：用悲观锁或乐观锁解决，volatile 并不能解决原子性</li></ul><h3 id="可见性" tabindex="-1"><a class="header-anchor" href="#可见性" aria-hidden="true">#</a> <strong>可见性</strong></h3><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致的对共享变量所做的修改另外的线程看不到</li><li>解决：用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</li></ul><h3 id="有序性" tabindex="-1"><a class="header-anchor" href="#有序性" aria-hidden="true">#</a> <strong>有序性</strong></h3><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致指令的实际执行顺序与编写顺序不一致</li><li>解决：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li><li>注意： <ul><li><strong>volatile 变量写</strong>加的屏障是阻止上方其它写操作越过屏障排到 <strong>volatile 变量写</strong>之下</li><li><strong>volatile 变量读</strong>加的屏障是阻止下方其它读操作越过屏障排到 <strong>volatile 变量读</strong>之上</li><li>volatile 读写加入的屏障只能防止同一线程内的指令重排</li></ul></li></ul><p>volatile 能够保证共享变量的可见性与有序性，但是并不难保证原子性</p><p>volatile 关键字可以禁止指令进行重排序优化</p><p>原子性的实现</p><ul><li>锁</li><li>CAS</li></ul><p>指令交错，就会导致问题</p><p>在 Java 中，<code>Unsafe</code> 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：</p>',15),o=[r];function n(s,d){return i(),e("div",null,o)}const u=l(t,[["render",n],["__file","index.html.vue"]]);export{u as default};
