import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as i,o as l}from"./app-CGXHKXsa.js";const p={};function a(r,e){return l(),t("div",null,e[0]||(e[0]=[i('<h1 id="topological-sort" tabindex="-1"><a class="header-anchor" href="#topological-sort"><span>Topological Sort</span></a></h1><p>拓扑排序</p><p>入度(In-degree)：有向图(Directed Graph)中指向当前节点的点的个数(或指向当前节点的边的条数)</p><p>步骤：</p><ol><li>统计每个点的入度</li><li>将每个入度为 0 的点放入队列(Queue)中作为起始节点</li><li>不断从队列中拿出一个点， <ol><li>去掉这个点的所有连边(指向其他点的边)， <ol><li>其他点的相应的入度 - 1</li><li>一旦发现新的入度为 0 的点，丢回队列中</li></ol></li></ol></li></ol><p>拓扑排序并不是传统的排序算法</p><p>一个图可能存在多个拓扑序(Topological Order)，也可能不存在任何拓扑序</p><p>拓扑排序的四种不同问法</p><ol><li>求任意一个拓扑序</li><li>问是否存在拓扑序</li><li>求是否存在且仅存在一个拓扑序</li><li>求字典序最小的拓扑排序</li></ol><hr><p>求任意一个拓扑排序</p><p>一个个把点从图中抠出来</p><hr><p>判断是否存在拓扑排序</p><p>所有节点均能从图中被删除进入拓扑序</p><hr><p>问拓扑序是否唯一</p><p>保持队列中有且仅有一个元素</p><hr><p>求字典序最小的拓扑排序</p><p>优先队列</p><p>alienOrder</p>',22)]))}const m=o(p,[["render",a],["__file","topo.html.vue"]]),d=JSON.parse(`{"path":"/algo/summary/search/BFS/topo.html","title":"Topological Sort","lang":"en-US","frontmatter":{"description":"Topological Sort 拓扑排序 入度(In-degree)：有向图(Directed Graph)中指向当前节点的点的个数(或指向当前节点的边的条数) 步骤： 统计每个点的入度 将每个入度为 0 的点放入队列(Queue)中作为起始节点 不断从队列中拿出一个点， 去掉这个点的所有连边(指向其他点的边)， 其他点的相应的入度 - 1 一旦发现...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/summary/search/BFS/topo.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"Topological Sort"}],["meta",{"property":"og:description","content":"Topological Sort 拓扑排序 入度(In-degree)：有向图(Directed Graph)中指向当前节点的点的个数(或指向当前节点的边的条数) 步骤： 统计每个点的入度 将每个入度为 0 的点放入队列(Queue)中作为起始节点 不断从队列中拿出一个点， 去掉这个点的所有连边(指向其他点的边)， 其他点的相应的入度 - 1 一旦发现..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-02-10T22:57:15.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-10T22:57:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Topological Sort\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-10T22:57:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[],"git":{"createdTime":1732244737000,"updatedTime":1739228235000,"contributors":[{"name":"David Liu","email":"liudawei@seas.upenn.edu","commits":2},{"name":"David","email":"l729641074@163.com","commits":1},{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro-3.local","commits":1}]},"readingTime":{"minutes":1.03,"words":310},"filePathRelative":"algo/summary/search/BFS/topo.md","localizedDate":"November 22, 2024","excerpt":"\\n<p>拓扑排序</p>\\n<p>入度(In-degree)：有向图(Directed Graph)中指向当前节点的点的个数(或指向当前节点的边的条数)</p>\\n<p>步骤：</p>\\n<ol>\\n<li>统计每个点的入度</li>\\n<li>将每个入度为 0 的点放入队列(Queue)中作为起始节点</li>\\n<li>不断从队列中拿出一个点，\\n<ol>\\n<li>去掉这个点的所有连边(指向其他点的边)，\\n<ol>\\n<li>其他点的相应的入度 - 1</li>\\n<li>一旦发现新的入度为 0 的点，丢回队列中</li>\\n</ol>\\n</li>\\n</ol>\\n</li>\\n</ol>\\n<p>拓扑排序并不是传统的排序算法</p>","autoDesc":true}`);export{m as comp,d as data};
