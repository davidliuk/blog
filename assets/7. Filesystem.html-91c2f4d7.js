import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,d as p}from"./app-9107e99b.js";const n={},i=p(`<h1 id="_7-文件系统" tabindex="-1"><a class="header-anchor" href="#_7-文件系统" aria-hidden="true">#</a> 7. 文件系统</h1><p>IDE</p><p>SCSI</p><p>移动硬盘</p><p>hd</p><p>sd 开头是窜口磁盘</p><p>默认是 8e，Linux LVM，现在是 83</p><p>Disk Partitions</p><h3 id="make-filesyste" tabindex="-1"><a class="header-anchor" href="#make-filesyste" aria-hidden="true">#</a> make filesyste</h3><p>创建文件系统</p><p>Windows 目录森林，每个文件系统都是一棵树</p><p>Unix 只有一个根，把他们嫁接成一个树，需要有一个 mount point，挂载点，一般喜欢找到一个空目录 mnt 进行挂载（因为会把原目录里的文件遮蔽）</p><p>lost+found</p><p>取消挂载：umount+目录名或者设备名都可以</p><p>mount 上去</p><p>link number 不为 0 的文件，就放在 lost+found</p><p>Mount -o ro：只读，不能被修改</p><p>fuser 可以查看谁在用哪个硬盘</p><p>LVM</p><p>mkfs 在分好区的硬盘上构建一个文件系统，在逻辑上进行组织</p><p>文件系统：</p><ol><li><p>超级块</p></li><li><p>i 节点表</p><p>ls -l 里面所有的信息都来自 i 节点 i-node(FCB)</p><p>一个 i 节点有 13 个指针，第 11 块指针指向的块只存他指向的块的指针（非常多），12 块就是上一类块的指针（根本用不完这么多）</p><p>ls -i 一开始的序号就是 i 节点的序号</p></li><li><p>blocks</p></li></ol><p>磁盘配额</p><p>目录就是一张表，存的就是所有的 i 节点信息</p><p>entry：文件，从哪个目录里面出现一下</p><p>文件移动，只需要修改两个目录就可以了，所以非常快</p><h3 id="链接" tabindex="-1"><a class="header-anchor" href="#链接" aria-hidden="true">#</a> 链接</h3><h4 id="ln-link" tabindex="-1"><a class="header-anchor" href="#ln-link" aria-hidden="true">#</a> ln：link</h4><p>i 节点一样，同一个文件</p><p>unix 不允许一个目录的链接</p><p>rm 删除就是文件链接数据，如果链接数是 0 的时候，就释放（没法删掉，只是以后别人可以占用这里）</p><p>删除的只是，把这个链接删掉了，用工具去扫描硬盘就可以看到里面所有的东西</p><p>文件名不用在 i 节点，文件名是目录赋予他的，可以有多个名字（考虑 ln）</p><h4 id="ln-s" tabindex="-1"><a class="header-anchor" href="#ln-s" aria-hidden="true">#</a> ln -s</h4><p>符号链接，就是快捷方式，可以一起改内容</p><p>符号链接可以做链接</p><h3 id="权限" tabindex="-1"><a class="header-anchor" href="#权限" aria-hidden="true">#</a> 权限</h3><ol><li><p>第一位：4bit，文件类型</p><ul><li><code>-</code> 文件</li><li><code>d</code> 目录</li><li><code>l</code> 符号链接</li><li><code>b</code> 块设备：硬盘</li><li><code>c</code> 字符设备：tty、mice</li></ul></li><li><p>st_mode，</p></li></ol><p>rwx：文件夹的 rwx，r 是 ls，x 是 cd，w 是里面内容的增删改查，不能 cd 就不能操作了</p><p>st_mode，16bit</p><p>Type: setuid: setgid: sticky; rwx(user); rwx(group); rwx(other)</p><p>s：setid 被置为 1 了，执行这个的时候以 uid 的身份运行，passwd 在运行的时候就是 root 权限了</p><p>setuid 的程序，应该少用，容易被人攻克，人家就拿到 root 了</p><p>8 进制写法</p><p>共享目录：<code>chmod 1777 sticky</code>，只允许目录的所有者删除或重命名，其他用户只具有该目录的写入权限</p><p>sticky，</p><p>粘滞位通常在公共目录上使用，如 /tmp 目录，以确保只有文件的所有者能够删除文件。这样可以防止其他用户意外或恶意地删除其他用户的文件，提高了文件的安全性和保护用户数据的完整性。</p><p>以下是粘滞位的一些常见用途和优势：</p><p>防止误删除：当多个用户共享同一个目录时，粘滞位可以防止用户误删除其他用户的文件。只有文件的所有者才能删除自己的文件，其他用户只能删除自己创建的文件。</p><p>防止恶意操作：粘滞位还可以防止恶意用户删除或篡改其他用户的文件。只有目录的所有者才有权限对其中的文件进行修改。</p><p>公共目录的安全性：在公共目录（如 /tmp）中启用粘滞位可以确保每个用户只能删除自己的临时文件，而不能删除其他用户的文件。这对于多个用户同时使用公共目录非常有用。</p><p>要设置粘滞位，可以使用 chmod 命令并在权限设置中添加数字 1 或符号 +t。例如，chmod +t directoryname 将为目录设置粘滞位。</p><p>请注意，粘滞位只对目录有效，对于文件没有任何影响。</p><h3 id="filesystem-table" tabindex="-1"><a class="header-anchor" href="#filesystem-table" aria-hidden="true">#</a> Filesystem Table</h3><p>临时文件，重启之后有效就挂载一下 etc/fstab，告诉系统重启以后如何挂载</p><p>mount -a</p><p>sda1 专门放 boot</p><p>boot 进去以后</p><p>逻辑卷，虚拟的，好处很多</p><p>swap 交换空间，可以是独立分区，也可以是一个文件，一般是用放一个独立分区</p><h3 id="disk-use" tabindex="-1"><a class="header-anchor" href="#disk-use" aria-hidden="true">#</a> Disk use</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">du</span> <span class="token operator">&lt;</span>目录<span class="token operator">&gt;</span> <span class="token comment"># 每个文件的每个目录占多大</span>
<span class="token function">du</span> <span class="token parameter variable">-s</span> <span class="token operator">&lt;</span>目录<span class="token operator">&gt;</span> <span class="token comment"># 总共占多少</span>
<span class="token function">du</span> <span class="token parameter variable">-ms</span> <span class="token operator">&lt;</span>目录<span class="token operator">&gt;</span>

<span class="token function">df</span> <span class="token operator">&lt;</span>文件系统<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>没有物理安全就没有信息安全</p><p><code>umask</code> 可以杜绝用户无意之间的权限给的太多的问题</p><p><code>chmod</code> 修改文件权限</p><p><code>chown</code> 修改文件的 owner</p><p><code>chgrp</code> 修改用户组</p><h3 id="acl" tabindex="-1"><a class="header-anchor" href="#acl" aria-hidden="true">#</a> ACL</h3><p>可以给每一个用户一个独一无二的权限（也可以给一个目录）</p><p>挂载的时候，打开 ACL 选项（好用，但是开销比较大）</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>getfacl <span class="token operator">&lt;</span>file name<span class="token operator">&gt;</span>
 <span class="token parameter variable">-m</span> u::<span class="token comment"># 修改权限</span>
 <span class="token parameter variable">-x</span> <span class="token comment"># 删掉一个权限</span>
setfacl
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ACL mask 给一个最大的权限，所有人的权限不超过这个</p><p>copy ACL</p><p>给一个目录设置一个 ACL 权限，然后下面所有的文件都有权限</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>setfacl <span class="token parameter variable">-dm</span> u: <span class="token comment"># 多了一个d，可以让所有人都可以</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>乔布斯讲 iCloud，标准的 presentation 的范本，presentation 的条理性</p><p>m1 性能很好，但是写入写出很多，很耗硬盘</p>`,77),t=[i];function l(d,o){return a(),s("div",null,t)}const h=e(n,[["render",l],["__file","7. Filesystem.html.vue"]]);export{h as default};
