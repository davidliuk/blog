import{_ as e,V as a,W as t,a0 as r}from"./framework-705b829b.js";const c={},n=r('<h1 id="死锁分析" tabindex="-1"><a class="header-anchor" href="#死锁分析" aria-hidden="true">#</a> 死锁分析</h1><h2 id="为什么会产生死锁" tabindex="-1"><a class="header-anchor" href="#为什么会产生死锁" aria-hidden="true">#</a> 为什么会产生死锁？</h2><p>可重复读隔离级别下，是存在幻读的问题。</p><p><strong>Innodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁</strong>，它是记录锁和间隙锁的组合。</p><ul><li>Record Lock，记录锁，锁的是记录本身；</li><li>Gap Lock，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。</li></ul><p>普通的 select 语句是不会对记录加锁的，因为它是通过 MVCC 的机制实现的快照读，如果要在查询时对记录加行锁，可以使用下面这两个方式：</p>',6),o=[n];function s(i,_){return a(),t("div",null,o)}const l=e(c,[["render",s],["__file","死锁分析.html.vue"]]);export{l as default};
