import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as t,o}from"./app-UiaY2OnX.js";const h={};function s(c,e){return o(),a("div",null,e[0]||(e[0]=[t('<blockquote><p>JDK追求的是通用性，而Netty则专注于高并发和网络通信。</p></blockquote><p>我们可以通过几个具体的例子来看看它们在实现上的区别。</p><h3 id="_1-threadlocal-实现" tabindex="-1"><a class="header-anchor" href="#_1-threadlocal-实现"><span>1. ThreadLocal )实现</span></a></h3><p>JDK的ThreadLocal采用的是<a href="https://www.zhihu.com/search?q=%E9%9D%9E%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%A3%E5%88%97%E6%B3%95&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">非波拉契散列法</a>和开放寻址。这种设计可以保证在大多数情况下，数据在内存中的分布更均匀，减少了碰撞的可能性。但在高并发场景下，这种实现还是有点力不从心。</p><p>而Netty的FastThreadLocal则采取了数组下标递增的方式。这么做的好处是，完全避免了哈希碰撞，也不需要rehash操作，因此在高并发情况下性能更好。</p><p>例如：</p><p>我们在一个高并发的<a href="https://www.zhihu.com/search?q=%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">交易系统</a>中，原来用的是JDK的ThreadLocal，结果频繁的碰撞导致性能瓶颈。换成Netty的FastThreadLocal后，性能瓶颈问题得到了很大缓解，系统吞吐量也显著提升。</p><h3 id="_2-堆外内存释放机制" tabindex="-1"><a class="header-anchor" href="#_2-堆外内存释放机制"><span>2. 堆外内存释放机制</span></a></h3><p>JDK提供的<a href="https://www.zhihu.com/search?q=DirectByteBuffer&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">DirectByteBuffer</a>会在初始化时默认开启Cleaner，这样在DirectByteBuffer被GC时，Cleaner会自动调用<a href="https://www.zhihu.com/search?q=clean()&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">clean()</a>方法清理堆外内存，避免<a href="https://www.zhihu.com/search?q=%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">内存泄漏</a>。</p><blockquote><p>不过，这种机制也带来了额外的性能开销。</p></blockquote><p>Netty为了提升性能，引入了No Cleaner策略，通过retain/release手动管理内存释放。</p><p>这种方式虽然提高了性能，但也增加了内存泄漏的风险。</p><blockquote><p>值得注意的是，[Netty 5](<a href="https://www.zhihu.com/search?q=Netty" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/search?q=Netty</a> 5&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A3508007258})已经将No Cleaner策略默认关闭，需要通过指定<a href="https://www.zhihu.com/search?q=JVM&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">JVM</a>启动参数来开启。</p></blockquote><p>例如： 之前我们在一个需要频繁分配和释放内存的项目中，使用JDK的DirectByteBuffer导致了大量的GC和性能开销。改用Netty的No Cleaner策略后，GC次数减少了，性能也提升了。</p><p>不过，我们也遇到了内存泄漏的问题，最后还是在代码中仔细管理了内存的分配和释放。</p><h3 id="_3-线程池实现" tabindex="-1"><a class="header-anchor" href="#_3-线程池实现"><span>3. 线程池实现</span></a></h3><p>JDK的线程池用的是<a href="https://www.zhihu.com/search?q=BlockingQueue&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">BlockingQueue</a>来保存任务队列，线程从这个队列获取任务时会产生锁竞争，进而降低性能。</p><p>Netty则通过每个<a href="https://www.zhihu.com/search?q=channel&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">channel</a>固定绑定一个IO线程（<a href="https://www.zhihu.com/search?q=NioEventLoop&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">NioEventLoop</a>），这个线程会处理该channel上的所有IO任务，从而避免了线程池级别的任务竞争。另外，为了解决IO线程内部的任务队列竞争，Netty使用了<a href="https://www.zhihu.com/search?q=JCTools&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">JCTools</a>提供的MpscQueue（多生产者单消费者队列），利用<a href="https://www.zhihu.com/search?q=CAS&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">CAS</a>操作避免了JDK中BlockingQueue的锁竞争。</p><h3 id="_4-网络传输性能" tabindex="-1"><a class="header-anchor" href="#_4-网络传输性能"><span>4. 网络传输性能</span></a></h3><p>JDK的NIO和Netty在网络传输性能上的差异也很明显。</p><p>JDK的NIO虽然引入了<a href="https://www.zhihu.com/search?q=%E9%9D%9E%E9%98%BB%E5%A1%9EI%2FO&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">非阻塞I/O</a>，但在处理大数据量传输时，其<a href="https://www.zhihu.com/search?q=%E9%9B%B6%E6%8B%B7%E8%B4%9D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">零拷贝</a>机制（FileChannel.<a href="https://www.zhihu.com/search?q=transferTo&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">transferTo</a>）在实际应用中往往并不理想。</p><p>其实现过程中可能会涉及多次用户态到<a href="https://www.zhihu.com/search?q=%E5%86%85%E6%A0%B8%E6%80%81&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">内核态</a>的切换，导致性能不如预期。</p><p>Netty在这方面进行了大量优化。它提供了高效的零拷贝技术，如直接缓冲区和<a href="https://www.zhihu.com/search?q=CompositeByteBuf&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">CompositeByteBuf</a>，使得在处理大数据量传输时，减少了内存复制操作，显著提高了传输性能。</p><p><strong>例如</strong>： 在一个需要处理大文件传输的系统中，最初我们使用JDK的FileChannel.transferTo方法，结果发现传输速度并不理想，CPU使用率也较高。改用Netty的零拷贝机制后，传输速度明显提升，CPU占用率也大幅降低。</p><h3 id="_5-消息编解码" tabindex="-1"><a class="header-anchor" href="#_5-消息编解码"><span>5. 消息编解码</span></a></h3><p>JDK的NIO提供了基本的ByteBuffer操作，但在实际开发中，消息的编解码往往比较繁琐，需要开发者自己处理字节的读写和<a href="https://www.zhihu.com/search?q=%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">协议解析</a>。</p><p>Netty提供了丰富的编解码器，如ProtobufEncoder/Decoder、<a href="https://www.zhihu.com/search?q=HttpObjectDecoder&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">HttpObjectDecoder</a>等，使得开发者可以方便地处理各种协议的编解码。这些编解码器不仅功能强大，而且性能也经过了精心优化。</p><h3 id="_6-连接管理" tabindex="-1"><a class="header-anchor" href="#_6-连接管理"><span>6. 连接管理</span></a></h3><p>JDK的NIO在处理大量短连接时表现不佳，频繁的连接创建和销毁会带来很大的性能开销，尤其是当连接数达到几千甚至几万时，系统的性能会急剧下降。</p><p>Netty通过优化连接管理，提高了系统的吞吐量。它支持<a href="https://www.zhihu.com/search?q=%E8%BF%9E%E6%8E%A5%E6%B1%A0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">连接池</a>和长连接，可以有效减少连接创建和销毁的开销，提高了连接处理效率。</p><h3 id="_7-事件驱动模型" tabindex="-1"><a class="header-anchor" href="#_7-事件驱动模型"><span>7. 事件驱动模型</span></a></h3><p>JDK的NIO提供了基本的事件驱动机制，但其Selector的实现比较低效，在高并发场景下，Selector的性能往往无法满足需求。</p><p>Netty的<a href="https://www.zhihu.com/search?q=%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">事件驱动模型</a>通过NioEventLoop优化了事件处理机制，减少了不必要的系统调用和上下文切换，提高了事件处理的效率。同时，Netty还支持多种事件类型和优先级调度，灵活性更高。</p><h3 id="_8-安全性和稳定性" tabindex="-1"><a class="header-anchor" href="#_8-安全性和稳定性"><span>8. 安全性和稳定性</span></a></h3><p>JDK在<a href="https://www.zhihu.com/search?q=%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">网络编程</a>中的安全性和稳定性方面虽然有一定保障，但其默认实现往往不够灵活，不能满足复杂场景下的需求。</p><p>Netty在安全性方面提供了更丰富的支持</p><p>例如，Netty内置了对SSL/<a href="https://www.zhihu.com/search?q=TLS&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">TLS</a>的支持，并且可以通过<a href="https://www.zhihu.com/search?q=SSLContextBuilder&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D" target="_blank" rel="noopener noreferrer">SSLContextBuilder</a>等工具方便地配置安全参数。</p><p>此外，Netty的错误处理机制也更为完善，能够更好地应对各种异常情况，提升了系统的稳定性。</p><p><strong>例如</strong>： 在一个需要高安全性的支付系统中，我们最初使用JDK的SSL实现，但配置和管理比较复杂，性能也不够理想。改用Netty的SSL支持后，配置变得更加简便，安全性和性能也都有了明显提升。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>总的来说，Netty认为JDK的许多实现不够高效，主要是因为Netty在高并发、网络通信等场景下进行了大量专门的优化。</p><p>这些优化不仅提升了性能，还简化了开发过程，使得开发者可以更专注于业务逻辑。</p><p>对于需要处理高并发和大数据量传输的应用，Netty无疑是一个更好的选择。</p>',43)]))}const i=r(h,[["render",s],["__file","Untitled.html.vue"]]),l=JSON.parse(`{"path":"/se/lang/java/framework/web/netty/Untitled.html","title":"","lang":"en-US","frontmatter":{"description":"JDK追求的是通用性，而Netty则专注于高并发和网络通信。 我们可以通过几个具体的例子来看看它们在实现上的区别。 1. ThreadLocal )实现 JDK的ThreadLocal采用的是非波拉契散列法和开放寻址。这种设计可以保证在大多数情况下，数据在内存中的分布更均匀，减少了碰撞的可能性。但在高并发场景下，这种实现还是有点力不从心。 而Netty...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/se/lang/java/framework/web/netty/Untitled.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:description","content":"JDK追求的是通用性，而Netty则专注于高并发和网络通信。 我们可以通过几个具体的例子来看看它们在实现上的区别。 1. ThreadLocal )实现 JDK的ThreadLocal采用的是非波拉契散列法和开放寻址。这种设计可以保证在大多数情况下，数据在内存中的分布更均匀，减少了碰撞的可能性。但在高并发场景下，这种实现还是有点力不从心。 而Netty..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-09T18:37:53.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-09T18:37:53.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-09T18:37:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":3,"title":"1. ThreadLocal )实现","slug":"_1-threadlocal-实现","link":"#_1-threadlocal-实现","children":[]},{"level":3,"title":"2. 堆外内存释放机制","slug":"_2-堆外内存释放机制","link":"#_2-堆外内存释放机制","children":[]},{"level":3,"title":"3. 线程池实现","slug":"_3-线程池实现","link":"#_3-线程池实现","children":[]},{"level":3,"title":"4. 网络传输性能","slug":"_4-网络传输性能","link":"#_4-网络传输性能","children":[]},{"level":3,"title":"5. 消息编解码","slug":"_5-消息编解码","link":"#_5-消息编解码","children":[]},{"level":3,"title":"6. 连接管理","slug":"_6-连接管理","link":"#_6-连接管理","children":[]},{"level":3,"title":"7. 事件驱动模型","slug":"_7-事件驱动模型","link":"#_7-事件驱动模型","children":[]},{"level":3,"title":"8. 安全性和稳定性","slug":"_8-安全性和稳定性","link":"#_8-安全性和稳定性","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1719451307000,"updatedTime":1731177473000,"contributors":[{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro-3.local","commits":1}]},"readingTime":{"minutes":6.51,"words":1954},"filePathRelative":"se/lang/java/framework/web/netty/Untitled.md","localizedDate":"June 27, 2024","excerpt":"<blockquote>\\n<p>JDK追求的是通用性，而Netty则专注于高并发和网络通信。</p>\\n</blockquote>\\n<p>我们可以通过几个具体的例子来看看它们在实现上的区别。</p>\\n<h3>1. ThreadLocal )实现</h3>\\n<p>JDK的ThreadLocal采用的是<a href=\\"https://www.zhihu.com/search?q=%E9%9D%9E%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%A3%E5%88%97%E6%B3%95&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3508007258%7D\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">非波拉契散列法</a>和开放寻址。这种设计可以保证在大多数情况下，数据在内存中的分布更均匀，减少了碰撞的可能性。但在高并发场景下，这种实现还是有点力不从心。</p>","autoDesc":true}`);export{i as comp,l as data};
