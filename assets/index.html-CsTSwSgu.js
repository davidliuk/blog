import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as e,o as l}from"./app-B6aCd_WP.js";const a={};function o(r,i){return l(),n("div",null,i[0]||(i[0]=[e('<h1 id="类加载" tabindex="-1"><a class="header-anchor" href="#类加载"><span>类加载</span></a></h1><h2 id="类的生命周期" tabindex="-1"><a class="header-anchor" href="#类的生命周期"><span>类的生命周期</span></a></h2><p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：</p><ul><li>加载（Loading）</li><li>连接（Linking） <ul><li>验证（Verification）</li><li>准备（Preparation）</li><li>解析（Resolution）</li></ul></li><li>初始化（Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始， 这是为了支持 Java 语言的运行时绑定特性(也称为动态绑定或晚期绑定)。</p><blockquote><p>是按部就班地“开始”，而不是按部就班地“进行”或按部就班地“完成”，强调这点是因为这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</p></blockquote><h2 id="类加载时机" tabindex="-1"><a class="header-anchor" href="#类加载时机"><span>类加载时机</span></a></h2><h3 id="主动引用" tabindex="-1"><a class="header-anchor" href="#主动引用"><span>主动引用</span></a></h3><p>主动引用<strong>一定会</strong>触发类加载（实例化（两种）、调用静态方法或变量、</p><p>主动引用的场景：</p><ol><li><p>当虚拟机启动时，用户需要指定一个要执行的<strong>主类</strong>(包含 main()方法的那个类)，虚拟机会先初始化这个主类。</p></li><li><p>遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。</p><p>能够生成这四条指令的典型 Java 代码场景有：</p><ul><li><p>使用 new 关键字实例化对象的时候。</p></li><li><p>读取或设置一个类型的静态字段的时候。</p><p>被 final 修饰、已在编译期把结果放入<strong>常量池</strong>的静态字段除外</p></li><li><p>调用一个类型的静态方法的时候。</p></li></ul></li><li><p>当初始化类的时候，如果发现其<strong>父类</strong>还没有进行过初始化，则需要先触发其父类的初始化。</p></li><li><p>当一个接口中定义了 JDK 8 新加入的默认方法(被 default 关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p></li><li><p>使用 java.lang.reflect 包的方法对类型进行<strong>反射</strong>调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</p></li><li><p>当使用 JDK 7 新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p></li></ol><p>这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用</p><h3 id="被动引用" tabindex="-1"><a class="header-anchor" href="#被动引用"><span>被动引用</span></a></h3><p>被动引用<strong>不会</strong>触发类加载</p><ul><li>通过<strong>子类引用父类的静态字段</strong>，不会导致子类初始化（父类会初始化）</li><li>通过<strong>数组</strong>定义来引用类，不会触发此类的初始化</li><li><strong>常量</strong>在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类</li></ul>',15)]))}const c=t(a,[["render",o],["__file","index.html.vue"]]),d=JSON.parse(`{"path":"/se/lang/java/jvm/%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F/%E7%B1%BB%E5%8A%A0%E8%BD%BD/","title":"类加载","lang":"en-US","frontmatter":{"description":"类加载 类的生命周期 类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段： 加载（Loading） 连接（Linking） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading） 加载、验...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/se/lang/java/jvm/%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"类加载"}],["meta",{"property":"og:description","content":"类加载 类的生命周期 类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段： 加载（Loading） 连接（Linking） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading） 加载、验..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-27T01:21:47.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-27T01:21:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类加载\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-27T01:21:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"类的生命周期","slug":"类的生命周期","link":"#类的生命周期","children":[]},{"level":2,"title":"类加载时机","slug":"类加载时机","link":"#类加载时机","children":[{"level":3,"title":"主动引用","slug":"主动引用","link":"#主动引用","children":[]},{"level":3,"title":"被动引用","slug":"被动引用","link":"#被动引用","children":[]}]}],"git":{"createdTime":1680090419000,"updatedTime":1719451307000,"contributors":[{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":1}]},"readingTime":{"minutes":2.8,"words":840},"filePathRelative":"se/lang/java/jvm/执行系统/类加载/README.md","localizedDate":"March 29, 2023","excerpt":"\\n<h2>类的生命周期</h2>\\n<p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：</p>\\n<ul>\\n<li>加载（Loading）</li>\\n<li>连接（Linking）\\n<ul>\\n<li>验证（Verification）</li>\\n<li>准备（Preparation）</li>\\n<li>解析（Resolution）</li>\\n</ul>\\n</li>\\n<li>初始化（Initialization）</li>\\n<li>使用（Using）</li>\\n<li>卸载（Unloading）</li>\\n</ul>\\n<p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始， 这是为了支持 Java 语言的运行时绑定特性(也称为动态绑定或晚期绑定)。</p>","autoDesc":true}`);export{c as comp,d as data};
