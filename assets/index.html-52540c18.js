import{_ as o,V as r,W as i,X as e,Y as t,$ as l,Z as a,E as p}from"./framework-e5d7a6b2.js";const s={},c=a('<h1 id="排序" tabindex="-1"><a class="header-anchor" href="#排序" aria-hidden="true">#</a> 排序</h1><h2 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h2><p>按时间复杂度分类</p><ul><li><p>O(n)</p><p>如，基数排序、桶排序、计数排序</p></li><li><p>O(nlogn)</p><p>如，快速排序、归并排序、队排序</p></li><li><p>O(n2)</p><p>如，插入排序、简单选择排序、简单希尔排序</p></li><li><p>其他</p><p>优化希尔排序可以达到O(n^7/6)但是仍然没有Onlogn优秀，故一般不采纳</p></li></ul><p>按排序方式分类</p><ul><li><p>基于交换类</p><p>效率的上限就是Onlogn</p></li><li><p>非交换类</p><p>上限可以是On</p></li></ul><p>按稳定性分类</p><ul><li><p>稳定排序</p><p>如，归并排序、桶排序</p></li><li><p>非稳定排序</p><p>如，快速排序、堆排序</p></li></ul><h2 id="术语" tabindex="-1"><a class="header-anchor" href="#术语" aria-hidden="true">#</a> 术语</h2><ul><li><strong>稳定</strong>：如果 A 原本在 B 前面，而 A=B，排序之后 A 仍然在 B 的前面。</li><li><strong>不稳定</strong>：如果 A 原本在 B 的前面，而 A=B，排序之后 A 可能会出现在 B 的后面。</li><li><strong>内排序</strong>：所有排序操作都在内存中完成。</li><li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li><li><strong>时间复杂度</strong>： 定性描述一个算法执行所耗费的时间。</li><li><strong>空间复杂度</strong>：定性描述一个算法执行所需内存的大小。</li></ul><p>三种partition</p>',11),d={href:"https://wenku.baidu.com/view/2cc7720e4873f242336c1eb91a37f111f1850db1.html?_wkts_=1675070336179&bdQuery=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FLomoto",target:"_blank",rel:"noopener noreferrer"},h={href:"https://blog.csdn.net/qq_42902997/article/details/115773598",target:"_blank",rel:"noopener noreferrer"},_=e("p",null,"三路快排：",-1),u=e("p",null,"<, =, > 三路，优化重复元素多的情况",-1);function f(g,b){const n=p("ExternalLinkIcon");return r(),i("div",null,[c,e("p",null,[e("a",d,[t("https://wenku.baidu.com/view/2cc7720e4873f242336c1eb91a37f111f1850db1.html?_wkts_=1675070336179&bdQuery=快速排序Lomoto"),l(n)])]),e("p",null,[e("a",h,[t("https://blog.csdn.net/qq_42902997/article/details/115773598"),l(n)])]),_,u])}const B=o(s,[["render",f],["__file","index.html.vue"]]);export{B as default};
