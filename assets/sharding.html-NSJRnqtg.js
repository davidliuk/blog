import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a as n,o as i}from"./app-TGRQBxvj.js";const t={};function o(d,a){return i(),r("div",null,a[0]||(a[0]=[n('<h1 id="sharding-分库分表" tabindex="-1"><a class="header-anchor" href="#sharding-分库分表"><span>Sharding 分库分表</span></a></h1><blockquote><p>ShardingSphere</p></blockquote><p>读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下：<strong>如果 MySQL 一张表的数据量过大怎么办?</strong></p><p>换言之，<strong>我们该如何解决 MySQL 的存储压力呢？</strong></p><p>答案之一就是 <strong>分库分表</strong>。</p><h3 id="分库" tabindex="-1"><a class="header-anchor" href="#分库"><span>分库</span></a></h3><p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。</p><h4 id="垂直分库" tabindex="-1"><a class="header-anchor" href="#垂直分库"><span><strong>垂直分库</strong></span></a></h4><p>就是把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。</p><p>举个例子：说你将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库。</p><h4 id="水平分库" tabindex="-1"><a class="header-anchor" href="#水平分库"><span><strong>水平分库</strong></span></a></h4><p>是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。</p><p>举个例子：订单表数据量太大，你对订单表进行了水平切分（水平分表），然后将切分后的 2 张订单表分别放在两个不同的数据库。</p><h3 id="分表" tabindex="-1"><a class="header-anchor" href="#分表"><span>分表</span></a></h3><p><strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p><h4 id="垂直分表" tabindex="-1"><a class="header-anchor" href="#垂直分表"><span><strong>垂直分表</strong></span></a></h4><p>是对数据表列的拆分，把一张列比较多的表拆分为多张表。</p><p>举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。</p><h4 id="水平分表" tabindex="-1"><a class="header-anchor" href="#水平分表"><span><strong>水平分表</strong></span></a></h4><p>是对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</p><p>举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p><p>水平拆分只能解决单表数据量大的问题，为了提升性能，我们通常会选择将拆分后的多张表放在不同的数据库中。也就是说，水平分表通常和水平分库同时出现。</p><h3 id="什么情况下需要分库分表" tabindex="-1"><a class="header-anchor" href="#什么情况下需要分库分表"><span>什么情况下需要分库分表？</span></a></h3><p>遇到下面几种场景可以考虑分库分表：</p><ul><li>单表的数据达到千万级别以上，数据库读写速度比较缓慢。</li><li>数据库中的数据占用的空间越来越大，备份时间越来越长。</li><li>应用的并发量太大。</li></ul><h2 id="shardingsphere" tabindex="-1"><a class="header-anchor" href="#shardingsphere"><span>ShardingSphere</span></a></h2><h3 id="sharding-jdbc" tabindex="-1"><a class="header-anchor" href="#sharding-jdbc"><span>Sharding-JDBC</span></a></h3><p>Sharding-JDBC的定位是一款轻量级Java框架，它会以POM依赖的形式嵌入程序，运行期间会和Java应用共享资源，这款框架的本质可以理解成是JDBC的增强版，只不过Java原生的JDBC仅支持单数据源的连接，而Sharding-JDBC则支持多数据源的管理，部署形态如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4147aa9a9ccb6fb588bd143c1dd5e588.png" alt="img" loading="lazy"></p><p>Java-ORM框架在执行SQL语句时，Sharding-JDBC会以切面的形式拦截发往数据库的语句，接着根据配置好的数据源、分片规则和路由键，为SQL选择一个目标数据源，然后再发往对应的数据库节点处理。</p><blockquote><p>Sharding-JDBC在整个业务系统中对性能损耗极低，但为何后面又会推出Sharding-Proxy呢？因为Sharding-JDBC配置较为麻烦，比如在分布式系统中，任何使用分库分表的服务都需要单独配置多数据源地址、路由键、分片策略....等信息，同时它也仅支持Java语言，当一个系统是用多语言异构的，此时其他语言开发的子服务，则无法使用分库分表策略。</p></blockquote><h3 id="sharding-proxy" tabindex="-1"><a class="header-anchor" href="#sharding-proxy"><span>Sharding-Proxy</span></a></h3><p>也正是由于配置无法统一管理、不支持异构系统的原因，后面又引入<code>Sharding-Proxy</code>来解决这两个问题，<code>Sharding-Proxy</code>可以将其理解成一个伪数据库，对于应用程序而言是完全透明的，它会以中间件的形式独立部署在系统中，部署形态如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/182015f2df7d8be01216440a6c5e6d9b.png" alt="img" loading="lazy"></p><p>使用Sharding-Proxy的子服务都会以连接数据库的形式，与其先建立数据库连接，然后将SQL发给它执行，Sharding-Proxy会根据分片规则和路由键，将SQL语句发给具体的数据库节点处理，数据库节点处理完成后，又会将结果集返回给Sharding-Proxy，最终再由它将结果集返回给具体的子服务。</p><p>但Sharding-Proxy虽然可以实现分库分表配置的统一管理，以及支持异构的系统，但因为需要使用独立的机器部署，同时还会依赖Zookeeper作为注册中心，所以硬件成本会直线增高，至少需要多出3~4台服务器来部署。</p><p>同时SQL执行时，需要先发给Proxy，再由Proxy发给数据库节点，执行完成后又会从数据库返回到Proxy，再由Proxy返回给具体的应用，这个过程会经过四次网络传输的动作，因此相较于原本的Sharding-JDBC来说，性能、资源开销更大，响应速度也会变慢。</p><h3 id="jdbc、proxy" tabindex="-1"><a class="header-anchor" href="#jdbc、proxy"><span>JDBC、Proxy</span></a></h3><p>如果用驱动式分库分表，虽然能够让Java程序的性能最好，但无法支持多语言异构的系统，但如果纯用代理式分库分表，这显然会损害Java程序的性能，因此在Sharding-Sphere中也支持JDBC、Proxy做混合式部署，也就是Java程序用JDBC做分库分表，其他语言的子服务用Proxy做分库分表，部署形态如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0f848ef1b1acba2be9c0a7c998db796e.png" alt="img" loading="lazy"></p><p>这种混合式的部署方案，所有的数据分片策略都会放到Zookeeper中统一管理，然后所有的子服务都去Zookeeper中拉取配置文件，这样就能很方便的根据业务情况，来灵活的搭建适用于各种场景的应用系统，这样也能够让数据源、分片策略、路由键....等配置信息灵活，可以在线上动态修改配置信息，修改后能够在线上环境中动态感知。</p><p>但Sharding-Sphere还提供了一种单机模式，即直接将数据分片配置放在Proxy中，但这种方式仅适用于开发环境，因为无法将分片配置同步给多个实例使用，也就意味着会导致其他实例由于感知不到配置变化，从而造成配置信息不一致的错误。</p>',42)]))}const h=e(t,[["render",o],["__file","sharding.html.vue"]]),g=JSON.parse(`{"path":"/cs/database/mysql/availability/sharding.html","title":"Sharding 分库分表","lang":"en-US","frontmatter":{"description":"Sharding 分库分表 ShardingSphere 读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下：如果 MySQL 一张表的数据量过大怎么办? 换言之，我们该如何解决 MySQL 的存储压力呢？ 答案之一就是 分库分表。 分库 分库 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。 垂直分库 就是把单...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/cs/database/mysql/availability/sharding.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"Sharding 分库分表"}],["meta",{"property":"og:description","content":"Sharding 分库分表 ShardingSphere 读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下：如果 MySQL 一张表的数据量过大怎么办? 换言之，我们该如何解决 MySQL 的存储压力呢？ 答案之一就是 分库分表。 分库 分库 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。 垂直分库 就是把单..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://i-blog.csdnimg.cn/blog_migrate/4147aa9a9ccb6fb588bd143c1dd5e588.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-12-09T14:30:53.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-09T14:30:53.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Sharding 分库分表\\",\\"image\\":[\\"https://i-blog.csdnimg.cn/blog_migrate/4147aa9a9ccb6fb588bd143c1dd5e588.png\\",\\"https://i-blog.csdnimg.cn/blog_migrate/182015f2df7d8be01216440a6c5e6d9b.png\\",\\"https://i-blog.csdnimg.cn/blog_migrate/0f848ef1b1acba2be9c0a7c998db796e.png\\"],\\"dateModified\\":\\"2025-12-09T14:30:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":3,"title":"分库","slug":"分库","link":"#分库","children":[]},{"level":3,"title":"分表","slug":"分表","link":"#分表","children":[]},{"level":3,"title":"什么情况下需要分库分表？","slug":"什么情况下需要分库分表","link":"#什么情况下需要分库分表","children":[]},{"level":2,"title":"ShardingSphere","slug":"shardingsphere","link":"#shardingsphere","children":[{"level":3,"title":"Sharding-JDBC","slug":"sharding-jdbc","link":"#sharding-jdbc","children":[]},{"level":3,"title":"Sharding-Proxy","slug":"sharding-proxy","link":"#sharding-proxy","children":[]},{"level":3,"title":"JDBC、Proxy","slug":"jdbc、proxy","link":"#jdbc、proxy","children":[]}]}],"git":{"createdTime":1684318252000,"updatedTime":1765290653000,"contributors":[{"name":"David Liu","email":"davidliu02k@gmail.com","commits":1},{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":1}]},"readingTime":{"minutes":5.6,"words":1680},"filePathRelative":"cs/database/mysql/availability/sharding.md","localizedDate":"May 17, 2023","excerpt":"\\n<blockquote>\\n<p>ShardingSphere</p>\\n</blockquote>\\n<p>读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下：<strong>如果 MySQL 一张表的数据量过大怎么办?</strong></p>\\n<p>换言之，<strong>我们该如何解决 MySQL 的存储压力呢？</strong></p>\\n<p>答案之一就是 <strong>分库分表</strong>。</p>\\n<h3>分库</h3>\\n<p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。</p>\\n<h4><strong>垂直分库</strong></h4>","autoDesc":true}`);export{h as comp,g as data};
