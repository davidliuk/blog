import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as p,o as c}from"./app-D4ZvIHfO.js";const d={};function t(a,e){return c(),o("div",null,e[0]||(e[0]=[p('<h1 id="二维型" tabindex="-1"><a class="header-anchor" href="#二维型"><span>二维型</span></a></h1><p>Unique Paths</p><p>状态：<code>f[i][j]</code>表示到坐标i,j位置的方案数</p><p>转移：<code>f[i][j]=f[i-1][j]+f[i][j-1]</code></p><p>边界：<code>f[0][0]=1</code></p><hr><p>Unique Paths II</p><blockquote><p>有些各自有障碍物，不能通过</p></blockquote><p>状态：<code>f[i][j]</code>表示到坐标i,j位置的方案数</p><p>转移：<code>f[i][j]=f[i-1][j]+f[i][j-1], 0|g[i][j]==1</code></p><p>边界：<code>f[0][0]=1</code></p><hr><p>Minimum Path Sum</p><blockquote><p>(0,0)到(m-1,n-1)的最小花费</p></blockquote><p>状态：<code>f[i][j]</code>表示到坐标i,j位置的最小花费</p><p>转移：<code>f[i][j]=min{f[i-1][j], f[i][j-1]}+A[i][j]</code></p><p>边界：<code>f[0][j], f[i][0]</code></p><p>空间优化：如果只依赖于前面的k列，则可以滚动数组</p><hr><p>Triangle 数字三角形</p><p>状态：<code>f[i][j]</code>表示到坐标i,j位置的最小花费</p><p>转移：<code>f[i][j]=min{f[i-1][j],f[i][j-1]}+a[i][j]</code></p><p>边界：<code>f[0][0]=a[0][0]</code></p><p>答案：<code>min{f[n-1][j]}</code></p><hr><p>Maximal Square 全1正方形</p><blockquote><p>求一个01矩阵中，全为1的正方形个数</p></blockquote><p>状态：</p><ul><li><code>f[i][j]</code>表示到坐标i,j位置的方案数</li><li><code>left[i][j]</code>表示i,j往左连续的1最长多长</li><li><code>up[i][j]</code>表示i,j往上连续的1最长多长</li></ul><p>转移：</p><p><code>0|m[i][j]==0</code></p><ul><li><code>left[i][j]=left[i][j-1]+1</code></li><li><code>up[i][j]=up[i-1][j]+1</code></li><li><code>f[i][j]=min{up[i-1][j], left[i][j-1], f[i-1][j-1]}+1</code></li></ul><p>边界：</p><ul><li><code>d[i][0],left[i][0],up[i][0]=m[i][0]</code></li><li><code>d[0][j],left[0][j],up[0][j=m[0][j]</code></li></ul><p>答案：<code>sum{dp[i][j]}</code></p><p>滚动数组，滚i，开2大小，答案在计算dp数组的时候累计</p><hr><p>Maximal Square II</p><blockquote><p>找最大的对角线全1其他都0的正方形</p></blockquote><hr><p>Knight Shortest Paths II</p><blockquote><p>只能向右面的 4 个方向跳，求左上到右下最短路径</p></blockquote><p>状态：<code>f[i][j]</code>表示到坐标i,j位置的最小步数</p><p>转移：<code>min{f[i-][j-]}</code></p><p>边界：<code>f[i][j]=inf,f[0][0]=0</code></p><p>答案：<code>f[n-1][m-1]</code></p><h3 id="逆向" tabindex="-1"><a class="header-anchor" href="#逆向"><span>逆向</span></a></h3><p>矩阵的终点的状态已知，起点状态为止，求起点状态</p><p>174 地下城游戏</p><p>状态：<code>f[i][j]</code>表示从i,j到n-1,m-1的最小HP</p><p>转移：<code>f[i][j]=max{1,max{f[i+1][j],f[i][j+1]}-grid[i][j]}</code></p><p>边界：<code>f[n][i]=inf,f[n][m-1]=1</code></p><p>答案：<code>f[0][0]</code></p><hr><p>1444 Number of Ways of Cutting a Pizza</p><p>状态：<code>f[k][i][j]</code>表示切k刀从i,j到n-1,m-1的方案数</p><p>转移：<code>f[k][i][j]=sum{f[k-1][i][j2]}+sum{f[k-1][i2][j]}</code></p><p>边界：<code>f[0][i][j]=1,sufSum(i,j)&gt;0</code></p><p>答案：<code>f[k][0][0]</code></p><h2 id="子矩阵" tabindex="-1"><a class="header-anchor" href="#子矩阵"><span>子矩阵</span></a></h2><blockquote><p>从子串型延展的，依然 Kadane 算法</p></blockquote><p>3148 矩阵中的最大得分</p><p>状态：<code>f[i][j]</code>表示以坐标i,j结尾的最大分数</p><p>转移：<code>f[i][j]=grid[i][j]+Math.max(Math.max(0,f[i-1][j])-grid[i-1][j], Math.max(0,f[i][j-1])-grid[i][j-1])</code></p><p>答案：<code>max{f[i][j]}</code></p><p>统计全为 1 的正方形子矩阵</p>',66)]))}const f=i(d,[["render",t],["__file","2d.html.vue"]]),l=JSON.parse(`{"path":"/algo/summary/optimise/dynamic-programming/%E5%9D%90%E6%A0%87/2d.html","title":"二维型","lang":"en-US","frontmatter":{"description":"二维型 Unique Paths 状态：f[i][j]表示到坐标i,j位置的方案数 转移：f[i][j]=f[i-1][j]+f[i][j-1] 边界：f[0][0]=1 Unique Paths II 有些各自有障碍物，不能通过 状态：f[i][j]表示到坐标i,j位置的方案数 转移：f[i][j]=f[i-1][j]+f[i][j-1], 0|g[...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/summary/optimise/dynamic-programming/%E5%9D%90%E6%A0%87/2d.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"二维型"}],["meta",{"property":"og:description","content":"二维型 Unique Paths 状态：f[i][j]表示到坐标i,j位置的方案数 转移：f[i][j]=f[i-1][j]+f[i][j-1] 边界：f[0][0]=1 Unique Paths II 有些各自有障碍物，不能通过 状态：f[i][j]表示到坐标i,j位置的方案数 转移：f[i][j]=f[i-1][j]+f[i][j-1], 0|g[..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-12-04T01:12:41.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-04T01:12:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二维型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-04T01:12:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":3,"title":"逆向","slug":"逆向","link":"#逆向","children":[]},{"level":2,"title":"子矩阵","slug":"子矩阵","link":"#子矩阵","children":[]}],"git":{"createdTime":1733274761000,"updatedTime":1733274761000,"contributors":[{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro-3.local","commits":1}]},"readingTime":{"minutes":2.45,"words":734},"filePathRelative":"algo/summary/optimise/dynamic-programming/坐标/2d.md","localizedDate":"December 4, 2024","excerpt":"\\n<p>Unique Paths</p>\\n<p>状态：<code>f[i][j]</code>表示到坐标i,j位置的方案数</p>\\n<p>转移：<code>f[i][j]=f[i-1][j]+f[i][j-1]</code></p>\\n<p>边界：<code>f[0][0]=1</code></p>\\n<hr>\\n<p>Unique Paths II</p>\\n<blockquote>\\n<p>有些各自有障碍物，不能通过</p>\\n</blockquote>\\n<p>状态：<code>f[i][j]</code>表示到坐标i,j位置的方案数</p>\\n<p>转移：<code>f[i][j]=f[i-1][j]+f[i][j-1], 0|g[i][j]==1</code></p>","autoDesc":true}`);export{f as comp,l as data};
