import{_ as c,V as d,W as r,X as e,Y as o,$ as l,Z as t,E as n}from"./framework-e5d7a6b2.js";const h={},s=t('<h1 id="threadlocal" tabindex="-1"><a class="header-anchor" href="#threadlocal" aria-hidden="true">#</a> ThreadLocal</h1><p>解决线程安全问题的另一种思路，之前是共享资源加锁或 CAS 重试，现在是线程隔离各用各的。</p><p>作用：</p><ul><li>实现资源对象的线程隔离，让每个线程各用各的资源对象，避免争用引发的线程安全问题</li><li>实现了线程内的资源共享</li></ul><p>局部变量，可以线程隔离，但是不能跨方法</p><p><code>Thread</code>类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>。</p><p><code>ThreadLocalMap</code>有自己的独立实现，可以简单地将它的<code>key</code>视作<code>ThreadLocal</code>，<code>value</code>为代码中放入的值（实际上<code>key</code>并不是<code>ThreadLocal</code>本身，而是它的一个<strong>弱引用</strong>）。</p><p>每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了<strong>线程隔离</strong>。</p><p><code>ThreadLocalMap</code>有点类似<code>HashMap</code>的结构，只是<code>HashMap</code>是由<strong>数组+链表</strong>实现的，而<code>ThreadLocalMap</code>中并没有<strong>链表</strong>结构。</p><p>我们还要注意<code>Entry</code>， 它的<code>key</code>是<code>ThreadLocal&lt;?&gt; k</code> ，继承自<code>WeakReference</code>， 也就是我们常说的弱引用类型。</p><h1 id="为什么-map-的-key-要设置成弱引用呢" tabindex="-1"><a class="header-anchor" href="#为什么-map-的-key-要设置成弱引用呢" aria-hidden="true">#</a> 为什么 Map 的 key 要设置成弱引用呢？？</h1>',11),p={href:"https://so.csdn.net/so/search?q=%E5%A0%86%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},_=e("p",null,[o("并且这个线程始终在运行(比如说线程池复用连接)，那么久而久之，堆内存里的 ThreadLocal 就无法被回收，造成"),e("code",null,"内存泄露"),o("。")],-1),i=e("p",null,"而设计成弱引用的话，在每次 GC 时，发现没有其他强引用指向 ThreadLocal 了，便会将其回收",-1),L=e("p",null,"概括说就是:在方法中新建一个线程本地对象，就有一个强引用指向它，在调用 set()后，线程的 ThreadLocaMap 对象里的 Entry 对象又有一个引用 k 指向它。如果后面这个引用 k 是强引用就会使方法执行完，栈帧中的强引用销毁了，对象还不能回收，造成严重的内存泄露。",-1),T=e("p",null,[e("strong",null,"那为什么不设置成软引用呢？？我自己思考的话：应该就是让没有引用的尽快回收，而不用等到内存不够在回收")],-1);function u(k,M){const a=n("ExternalLinkIcon");return d(),r("div",null,[s,e("p",null,[o("因为如果我们 ThreadLocalMap 中的 ThreadLocal 不设置成弱引用，设置成强引用的话，如果外界已经将所有引用 ThreadLocal 的地方设置为了 null(也就是不再使用了)，但是我们的 Map 里的 key 还指向"),e("a",p,[o("堆内存"),l(a)]),o("里的 ThreadLocal 呢，而我们又不能直接操控 Map。")]),_,i,L,T])}const m=c(h,[["render",u],["__file","threadlocal.html.vue"]]);export{m as default};
