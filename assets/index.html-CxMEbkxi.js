import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as l,o as r}from"./app-B_TQ4tbw.js";const i={};function a(o,e){return r(),t("div",null,e[0]||(e[0]=[l('<h1 id="decrease-conquer" tabindex="-1"><a class="header-anchor" href="#decrease-conquer"><span>Decrease Conquer</span></a></h1><p>减治</p><p>减少问题规模</p><p>在广义“有序“的线性结构上搜索</p><p><strong>反向有序</strong>：两侧性质相反</p><ul><li>二分：每次减一半</li><li>倍增：每次扩一半，看看是否合法</li><li>双指针：减少组合复杂度的空间</li></ul><p><strong>结构有序</strong>：每次减一半</p><ul><li>基于二分查找存储化的结构 <ul><li>数组：树状数组</li><li>链表：跳表</li><li>树： <ul><li>B+树</li><li>线段树</li><li>分块树</li></ul></li></ul></li></ul><p><strong>删除有序</strong>：每次减的不一定</p><ul><li>单调栈</li><li>单调队列</li></ul><p><strong>贪心有序</strong>：减少排列和组合复杂度的空间</p><ul><li>贪心法</li></ul><p>如上的减治每一种都可以用在动规里面对动规进行优化</p><hr><ul><li><strong>减一个常量</strong>，常常是减1(例如插入排序)。</li><li><strong>减一个常因子</strong>，常常是减去因子2(例如折半查找)。</li><li><strong>减可变规模</strong>，例如欧几里得算法).</li></ul><p><a href="https://blog.csdn.net/huanghanqian/article/details/79088171" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/huanghanqian/article/details/79088171</a></p><h3 id="减常因子算法" tabindex="-1"><a class="header-anchor" href="#减常因子算法"><span>减常因子算法</span></a></h3><p>减常因子算法的例子有：用天平来辨别假币、俄式乘法、约瑟夫斯问题、<a href="https://so.csdn.net/so/search?q=%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">折半查找</a>、用平方求幂。</p><h4 id="假币问题" tabindex="-1"><a class="header-anchor" href="#假币问题"><span>假币问题</span></a></h4><blockquote><p>在n枚外观相同的硬币中，有一枚是假币。在一架天平上，我们可以比较任意两组硬币，得知哪一组比另一组更重，但不知道重多少。假币比真币轻。要求设计算法检测这枚假币。<br> 折半查找不是最高效的解法。</p></blockquote><p>把硬币分成三堆，每堆n/3个硬币更好。<br> 代码实现假币问题的三分算法：</p><h3 id="减可变规模" tabindex="-1"><a class="header-anchor" href="#减可变规模"><span>减可变规模</span></a></h3><p><strong>减可变规模算法</strong>的一次迭代和另一次迭代时消减的规模是变化的。例子如：欧几里得算法、选择问题的基于分区的算法、插值查找和二叉查找树中的查找及插入操作。</p><h4 id="计算中值和选择问题" tabindex="-1"><a class="header-anchor" href="#计算中值和选择问题"><span>计算中值和选择问题</span></a></h4><blockquote><p><strong>选择问题</strong>是求一个n个数列表的第k个最小元素的问题。这个数字被称为第k个顺序统计量。<br> 这个问题的一个更有意思的情况是在k=n/2时，它要求找出这样一个元素，该元素比列表中的一半元素大，又比另一半元素小。这个中间的值被称为<strong>中值</strong>。</p></blockquote><p><strong>中值问题的思路</strong>：先假设s是分区的分割位置。如果s=k，中轴p就是选择问题的解。如果s&gt;k，p是s的左边区域中第k小的元素。如果s&lt;k，p是s的右边区域中第k-s小的元素。从而减小问题规模。</p>',26)]))}const c=n(i,[["render",a],["__file","index.html.vue"]]),u=JSON.parse(`{"path":"/algo/summary/optimise/decrease-conquer/","title":"Decrease Conquer","lang":"en-US","frontmatter":{"description":"Decrease Conquer 减治 减少问题规模 在广义“有序“的线性结构上搜索 反向有序：两侧性质相反 二分：每次减一半 倍增：每次扩一半，看看是否合法 双指针：减少组合复杂度的空间 结构有序：每次减一半 基于二分查找存储化的结构 数组：树状数组 链表：跳表 树： B+树 线段树 分块树 删除有序：每次减的不一定 单调栈 单调队列 贪心有序：减少...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/summary/optimise/decrease-conquer/"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"Decrease Conquer"}],["meta",{"property":"og:description","content":"Decrease Conquer 减治 减少问题规模 在广义“有序“的线性结构上搜索 反向有序：两侧性质相反 二分：每次减一半 倍增：每次扩一半，看看是否合法 双指针：减少组合复杂度的空间 结构有序：每次减一半 基于二分查找存储化的结构 数组：树状数组 链表：跳表 树： B+树 线段树 分块树 删除有序：每次减的不一定 单调栈 单调队列 贪心有序：减少..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-01-01T21:36:31.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-01T21:36:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Decrease Conquer\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-01T21:36:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":3,"title":"减常因子算法","slug":"减常因子算法","link":"#减常因子算法","children":[]},{"level":3,"title":"减可变规模","slug":"减可变规模","link":"#减可变规模","children":[]}],"git":{"createdTime":1732244737000,"updatedTime":1735767391000,"contributors":[{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro-3.local","commits":2},{"name":"David Liu","email":"liudawei@seas.upenn.edu","commits":1}]},"readingTime":{"minutes":2.17,"words":651},"filePathRelative":"algo/summary/optimise/decrease-conquer/README.md","localizedDate":"November 22, 2024","excerpt":"\\n<p>减治</p>\\n<p>减少问题规模</p>\\n<p>在广义“有序“的线性结构上搜索</p>\\n<p><strong>反向有序</strong>：两侧性质相反</p>\\n<ul>\\n<li>二分：每次减一半</li>\\n<li>倍增：每次扩一半，看看是否合法</li>\\n<li>双指针：减少组合复杂度的空间</li>\\n</ul>\\n<p><strong>结构有序</strong>：每次减一半</p>\\n<ul>\\n<li>基于二分查找存储化的结构\\n<ul>\\n<li>数组：树状数组</li>\\n<li>链表：跳表</li>\\n<li>树：\\n<ul>\\n<li>B+树</li>\\n<li>线段树</li>\\n<li>分块树</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}`);export{c as comp,u as data};
