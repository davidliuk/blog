import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as n}from"./app-BtADw1TI.js";const l={};function t(h,s){return n(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="函数" tabindex="-1"><a class="header-anchor" href="#函数"><span>函数</span></a></h1><h2 id="聚合函数" tabindex="-1"><a class="header-anchor" href="#聚合函数"><span>聚合函数</span></a></h2><p>将一组数据通过运算返回这组数据的某种性质，如最大值，最小值。</p><p>没有元素的时候返回null</p><p><strong>聚合函数类型</strong></p><ul><li>AVG()</li><li>SUM()</li><li>MAX()</li><li>MIN()</li><li>COUNT()</li><li>VARIANCE() 和 STDDEV()</li><li>GROUP_CONCAT()</li></ul><h3 id="avg" tabindex="-1"><a class="header-anchor" href="#avg"><span>AVG()</span></a></h3><p>AVG(c.action = &#39;confirmed&#39;)</p><p>= sum(if(c.action = &#39;confirmed&#39;, 1, 0) / count(*)</p><p>= sum(action = &#39;confirmed&#39;) / count(*)</p><p>= count(if(action=&#39;confirmed&#39;,c.action,null) / count(c.action)</p><h3 id="count" tabindex="-1"><a class="header-anchor" href="#count"><span>COUNT()</span></a></h3><p>SQL <code>COUNT</code>函数是一个聚合函数，它返回符合条件行数。 可以使用<a href="http://www.yiibai.com/sql/sql-select.html" target="_blank" rel="noopener noreferrer">SELECT语句</a>中的<code>COUNT</code>函数来获取员工数量，每个部门的员工数量，指定工作岗位的员工数量等。</p><p>以下是SQL <code>COUNT</code>函数的语法：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">COUNT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[ALL | DISTINCT]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> expression);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>COUNT</code>函数的结果取决于传递给它的参数。</p><ul><li>默认情况下，<code>COUNT</code>函数使用<code>ALL</code>关键字，无论是否指定它。 <code>ALL</code>关键字表示考虑组中的所有项目，包括重复值。 例如，如果有一个数据集合<code>(1,2,3,3,4,4)</code>并应用<code>COUNT</code>函数，则结果为<code>6</code>。</li><li>如果明确指定<code>DISTINCT</code>关键字，则仅考虑唯一的非<code>NULL</code>值。 如果将<code>COUNT</code>函数应用于数据集<code>(1,2,3,3,4,4)</code>，则<code>COUNT</code>函数返回<code>4</code>。</li></ul><p>另一种形式的<code>COUNT</code>函数接受星号(<code>*</code>)作为参数如下：</p><p>COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">COUNT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(*)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>COUNT(*)</code>函数返回表中的行数，包括包含<code>NULL</code>值的行。</p><p>这里值得注意的是count的条件用法。举个例子count(age &gt; 20 or null)这个语句，里面or null必须加，否则就等价于count(*)了，要么就是写作sum(age &gt; 20)也可。</p><h3 id="group-concat" tabindex="-1"><a class="header-anchor" href="#group-concat"><span>GROUP_CONCAT()</span></a></h3><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">GROUP_CONCAT(</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    DISTINCT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> expression1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> expression2</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    SEPARATOR sep</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="json-arrayagg" tabindex="-1"><a class="header-anchor" href="#json-arrayagg"><span>JSON_ARRAYAGG()</span></a></h3><p>用于将分组中的数据以 JSON 格式返回。<strong><code>JSON_ARRAYAGG(column_name)</code></strong>：生成 JSON 数组。</p><h3 id="json-objectagg" tabindex="-1"><a class="header-anchor" href="#json-objectagg"><span>JSON_OBJECTAGG()</span></a></h3><p><strong><code>JSON_OBJECTAGG(key_column, value_column)</code></strong>：生成 JSON 对象。</p><h2 id="窗口函数" tabindex="-1"><a class="header-anchor" href="#窗口函数"><span>窗口函数</span></a></h2><p><a href="https://zhuanlan.zhihu.com/p/92654574" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/92654574</a></p><p><a href="https://zhuanlan.zhihu.com/p/120269203" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/120269203</a></p><p><a href="https://zhuanlan.zhihu.com/p/80051518" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/80051518</a></p><ul><li><p>序号函数：rank, dense_rank, <strong>row_number</strong></p></li><li><p>分布函数：percent_rank(), cume_dist(), <code>ntile()</code></p></li><li><p>前后函数：lag() / lead()</p></li><li><p>头尾函数：first_val() / last_val()</p></li><li><p>其他函数：nth_value() / 用途：将分区中的有序数据分为n个桶，记录桶号。</p></li></ul><p>窗口函数 (WINDOW function)，也叫OLAP函数（Online Anallytical Processing，联机分析处理)，可以对数据库数据进行实时分析处理。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">聚合函数/窗口函数</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> over</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    partition</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> by</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">用于分组的列名</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    order by</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">用于排序的列名</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">window_function (expression) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">OVER</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">   [ PARTITION BY part_list ]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">   [ ORDER BY order_list ]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">   [ { ROWS | RANGE } BETWEEN frame_start AND frame_end ]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> )</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>&lt;窗口函数&gt;的位置，可以放以下两种函数：</p><ol><li><p>专用窗口函数，包括后面要讲到的rank, dense_rank, row_number, lead, lag等专用窗口函数。</p></li><li><p>聚合函数，如 sum, avg, count, max, min 等</p></li></ol><p>因为窗口函数是对where或者group by子句处理后的结果进行操作，所以<strong>窗口函数原则上只能写在select子句中</strong>。</p><ul><li><strong>ROWS</strong> 选择前后几行，例如 <code>ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING</code> 表示往前 3 行到往后 3 行，一共 7 行数据（或小于 7 行，如果碰到了边界）</li><li><strong>RANGE</strong> 选择数据范围，例如 <code>RANGE BETWEEN 3 PRECEDING AND 3 FOLLOWING</code> 表示所有值在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>c</mi><mo>−</mo><mn>3</mn><mo separator="true">,</mo><mi>c</mi><mo>+</mo><mn>3</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[c-3,c+3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span> 这个范围内的行，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> 为当前行的值</li></ul><p><a href="https://blog.csdn.net/qq_42374697/article/details/115109386" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_42374697/article/details/115109386</a></p><hr><p>逻辑语义上说，一个窗口函数的计算“过程”如下：</p><ol><li>按窗口定义，将所有输入数据分区、再排序（如果需要的话）</li><li>对每一行数据，计算它的 Frame 范围</li><li>将 Frame 内的行集合输入窗口函数，计算结果填入当前行</li></ol><hr><ul><li><p>如果不指定 <code>ORDER BY</code>，则不对各分区做排序，通常用于那些顺序无关的窗口函数，例如 <code>SUM()</code></p></li><li><p>如果不指定 Frame 子句，则默认采用以下的 Frame 定义：</p></li><li><ul><li>若不指定 <code>ORDER BY</code>，默认使用分区内所有行 <code>RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</code></li><li>若指定了 <code>ORDER BY</code>，默认使用分区内第一行到当前值 <code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code></li></ul></li></ul><p>最后，窗口函数可以分为以下 3 类：</p><ul><li><strong>聚合（Aggregate）</strong>：<code>AVG()</code>, <code>COUNT()</code>, <code>MIN()</code>, <code>MAX()</code>, <code>SUM()</code>...</li><li><strong>取值（Value）</strong>：<code>FIRST_VALUE()</code>, <code>LAST_VALUE()</code>, <code>LEAD()</code>, <code>LAG()</code>...</li><li><strong>排序（Ranking）</strong>：<code>RANK()</code>, <code>DENSE_RANK()</code>, <code>ROW_NUMBER()</code>, <code>NTILE()</code>...</li></ul><p>受限于篇幅，本文不去探讨各个窗口函数的含义，有兴趣的读者可以参考<a href="https://link.zhihu.com/?target=https%3A//drill.apache.org/docs/sql-window-functions-introduction/%23types-of-window-functions" target="_blank" rel="noopener noreferrer">这篇文档</a>。</p><blockquote><p>注：Frame 定义并非所有窗口函数都适用，比如 <code>ROW_NUMBER()</code>、<code>RANK()</code>、<code>LEAD()</code> 等。这些函数总是应用于整个分区，而非当前 Frame。</p></blockquote><hr><p>功能：</p><ol><li><p>同时具有分组 partition by 和排序 order by 的功能</p></li><li><p>不减少原表的行数</p></li></ol><p>加distinct会显著提速</p><p>使用场景：</p><ol><li>业务需求“<strong>在每组内排名”</strong>，比如：</li></ol><blockquote><p>排名问题：每个部门按业绩来排名<br> topN问题：找出每个部门排名前N的员工进行奖励</p></blockquote><h3 id="前后类" tabindex="-1"><a class="header-anchor" href="#前后类"><span>前后类</span></a></h3><p>Lead向下（后)，Lag向上（前)</p><p><strong>Lag</strong> 和<strong>Lead</strong> 函数可以在一次查询中取出同一字段的<strong>前N行</strong> 的数据和<strong>后N行</strong> 的值。这种操作可以使用对相同表的表连接来实现，不过使用LAG和LEAD有更高的效率。</p><p><code>Lead(expression, offset, default) over(partition-clause order-by-clause)</code></p><p>参数说明：</p><ul><li>offset 偏移，表示查询其后第n条记录，如果不提供这个参数，就是默认为1；</li><li>default 默认值，如果没有找到。如果没有设置，且找不到，那么就返回Null；</li><li>query_partition_clause 分区语句，对结果集合分区的语句，是可选的，如果没有就是所有的一个分区；</li><li>order_by_clause 排序语句 必须需要 , 如果没有order by 子句，就不是“连续”的。</li></ul><p>语法：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[你要的操作]</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> OVER</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    PARTITION</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> BY</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">  &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">用于分组的列名</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">按序叠加的列名</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    ROWS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">RANGE</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">窗口滑动的数据范围</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>&lt;窗口滑动的数据范围&gt; 用来限定 [你要的操作] 所运用的数据的范围，有如下这些：</p><ul><li>当前 - current row</li><li>之前的 - preceding</li><li>之后的 - following</li><li>无界限 - unbounded</li><li>表示从前面的起点 - unbounded preceding</li><li>表示到后面的终点 - unbounded following</li></ul><p>举例：</p><ul><li>取当前行和前五行：ROWS between 5 preceding and current row --共6行</li><li>取当前行和后五行：ROWS between current row and 5 following --共6行</li><li>取前五行和后五行：ROWS between 5 preceding and 5 following --共11行</li><li>取当前行和前六行：ROWS 6 preceding（等价于between...and current row） --共7行</li><li>这一天和前面6天：RANGE between interval 6 day preceding and current row --共7天</li><li>这一天和前面6天：RANGE interval 6 day preceding（等价于between...and current row） --共7天</li><li>字段值落在当前值-100到+200的区间：RANGE between 100 preceding and 200 following --共301个数值</li></ul><p>题目分析：</p><p>本题中，要的是按日期的金额的累计， 窗口内的数据要取当前日期和前6天。<br> 但是即使前边的数据不够，窗口函数也会将范围内的数据框住并计算，因此需要最后手动地从第7天开始。</p><h2 id="处理函数" tabindex="-1"><a class="header-anchor" href="#处理函数"><span>处理函数</span></a></h2><p><code>FORMAT()</code></p><h3 id="字符串处理函数" tabindex="-1"><a class="header-anchor" href="#字符串处理函数"><span>字符串处理函数</span></a></h3><p><code>CHAR_LENGTH(str)</code>：字符串长度</p><p><code>SUBSTRING(column_name, start, length)</code>：从1开始数的，这将从列的值中提取一个子字符串，从指定的起始位置开始，直到指定的长度。不指定长度就到末尾。</p><p><code>UPPER(expression)</code>：这会将字符串表达式转换为大写。</p><p><code>LOWER(expression)</code>：这会将字符串表达式转换为小写。</p><p><code>CONCAT(string1, string2, ...)</code>：这会将两个或多个字符串连接成一个字符串。</p><p>核心思想是将名称列的第一个字符与其他字符分开，相应地更改它们的大小写，然后将它们连接在一起。</p><h3 id="数学函数" tabindex="-1"><a class="header-anchor" href="#数学函数"><span>数学函数</span></a></h3><p>abs、cos、floor、power 等</p><h3 id="浮点数处理函数" tabindex="-1"><a class="header-anchor" href="#浮点数处理函数"><span>浮点数处理函数</span></a></h3><p>MOD(100, 2)</p><p>可以使用 ROUND 函数来保留指定位数的小数。ROUND 函数的语法如下：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">ROUND</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">number</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, decimal_places)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中，number 是要进行舍入的数字，decimal_places 是要保留的小数位数。例如，要将一个数保留两位小数，可以使用以下 SQL 语句：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> ROUND</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">number</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中，number 是要进行舍入的数字，2 是要保留的小数位数。执行该 SQL 语句后，将返回一个保留两位小数的结果集。</p><p>需要注意的是，ROUND 函数会根据第二个参数进行四舍五入操作。如果要对小数进行截断操作，可以使用 TRUNCATE 函数。TRUNCATE 函数的语法如下：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">TRUNCATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">number</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, decimal_places)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中，number 是要进行截断的数字，decimal_places 是要保留的小数位数。例如，要将一个数截断到两位小数，可以使用以下 SQL 语句：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TRUNCATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">number</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>执行该 SQL 语句后，将返回一个截断到两位小数的结果集。</p><h3 id="日期处理函数" tabindex="-1"><a class="header-anchor" href="#日期处理函数"><span>日期处理函数</span></a></h3><h4 id="加减" tabindex="-1"><a class="header-anchor" href="#加减"><span>加减</span></a></h4><p><code>TIMESTAMPDIFF(unit, date1, date2)</code></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">ADDDATE: ADDDATE(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">date</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, INTERVAL </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> addunit) </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">#ADDDATE(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;yyyyMMdd&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,INTERVAL </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> day</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">DATEDIFF: </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">DATEDIFF</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(date1, date2) #date1-date2,结果是以日为单位</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">TIMESTAMPDIFF: TIMESTAMPDIFF(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DAY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;2023-01-01&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;2022-12-21&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">DATE_SUB: DATE_SUB(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;2023-12-29&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,INTERVAL </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> DAY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) #</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2023</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">12</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">27</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">DATE_ADD: DATE_ADD(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;2023-12-29&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,INTERVAL </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> DAY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) #</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2023</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">12</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">27</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ADDDATE(date, INTERVAL value addunit)</code></p><p>ADDDATE()函数用于将指定的时间间隔添加到日期值date是表示日期的值，它可以是 String、DATE（YEAR、MONTH 和 DAY)、DATETIME（HOURS、MINUTES 或 SECONDS)或 TIMESTAMP 类型。</p><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>date</td><td>必填。要修改的日期</td></tr><tr><td>days</td><td>必填。要添加到日期的天数</td></tr><tr><td>value</td><td>必填。要添加的时间/日期间隔的值。允许正值和负值</td></tr><tr><td>addunit</td><td>必填。要添加的间隔类型。可以是以下值之一：MICROSECON 、 DSECOND、MINUTE、HOUR、DAY、WEEK、MONTH、QUARTER、YEAR、 SECOND_MICROSECOND、YEAR_MONTH、MINUTE_MICROSECOND、MINUTE_SECOND 、HOUR_MICROSECOND、HOUR_SECOND 、HOUR_MINUTE、DAY_MICROSECOND、DAY_SECOND、DAY_MINUTE、DAY_HOUR</td></tr></tbody></table><h4 id="格式" tabindex="-1"><a class="header-anchor" href="#格式"><span>格式</span></a></h4><p><code>DATE_FORMAT(datem &#39;%Y-%m&#39;)</code></p><h3 id="空值处理函数" tabindex="-1"><a class="header-anchor" href="#空值处理函数"><span>空值处理函数</span></a></h3><p><code>COALESCE</code> 是 SQL 中的一个函数，用于返回参数列表中的第一个非空值。如果所有参数均为 NULL，则 <code>COALESCE</code> 返回 NULL。语法如下：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">COALESCE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(value1, value2, ..., valueN)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>它会按顺序检查每个参数，并返回第一个非空值。如果所有参数都是 NULL，则返回 NULL。</p><p>在上面的 SQL 查询中，<code>COALESCE(ms.num_of_reports, 0)</code> 和 <code>COALESCE(ms.avg_age, 0)</code> 的作用是如果 <code>ms.num_of_reports</code> 或 <code>ms.avg_age</code> 是 NULL，则将其替换为 0。</p>`,107)])])}const r=i(l,[["render",t]]),c=JSON.parse(`{"path":"/se/database/sql/basic/function.html","title":"函数","lang":"en-US","frontmatter":{"description":"函数 聚合函数 将一组数据通过运算返回这组数据的某种性质，如最大值，最小值。 没有元素的时候返回null 聚合函数类型 AVG() SUM() MAX() MIN() COUNT() VARIANCE() 和 STDDEV() GROUP_CONCAT() AVG() AVG(c.action = 'confirmed') = sum(if(c.act...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"函数\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-15T23:09:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"],["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/se/database/sql/basic/function.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"函数"}],["meta",{"property":"og:description","content":"函数 聚合函数 将一组数据通过运算返回这组数据的某种性质，如最大值，最小值。 没有元素的时候返回null 聚合函数类型 AVG() SUM() MAX() MIN() COUNT() VARIANCE() 和 STDDEV() GROUP_CONCAT() AVG() AVG(c.action = 'confirmed') = sum(if(c.act..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-12-15T23:09:49.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-15T23:09:49.000Z"}]]},"git":{"createdTime":1765840189000,"updatedTime":1765840189000,"contributors":[{"name":"David Liu","username":"","email":"davidliu02k@gmail.com","commits":1}]},"readingTime":{"minutes":8.23,"words":2470},"filePathRelative":"se/database/sql/basic/function.md","excerpt":"\\n<h2>聚合函数</h2>\\n<p>将一组数据通过运算返回这组数据的某种性质，如最大值，最小值。</p>\\n<p>没有元素的时候返回null</p>\\n<p><strong>聚合函数类型</strong></p>\\n<ul>\\n<li>AVG()</li>\\n<li>SUM()</li>\\n<li>MAX()</li>\\n<li>MIN()</li>\\n<li>COUNT()</li>\\n<li>VARIANCE() 和 STDDEV()</li>\\n<li>GROUP_CONCAT()</li>\\n</ul>\\n<h3>AVG()</h3>\\n<p>AVG(c.action = 'confirmed')</p>\\n<p>= sum(if(c.action = 'confirmed', 1, 0) / count(*)</p>","autoDesc":true}`);export{r as comp,c as data};
