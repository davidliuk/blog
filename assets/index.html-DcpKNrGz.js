import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as i}from"./app-BtADw1TI.js";const r={};function p(o,e){return i(),a("div",null,[...e[0]||(e[0]=[n('<h1 id="range" tabindex="-1"><a class="header-anchor" href="#range"><span>Range</span></a></h1><p>针对不同的题目，我们有不同的方案可以选择（假设我们有一个数组）：</p><ol><li>数组不变，求区间和：「前缀和」、「树状数组」、「线段树」</li><li>多次修改某个单点，求区间和：「树状数组」、「线段树」</li><li>多次修改某个区间，输出最终结果：「差分」</li><li>多次修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间范围大小）</li><li>多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间范围大小）</li></ol><p>「线段树」能解决的问题是最多的，那我们是不是无论什么情况都写「线段树」呢？</p><p>答案：并不是，而且恰好相反，只有在我们遇到第 4 类问题，不得不写「线段树」的时候，我们才考虑线段树。因为「线段树」代码很长，而且常数很大，实际表现不算很好。我们只有在不得不用的时候才考虑「线段树」。</p><p>总结一下，我们应该按这样的优先级进行考虑：</p><p>简单求区间和，用「前缀和」<br> 多次将某个区间变成同一个数，用「线段树」<br> 其他情况，用「树状数组」</p><p>时间复杂度：add 操作和 query 的复杂度都是 O(log⁡n)，因此构建数组的复杂度为 O(nlog⁡n)。整体复杂度为 O(nlog⁡n)<br> 空间复杂度：O(n)</p><p>逆序数是一个数列中在它前面有比它大的个数。如 4312 的逆序数是 0+1+2+2=5。<br> 从最后一个数开始遍历，每次在树状数组中查询有多少个数小于当前的数并加入计数器，之后把当前元素加入树状数组。</p><h2 id="树状数组" tabindex="-1"><a class="header-anchor" href="#树状数组"><span>树状数组</span></a></h2><p>正如所有的整数都可以表示成 2 的幂和，我们也可以把一串序列表示成一系列子序列的和。采用这个想法，我们可将一个前缀和划分成多个子序列的和，而划分的方法与数的 2 的幂和具有极其相似的方式。</p><p>更新</p><p>但是，如果还可以修改数组中的元素呢？<br> 比如我把下标为 1 的元素修改了，由于所有前缀都包含下标 1，那么就需要更新所有前缀的元素和，更新操作就需要 O(n)的时间，这太慢了。<br> 能不能把前缀[1,i]拆分成若干段连续子数组呢？<br> 如果拆分得太细，比如拆分成[1,1]，[2,2]，[3,3]，虽然更新是 O(1)的，但计算子数组元素和还是得遍历累加，时间复杂度是 O(n),太慢了。</p><p>平衡</p><p>上面的做法，要么询问是 O(1)更新是 O()，要么询问是 O(n)更新是 O(1),时间差距悬殊。<br> 如何「平衡」询问和更新的时间复杂度？<br> 关键在于如何拆分子数组（区间）。<br> 能否把任意前缀拆分成若干个关键区间，使得更新操作也只会更新若干个关键区间？<br> 这样回答询问时，只需要遍历并累加若干个关键区间的元素和。更新元素时，也只需要遍历并更新若干个关键区间的元素和。</p><p>如何拆分？</p><p>启示：如果把一个正整数 i 拆分成若干个不同的 2 的幂（从大到小），那么只会拆分出 O(logi)个数。前缀能否也这样拆分呢？<br> 举个例子，13=8+4+1，那么前缀[1,13]可以拆分成三个长度分别为 8,4,1 的关键区间：<br> [1,8], [9,12], [13,13]。<br> 按照这个规则，来看看从[1,1]到[1,8]是如何拆分的：</p><p>树状数组总是结合离散化</p><ul><li>逆序对</li><li>区间和的个数</li></ul><h2 id="线段树" tabindex="-1"><a class="header-anchor" href="#线段树"><span>线段树</span></a></h2>',20)])])}const d=t(r,[["render",p]]),s=JSON.parse(`{"path":"/algo/faq/range/","title":"Range","lang":"en-US","frontmatter":{"description":"Range 针对不同的题目，我们有不同的方案可以选择（假设我们有一个数组）： 数组不变，求区间和：「前缀和」、「树状数组」、「线段树」 多次修改某个单点，求区间和：「树状数组」、「线段树」 多次修改某个区间，输出最终结果：「差分」 多次修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间范围大小） 多次将某个区间变成同一个数，求区间和：「线段树...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Range\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-15T23:09:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"],["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/faq/range/"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"Range"}],["meta",{"property":"og:description","content":"Range 针对不同的题目，我们有不同的方案可以选择（假设我们有一个数组）： 数组不变，求区间和：「前缀和」、「树状数组」、「线段树」 多次修改某个单点，求区间和：「树状数组」、「线段树」 多次修改某个区间，输出最终结果：「差分」 多次修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间范围大小） 多次将某个区间变成同一个数，求区间和：「线段树..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-12-15T23:09:49.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-15T23:09:49.000Z"}]]},"git":{"createdTime":1765840189000,"updatedTime":1765840189000,"contributors":[{"name":"David Liu","username":"","email":"davidliu02k@gmail.com","commits":1}]},"readingTime":{"minutes":3.23,"words":970},"filePathRelative":"algo/faq/range/README.md","excerpt":"\\n<p>针对不同的题目，我们有不同的方案可以选择（假设我们有一个数组）：</p>\\n<ol>\\n<li>数组不变，求区间和：「前缀和」、「树状数组」、「线段树」</li>\\n<li>多次修改某个单点，求区间和：「树状数组」、「线段树」</li>\\n<li>多次修改某个区间，输出最终结果：「差分」</li>\\n<li>多次修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间范围大小）</li>\\n<li>多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间范围大小）</li>\\n</ol>\\n<p>「线段树」能解决的问题是最多的，那我们是不是无论什么情况都写「线段树」呢？</p>\\n","autoDesc":true}`);export{d as comp,s as data};
