import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,b as p,o as a}from"./app-B3ooTv29.js";const o={};function l(n,e){return a(),i("div",null,e[0]||(e[0]=[p('<h1 id="图论" tabindex="-1"><a class="header-anchor" href="#图论"><span>图论</span></a></h1><p>图可以先生成好再遍历，也可以边遍历边生成（推荐变遍历边生成）</p><p>dfs时有的时候需要记录parent/from防止出现平凡环/走回头路</p><p><strong>编号</strong>：图是一个抽象的结构，一定要为图中每一个节点赋值一个唯一的编号。</p><ul><li>一般来说，题目上给的节点是按照数组给的有一个默认编号 0到n-1或 1 到 n</li><li>没有的情况下，需要用哈希表来记录元素到编号，如合并账户这一题</li></ul><p>在我们开始实际执行深度优先搜索之前，让我们快速地向自己确保，邻接表 是这个问题的最佳图形表示。另外两个选项是 邻接矩阵 或 链表表示。</p><p>对于这个问题，一个 邻接矩阵 将是一个可以接受的表示，尽管不是很理想。通常，只有当我们知道边数大大高于节点数时，我们才会使用邻接矩阵。我们没有理由相信情况就是这样。方法 2 也将对此提供一些有用的见解。<br> 将实际节点作为对象的 链表表示法 是一种过于复杂的表示法，可能会向面试官暗示您对邻接列表和邻接矩阵的了解有限。它们在面试问题中并不常用。</p><h2 id="图的存储-表示" tabindex="-1"><a class="header-anchor" href="#图的存储-表示"><span>图的存储/表示</span></a></h2><ul><li><p>邻接矩阵</p><p>二维数组<code>graph[i][j]</code>，表示i, j之间的距离</p></li><li><p>邻接表 adjacencyList</p><p>有一个有 <code>n</code> 个节点的有向图，节点按 <code>0</code> 到 <code>n - 1</code> 编号。</p><p>图由一个 <strong>索引从 0 开始</strong> 的 2D 整数数组 <code>graph</code>表示， <code>graph[i]</code>是与节点 <code>i</code> 相邻的节点的整数数组，这意味着从节点 <code>i</code> 到 <code>graph[i]</code>中的每个节点都有一条边。</p><p><code>List&lt;Integer&gt;[] next = new List[n]</code></p><p><code>List&lt;Integer&gt;[] adjacencyList = new List[n]</code></p><p><code>List&lt;List&lt;Integer&gt;&gt; adjacencyList = new ArrayList&lt;&gt;()</code></p><p>好处：节省空间，便于遍历</p><p>List&lt;int[]&gt;[] e = new List[n];</p></li><li><p>边存储</p><p>一个边的数组，每个元素都是起点、终点的二元组</p><p>给你一个 <strong>有向无环图</strong> ， <code>n</code> 个节点编号为 <code>0</code> 到 <code>n-1</code> ，以及一个边数组 <code>edges</code> ，其中 <code>edges[i] = [fromi, toi]</code> 表示一条从点 <code>fromi</code> 到点 <code>toi</code> 的有向边。</p><p>eg. [[0, 1], [0, 2], [1, 2]]</p><p>有 <code>n</code> 个城市通过一些航班连接。给你一个数组 <code>flights</code> ，其中 <code>flights[i] = [fromi, toi, pricei]</code> ，表示该航班都从城市 <code>fromi</code> 开始，以价格 <code>pricei</code> 抵达 <code>toi</code>。</p><p>好处：适合用并查集，题目一般是给一组边，然后用户根据题意选择合适的方式建图</p></li></ul><p>特殊图</p><ul><li>矩阵图（比如一个二维棋盘）</li><li>有向无环图 DAG, 无需visited数组，因为不会走回头路 <ul><li>树</li></ul></li></ul><h3 id="树" tabindex="-1"><a class="header-anchor" href="#树"><span>树</span></a></h3><p>图 G 是树当且仅当满足以下两个条件：</p><ol><li>G 完全连通。换句话说，对于 G 中的每一对点，都有一条路径连接彼此。</li><li>G 不包含环。换句话说，对于 G 中的每一对点只有一条路径连接彼此。</li></ol><p>或者当且仅当</p><ol><li>检查是否是 <code>n-1</code> 条边。如果没有，则返回 <code>false</code>。</li><li>完全连通：检查该图是否完全连通。如果是，则返回 <code>true</code>，否则返回 <code>false</code>。</li></ol><h2 id="图的遍历" tabindex="-1"><a class="header-anchor" href="#图的遍历"><span>图的遍历</span></a></h2><p>遍历过程中要有一个visited数组或表防止一个点重复遍历</p><ul><li><p>深度优先搜索</p><p>好处：代码简短多种类型的状态好存，有先序后序</p></li><li><p>广度优先搜索</p><p>好处：可用于无权图的最短路径问题</p></li></ul><p>染色法/三色标记法，判断二分图和环的图</p><p>根据题意，若起始节点位于一个环内，或者能到达一个环，则该节点不是安全的。否则，该节点是安全的。</p><p>我们可以使用深度优先搜索来找环，并在深度优先搜索时，用三种颜色对节点进行标记，标记的规则如下：</p><p>白色（用 000 表示）：该节点尚未被访问；<br> 灰色（用 111 表示）：该节点位于递归栈中，或者在某个环上；<br> 黑色（用 222 表示）：该节点搜索完毕，是一个安全节点。</p><h3 id="tarjan-算法" tabindex="-1"><a class="header-anchor" href="#tarjan-算法"><span>Tarjan 算法</span></a></h3><p>Tarjan 是著名计算机科学家。Tarjan 算法基于 dfs，可以玩出很多花样，比如求无向图的割点、无向图的桥边（割边）、无向图的双连通分量、有向图的强连通分量。用于不同问题时，写法略有区别。</p><p>Tarjan 算法的关键点有二：</p><p>在 dfs 的过程中，记录每个节点初次被访问的时间戳<br> 计算每个节点能访问到的节点的最小时间戳。</p><p>这个算法理解起来略微痛苦，需要结合代码仔细体会其细节。</p><h2 id="环" tabindex="-1"><a class="header-anchor" href="#环"><span>环</span></a></h2><p>平凡环：无向图里面A-&gt;B, B-&gt;A构成一个平凡环</p><p>自环：一个节点有一条指向自己的边</p><p>三色标记法</p><p>拓扑排序</p><p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong></p><h2 id="连通分量" tabindex="-1"><a class="header-anchor" href="#连通分量"><span>连通分量</span></a></h2><p>我们可以将每一个变量看作图中的一个节点，把相等的关系 == 看作是连接两个节点的边，那么由于表示相等关系的等式方程具有传递性，即如果 a<mark>b 和 b</mark>c 成立，则 a==c 也成立。也就是说，所有相等的变量属于同一个连通分量。因此，我们可以使用并查集来维护这种连通分量的关系。</p><h2 id="最短路" tabindex="-1"><a class="header-anchor" href="#最短路"><span>最短路</span></a></h2><h3 id="dijkstra" tabindex="-1"><a class="header-anchor" href="#dijkstra"><span>Dijkstra</span></a></h3><p>在研究这种方法之前，快速了解一下 Dijkstra 算法。</p><p>Dijkstra 算法是一个非常著名的图算法，用于找到给定加权图（图的边表示节点之间的距离）中从任何起始节点到任何目标节点的最短路径。</p><p>该算法包括以下步骤：</p><ol><li><p>为每个节点分配一个临时距离值：对于我们的起始节点，将其设置为零，对于所有其他节点，将其设置为无穷大。</p></li><li><p>将起始节点设置为当前节点。标记它为已访问。</p></li><li><p>对于当前节点，考虑其所有相邻节点并计算它们的临时距离。将新计算的临时距离与当前分配的值进行比较，并将较小的值分配给所有相邻节点。例如，如果当前节点 A 的距离标记为 6，并且与相邻节点B相连的边长为 2，则到B(通过A)的距离将为 6 + 2 = 8。如果 B 之前标记的距离大于 8，则将其更改为 8。否则，保留当前值。</p></li><li><p>当我们完成考虑当前节点的所有相邻节点时，将当前节点标记为已访问。已访问的节点将不再被检查。</p></li><li><p>如果目标节点已标记为已访问，或者所有剩余节点中最小的临时距离为无穷大(表示无法到达目标节点)，则停止。算法已完成。</p></li><li><p>否则，选择标记为未访问的节点中具有最小临时距离的节点，并将其设置为新的当前节点，然后返回到步骤 3。</p></li></ol><p>可以通过两个简单的示例来了解该算法的工作原理。首先，考虑下面的节点集。</p>',43)]))}const c=t(o,[["render",l],["__file","图论.html.vue"]]),s=JSON.parse(`{"path":"/cs/algo/faq/%E5%9B%BE%E8%AE%BA.html","title":"图论","lang":"en-US","frontmatter":{"description":"图论 图可以先生成好再遍历，也可以边遍历边生成（推荐变遍历边生成） dfs时有的时候需要记录parent/from防止出现平凡环/走回头路 编号：图是一个抽象的结构，一定要为图中每一个节点赋值一个唯一的编号。 一般来说，题目上给的节点是按照数组给的有一个默认编号 0到n-1或 1 到 n 没有的情况下，需要用哈希表来记录元素到编号，如合并账户这一题 在...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/cs/algo/faq/%E5%9B%BE%E8%AE%BA.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"图论"}],["meta",{"property":"og:description","content":"图论 图可以先生成好再遍历，也可以边遍历边生成（推荐变遍历边生成） dfs时有的时候需要记录parent/from防止出现平凡环/走回头路 编号：图是一个抽象的结构，一定要为图中每一个节点赋值一个唯一的编号。 一般来说，题目上给的节点是按照数组给的有一个默认编号 0到n-1或 1 到 n 没有的情况下，需要用哈希表来记录元素到编号，如合并账户这一题 在..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-12-27T14:41:52.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-27T14:41:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"图论\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-12-27T14:41:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"图的存储/表示","slug":"图的存储-表示","link":"#图的存储-表示","children":[{"level":3,"title":"树","slug":"树","link":"#树","children":[]}]},{"level":2,"title":"图的遍历","slug":"图的遍历","link":"#图的遍历","children":[{"level":3,"title":"Tarjan 算法","slug":"tarjan-算法","link":"#tarjan-算法","children":[]}]},{"level":2,"title":"环","slug":"环","link":"#环","children":[]},{"level":2,"title":"连通分量","slug":"连通分量","link":"#连通分量","children":[]},{"level":2,"title":"最短路","slug":"最短路","link":"#最短路","children":[{"level":3,"title":"Dijkstra","slug":"dijkstra","link":"#dijkstra","children":[]}]}],"git":{"createdTime":1703688112000,"updatedTime":1703688112000,"contributors":[{"name":"davidliu","email":"liudawei47@jd.com","commits":1}]},"readingTime":{"minutes":6.29,"words":1887},"filePathRelative":"cs/algo/faq/图论.md","localizedDate":"December 27, 2023","excerpt":"\\n<p>图可以先生成好再遍历，也可以边遍历边生成（推荐变遍历边生成）</p>\\n<p>dfs时有的时候需要记录parent/from防止出现平凡环/走回头路</p>\\n<p><strong>编号</strong>：图是一个抽象的结构，一定要为图中每一个节点赋值一个唯一的编号。</p>\\n<ul>\\n<li>一般来说，题目上给的节点是按照数组给的有一个默认编号 0到n-1或 1 到 n</li>\\n<li>没有的情况下，需要用哈希表来记录元素到编号，如合并账户这一题</li>\\n</ul>\\n<p>在我们开始实际执行深度优先搜索之前，让我们快速地向自己确保，邻接表 是这个问题的最佳图形表示。另外两个选项是 邻接矩阵 或 链表表示。</p>","autoDesc":true}`);export{c as comp,s as data};
