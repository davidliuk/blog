import{_ as e,V as a,W as i,Z as t}from"./framework-e5d7a6b2.js";const l={},r=t('<h1 id="sleep-vs-wait" tabindex="-1"><a class="header-anchor" href="#sleep-vs-wait" aria-hidden="true">#</a> sleep vs wait</h1><h2 id="共同点" tabindex="-1"><a class="header-anchor" href="#共同点" aria-hidden="true">#</a> 共同点</h2><p>效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</p><h2 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h2><h3 id="方法归属不同" tabindex="-1"><a class="header-anchor" href="#方法归属不同" aria-hidden="true">#</a> 方法归属不同</h3><ul><li>sleep(long)上 Thread 的静态方法</li><li>wait(), wait(long)都是 Object 的成员方法，每个对象都有（即任意对象都可以有锁）</li></ul><h3 id="醒来时机不同" tabindex="-1"><a class="header-anchor" href="#醒来时机不同" aria-hidden="true">#</a> 醒来时机不同</h3><ul><li>执行 sleep(long), wait(long)的线程都会在等待相应毫秒后醒来</li><li>wait(), wait(long)还可以蓓 notify 唤醒，wait()如果不唤醒就一直等下去</li><li>他们都可以被 interrupt 直接唤醒（抛出 InterruptException）</li></ul><h3 id="锁的特性不同" tabindex="-1"><a class="header-anchor" href="#锁的特性不同" aria-hidden="true">#</a> 锁的特性不同</h3><ul><li>wait 方法的调用，必须先获取 wait 对象的锁，而 sleep 则无此限制</li><li>wait 方法执行后会释放对象锁，允许其他线程获取该对象锁（我放弃，但你们还可以用）</li><li>sleep 如果在 synchronize 代码块中执行，并不会释放对象锁（我放弃，你们也用不了）</li></ul>',10),h=[r];function n(s,d){return a(),i("div",null,h)}const o=e(l,[["render",n],["__file","sleep vs wait.html.vue"]]);export{o as default};
