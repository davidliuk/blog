import{_ as t,V as o,W as n,X as i,Y as l,$ as a,Z as e,E as r}from"./framework-e5d7a6b2.js";const s={},d=e('<h1 id="项目亮点总结" tabindex="-1"><a class="header-anchor" href="#项目亮点总结" aria-hidden="true">#</a> 项目亮点总结</h1><h3 id="用户中心项目" tabindex="-1"><a class="header-anchor" href="#用户中心项目" aria-hidden="true">#</a> 用户中心项目</h3><ol><li><p>为了提高开发效率，选用 Ant Design Pro 脚手架快速搭建基础页面，并对原始模板进行瘦身、抽象为可复用的公共模板，便于后续同类项目的快速研发。</p></li><li><p>在脚手架自带的 umi-request 请求库基础上进行改造和封装，添加全局请求拦截和全局异常处理逻辑、自动根据项目启动命令来区分环境，减少重复代码、提升项目可维护性。</p></li><li><p>选用 MyBatis + MyBatis-Plus 进行数据访问层开发，复用大多数通用方法，并且通过继承定制了自己的 通用操作模板 ，大幅提升了项目开发效率。</p></li><li><p>为了明确接口的返回，自定义统一的错误码，并封装了 全局异常处理器 ，从而规范了异常返回、屏蔽了项目冗余的报错细节。</p></li><li><p>对于项目中的 JSON 格式化处理对象，采用 双检锁单例模式 进行管理，从而复用对象，避免了重复创建对象的开销，便于集中维护管理。</p></li><li><p>采用 Nginx 完成前端项目部署、采用 Docker 容器完成后端项目部署，并且使用宝塔面板对项目进行运维监控。</p></li></ol><h3 id="伙伴匹配系统" tabindex="-1"><a class="header-anchor" href="#伙伴匹配系统" aria-hidden="true">#</a> 伙伴匹配系统</h3><p>项目介绍：</p><p>基于 Vue 3 + Spring Boot 2 的移动端网站，实现了用户管理、按标签检索用户、推荐相似用户、组队等功能。</p><p>主要工作：</p><ol><li><p>用户登录：使用 Redis 实现分布式 Session，解决集群间登录态同步问题；并使用 Hash 代替 String 来存储用户信息，节约了 xx% 的内存并便于单字段的修改。（需要自己实际测试对比数据，节省内存的原因是不用保存序列化对象信息或者 JSON 的一些额外字符串）</p></li><li><p>对于项目中复杂的集合处理（比如为队伍列表关联已加入队伍的用户），使用 Java 8 Stream API 和 Lambda 表达式来简化编码。</p></li><li><p>使用 Easy Excel 读取收集来的基础用户信息，并通过自定义线程池 + CompletableFuture 并发编程提高批量导入数据库的性能。实测导入 100 万行的时间从 xx 秒缩短至 xx 秒。（需要自己实际测试对比数据）</p></li><li><p>使用 Redis 缓存首页高频访问的用户信息列表，将接口响应时长从 xx 秒缩短至 xx 秒。且通过自定义 Redis 序列化器来解决数据乱码、空间浪费的问题。</p></li><li><p>为解决首次访问系统的用户主页加载过慢的问题，使用 Spring Scheduler 定时任务来实现缓存预热，并通过分布式锁保证多机部署时定时任务不会重复执行。</p></li><li><p>为解决同一用户重复加入队伍、入队人数超限的问题，使用 Redisson 分布式锁来实现操作互斥，保证了接口幂等性。</p></li><li><p>使用编辑距离算法实现了根据标签匹配最相似用户的功能，并通过优先队列来减少 TOP N 运算过程中的内存占用。</p></li><li><p>自主编写 Dockerfile，并通过第三方容器托管平台实现自动化镜像构建及容器部署，提高部署上线效率。</p></li><li><p>使用 Knife4j + Swagger 自动生成后端接口文档，并通过编写 ApiOperation 等注解补充接口注释，避免了人工编写维护文档的麻烦。</p></li><li><p>0前端使用 Vant UI 组件库，并封装了全局通用的 Layout 组件，使主页、搜索页、组队页布局一致、并减少重复代码。</p></li><li><p>基于 Vue Router 全局路由守卫实现了根据不同页面来动态切换导航栏标题， 并通过在全局路由配置文件扩展 title 字段来减少无意义的 if else 代码。</p></li></ol><h3 id="api-开放平台" tabindex="-1"><a class="header-anchor" href="#api-开放平台" aria-hidden="true">#</a> API 开放平台</h3><p>项目名称：XX API 开放平台（或者 XX 接口平台、XX 免费接口平台、XX API 等）</p><p>在线访问：xxx（建议提供可访问的、简短的线上地址）</p><p>项目介绍：</p><p>基于 React + Spring Boot + Dubbo + Gateway 的 API 接口开放调用平台。管理员可以接入并发布接口，可视化各接口调用情况；用户可以开通接口调用权限、浏览接口及在线调试，并通过客户端 SDK 轻松调用接口。</p><p>主要工作（根据自己的方向选 6 个左右去写并适当调整文案，如果自己没有实现或不理解，就先不要写，灵活一点）：</p>',14),c=e("<li><p>根据业务流程，将整个项目后端划分为 web 系统、模拟接口、公共模块、客户端 SDK、API 网关这 5 个子项目，并使用 Maven 进行多模块依赖管理和打包。</p></li><li><p>使用 Ant Design Pro 脚手架 + 自建 Spring Boot 项目模板快速构建初始 web 项目，并实现了前后端统一权限管理、多环境切换等基础能力。</p></li><li><p>基于 MyBatis Plus 框架的 QueryWrapper 实现对 MySQL 数据库的灵活查询，并配合 MyBatis X 插件自动生成后端 CRUD 基础代码，减少重复工作。</p></li><li><p>前端：后端使用 Swagger + Knife4j 自动生成 OpenAPI 规范的接口文档，前端在此基础上使用插件自动生成接口请求代码，降低前后端协作成本。</p></li><li><p>为防止接口被恶意调用，设计 API 签名认证算法，为用户分配唯一 ak / sk 以鉴权，保障调用的安全性、可溯源性（指便于统计接口调用次数）。</p></li><li><p>为解决开发者调用成本过高的问题（须自己使用 HTTP + 封装签名去调用接口，平均 20 行左右代码），基于 Spring Boot Starter 开发了客户端 SDK，一行代码 即可调用接口，提高开发体验。</p></li><li><p>前端：使用 ECharts（或 AntV）可视化库实现了接口调用的分析图表（如饼图），并通过 loading 配置提高加载体验。</p></li>",7),h={href:"https://blog.csdn.net/guorui_java/article/details/124112897%EF%BC%89",target:"_blank",rel:"noopener noreferrer"},u=i("li",null,[i("p",null,"为解决多个子系统内代码大量重复的问题，抽象模型层和业务层代码为公共模块，并使用 Dubbo RPC 框架实现子系统间的高性能接口调用（实测单机 qps 达 xx），大幅减少重复代码。")],-1),x=e('<p>扩展思路：</p><ol><li><p>前端：参考 Swagger（或 Postman）等 API 管理产品实现了 API 文档浏览及在线调用功能，并提供多级联动表单来提升用户输入请求参数 json 的体验。</p></li><li><p>前端可以阅读 Ant Design Pro 的文档，从框架的特性出发、结合自己做的功能去写一些亮点。</p></li><li><p>如果项目已上线且提供了一些 API 接口，可以说：自主开发了 XX、XX 等 API 接口并接入系统，累积调用次数达 xx 次，且接口调用可用性达 99.999%（4 - 5 个 9 都可以）</p></li><li><p>客户端 SDK 尽量使用最少的依赖，可以补充提一些 SDK 设计的亮点，比如：基于 Spring Boot Starter，自主设计客户端 SDK，并遵循 xx、xx、xx 等规范，保证了 SDK 的精简、避免依赖冲突。</p></li><li><p>使用 Docker 或 Docker Compose 来部署项目，可以写：自主编写 Dockerfile，并通过第三方容器托管平台实现自动化镜像构建及容器部署，提高部署上线效率。</p></li><li><p>思考如何保证接口调用的性能、稳定性和可用性（比如在网关增加限流 / 降级保护）？</p></li><li><p>思考如何提高开发者接入平台的效率、安全性等，真正地让平台成为开放平台。</p></li><li><p>可以考虑在微服务网关前搭建 Nginx 网关，通过负载均衡实现更大的并发。</p></li><li><p>在数据量大的情况下，使用 Spring Scheduler 定时任务离线计算结果集来替代实时查询，提高了后端统计分析的性能，单次查询响应时长从 xx 降低至 xx。</p></li></ol><p>如果简历内容过少，可以补充【个人介绍】或【自我评价】板块，提到：有较强的文档阅读能力，曾自主阅读 Spring Cloud Gateway、Dubbo（Ant Design Pro）等官方文档并能够运用到项目中。</p><h3 id="瑞吉外卖" tabindex="-1"><a class="header-anchor" href="#瑞吉外卖" aria-hidden="true">#</a> 瑞吉外卖</h3>',4),S=e("<li><p>为集中处理系统异常，自定义统一的错误码，并封装了 全局异常处理器 ，屏蔽了项目冗余的报错细节、便于接口调用方理解和统一处理。</p></li><li><p>基于静态 ThreadLocal 封装了线程隔离的全局上下文对象，便于在请求内部存取用户信息，减少用户远程查询次数。</p></li><li><p>为兼容请求参数 date 类型的序列化，自定义 Jackson 对象映射器处理日期；并扩展 SpringMVC 的消息转换器，实现自动序列化。</p></li><li><p>自定义 MyBatis Plus 的 MetaObjectHandler，配合全局上下文实现写数据前的创建时间、用户 id 字段的自动填充。</p></li><li><p>遵循 Restful 设计规范编写接口，降低前后端接口沟通和理解成本。</p></li><li><p>为解决原生 Jdk 序列化器导致的缓存 key 值乱码问题，自定义 RedisTemplate Bean 的 Redis Key 序列化器为 StringRedisSerializer。</p></li><li><p>使用 Knife4j + Swagger 自动生成后端接口文档，并通过编写 ApiOperation 等注解补充接口注释，避免了人工编写维护文档的麻烦。</p></li><li><p>为省去重复编写用户校验的麻烦，基于 WebFilter 实现全局登录校验；并通过 AntPathMatcher 来匹配动态请求路径，实现灵活的可选鉴权。</p></li>",8),_={href:"https://bcdh.yuque.com/Transactional",target:"_blank",rel:"noopener noreferrer"},g=i("li",null,[i("p",null,"为提高 XX 信息页加载速度，基于 Spring Cache 注解 + Redis 实现对 XX 信息的自动缓存，大幅降低数据库压力的同时将接口响应耗时由 0.8s 减少至 50ms（数值自己再测一下）")],-1),R=i("li",null,[i("p",null,"为降低开发成本，使用 MyBatis Plus 框架自动生成业务的增删改查重复代码，并使用 LambdaQueryWrapper 实现更灵活地自定义查询。")],-1),A=i("li",null,[i("p",null,"为降低用户注册成本、保证用户真实性，二次封装 XX 云 SDK 接入短信服务，并通过 Redis 来集中缓存验证码，防止单手机号的重复发送。")],-1),b=i("li",null,[i("p",null,"为提高数据库整体读写性能，配置 MySQL 主从同步，并使用 sharding-jdbc 实现业务无侵入的读写分离。")],-1),D=i("li",null,[i("p",null,"封装全局 Axios 请求实例，添加全局请求拦截和全局异常响应处理器，减少重复的状态码判断、提升项目可维护性。")],-1),P=e('<h3 id="尚医通微服务项目" tabindex="-1"><a class="header-anchor" href="#尚医通微服务项目" aria-hidden="true">#</a> 尚医通微服务项目</h3><ol><li><p>基于 Spring Cloud + Nacos 实现项目的微服务化，划分项目为公共、用户、订单等服务，提高项目的可扩展性和容错性。</p></li><li><p>使用 Spring Data 注解实现自动 Redis 缓存，并通过自定义 Redis Key Generator 来根据类和方法自动生成 key，降低开发成本、避免 key 冲突。</p></li><li><p>使用 Spring Cloud Gateway 实现微服务请求转发，并在网关层全局解决跨域、用户鉴权、黑白名单、内网服务保护等问题，降低开发成本、提高安全性。</p></li><li><p>提供 Restful API 供外部系统接入并上报数据，并通过 API 签名认证保障了接口的安全性。</p></li><li><p>使用 JWT 实现单点登录，并支持手机验证码、OAuth2 微信扫码登录，提高用户真实性和登录安全性</p></li><li><p>对接微信支付 API 实现预约付款，并通过全局唯一 id 以及支付 / 退款记录表的设计保证了支付操作的幂等性</p></li><li><p>使用 MongoDB 代替 MySQL 存储读多写少的半结构化数据（如医院信息），实测查询性能提高 xx%。（自己用 JMeter 测试一下）</p></li><li><p>基于 Docker 快速搭建项目依赖服务（如 RabbitMQ），并通过 Docker log 命令查看日志，降低本地开发运维成本。</p></li><li><p>为应对流量高峰，使用 RabbitMQ 将下单减库存等耗时操作异步化，提升下单接口单机 QPS（xx 至 xx）</p></li><li><p>使用 Spring Scheduler 实现定时预约提醒功能，并使用 RabbitMQ 实现定时服务和通知服务的解耦，提高服务可维护性。</p></li><li><p>使用 Nuxt 框架实现服务端渲染，提高网页首屏加载速度（xx 秒至 xx 秒）。</p></li></ol><h3 id="黑马点评" tabindex="-1"><a class="header-anchor" href="#黑马点评" aria-hidden="true">#</a> 黑马点评</h3><p>项目介绍：</p><p>基于 Spring Boot + Redis 的店铺点评 APP，实现了找店铺 =&gt; 写点评 =&gt; 看热评 =&gt; 点赞关注 =&gt; 关注 Feed 流的完整业务流程。</p><p>主要工作：</p><ol><li><p>短信登录：使用 Redis 实现分布式 Session，解决集群间登录态同步问题；使用 Hash 代替 String 来存储用户信息，节约了 xx% 的内存并便于单字段的修改。（需要自己实际测试对比数据，节省内存的原因是不用保存序列化对象信息或者 JSON 的一些额外字符串）</p></li><li><p>店铺查询：使用 Redis 对高频访问店铺进行缓存，降低 DB 压力同时提升 90% 的数据查询性能。</p></li><li><p>为方便其他业务后续使用缓存，使用泛型 + 函数式编程实现了通用缓存访问静态方法，并解决了缓存雪崩、缓存穿透等问题。</p></li><li><p>使用常量类全局管理 Redis Key 前缀、TTL 等，保证了键空间的业务隔离，减少冲突。</p></li><li><p>使用 Redis 的 Geo + Hash 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及按距离排序。</p></li><li><p>使用 Redis List 数据结构存储用户点赞信息，并基于 ZSet 实现 TopN 点赞排行，实测相对于 DB 查询性能提升 xx%。（需要自己实际测试对比数据）</p></li><li><p>使用 Redis Set 数据结构实现用户关注、共同关注功能（交集），实测相对于 DB 查询性能提升 xx%。（需要自己实际测试对比数据）</p></li><li><p>使用 Redis BitMap 实现用户连续签到统计功能，相对于传统关系库存储，节约 xx% 的内存并提升 xx% 的查询性能。（需要自己实际测试对比数据）</p></li><li><p>在系统用户量不大的前提下，基于推模式实现关注 Feed 流，保证了新点评消息的及时可达，并减少用户访问的等待时间。</p></li><li><p>优惠券秒杀：使用 Redis + Lua 脚本实现库存预检，并通过 Stream 队列实现订单的异步创建，解决了超卖问题、实现一人一单。实现相比传统数据库，秒杀性能提高了 xx%。（需要自己实际测试对比数据）</p></li></ol><p>再列举一些该项目可以扩展的点，有能力的同学可以自己尝试实现（注意，没有自己实现过千万别写到简历上！！！做没做过一问便知）：</p><ol><li><p>使用 Redis + Token 机制实现单点登录（补充到上述第 1 点中）</p></li><li><p>对 Redis 的所有 key 设置 N + n 的过期时间，从而合理使用内存并防止缓存雪崩；针对热点店铺缓存，使用逻辑过期（或自动续期）机制解决缓存击穿问题，防止数据库宕机。</p></li><li><p>使用 Redis 的 Geo + Hash 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及按距离排序，实测相对于传统 DB 查询 + 业务层计算的方式，性能提升 xx%。</p></li><li><p>使用 Redis Set 数据结构实现用户关注、共同关注功能（交集），实测相对于 DB 查询性能提升 xx%，并使用 Redis AOF + 业务层日志防止关注数据丢失。（理解 AOF 和 RDB 持久化机制后再写这点）</p></li><li><p>基于 Spring Scheduler 实现对热点数据的定期检测和缓存预加载，提升用户的访问体验，并通过 Redisson 分布式锁保证集群中同一时刻的定时任务只执行一次。</p></li><li><p>关注 Feed 流可以改为推拉结合模式（活跃用户用推、普通用户用拉）</p></li><li><p>使用哨兵集群来提升 Redis 的读并发量、可用性和稳定性；或者使用 Redis 分片集群来提升 Redis 读写并发量、总存储容量，保障可用性和稳定性。</p></li><li><p>随着系统用户增多，使用 Redis HyperLogLog 代替 DB 来实现店铺和点评的 UV 统计，提高 xx% 的查询分析性能并解决 xx% 的内存空间。</p></li></ol><h3 id="硅谷课堂-在线学习平台" tabindex="-1"><a class="header-anchor" href="#硅谷课堂-在线学习平台" aria-hidden="true">#</a> 硅谷课堂 - 在线学习平台</h3><p>项目介绍：</p><p>基于微服务的在线学习平台，分为公众号前台和 PC 端管理后台，实现了课程发布、信息展示、发券、下单支付、在线点播、观看直播、统计分析的完整业务流程。</p><p>这个项目由于大量对接了第三方服务，所以亮点相对不是很多</p><p>主要工作：</p><ol><li><p>基于 Spring Cloud + Nacos 实现项目的微服务化，根据功能和依赖关系划分出用户、点播、直播、公众号管理、公共服务等模块，并根据服务进行分库，提高项目的可扩展性和容错性。</p></li><li><p>使用 Spring Cloud Gateway 实现微服务请求转发，并在网关层全局解决跨域、用户鉴权、黑白名单、内网服务保护等问题，降低开发成本、提高安全性。（注意，这句话是 Spring Cloud Gateway 万用金句，但在这个项目中只用到了请求转发和解决跨域）</p></li><li><p>使用第三方对象存储来集中存管课程及用户图片，并通过限制大小、校验后缀等方式预防文件上传漏洞，增强安全性。</p></li><li><p>使用 WxJava SDK 代替 HttpClient 方式实现 OAuth2 微信授权登录、公众号菜单管理、模板消息推送，节省开发时间。</p></li><li><p>为降低开发成本，接入第三方视频点播和直播服务（xx 平台），并将官方 SDK 封装为 Service 实现复用。</p></li></ol><p>再列举一些该项目可以扩展的点，有能力的同学可以自己尝试实现（注意，没有自己实现过千万别写到简历上！！！做没做过一问便知）：</p>',16),B={href:"https://cloud.tencent.com/document/product/436/50201%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E5%9C%A8",target:"_blank",rel:"noopener noreferrer"},f=i("li",null,"使用 Mockito 来模拟文件上传等依赖了第三方服务的方法，从而提高系统的单元测试覆盖度，保证系统质量。",-1);function y(k,m){const p=r("ExternalLinkIcon");return o(),n("div",null,[d,i("ol",null,[c,i("li",null,[i("p",null,[l("选用 Spring Cloud Gateway 作为 API 网关，实现了路由转发、访问控制、流量染色，并集中处理签名校验、请求参数校验、接口调用统计等业务逻辑，提高安全性的同时、便于系统开发维护。（更多 API 网关的优点参考："),i("a",h,[l("https://blog.csdn.net/guorui_java/article/details/124112897）"),a(p)])])]),u]),x,i("ol",null,[S,i("li",null,[i("p",null,[l("为保证数据的完整性和一致性，使用 "),i("a",_,[l("@Transactional "),a(p)]),l(" 实现数据库事务，并配置 rollbackFor = Exception.class 来支持受检异常的事务回滚。")])]),g,R,A,b,D]),P,i("ol",null,[i("li",null,[l("使用第三方对象存储来集中存管课程及用户图片，并通过压缩、数据降冷等方式降低约 30% 的存储成本。（可以参考这篇文章进行学习和实践："),i("a",B,[l("https://cloud.tencent.com/document/product/436/50201，可以自己在"),a(p)]),l(" Java 代码层面实现压缩，也可以利用对象存储自带的图像处理能力）")]),f])])}const I=t(s,[["render",y],["__file","项目亮点总结.html.vue"]]);export{I as default};
