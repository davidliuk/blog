import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as n,o as t}from"./app-ChU1gMRF.js";const i={};function l(r,p){return t(),a("div",null,p[0]||(p[0]=[n('<h1 id="递归" tabindex="-1"><a class="header-anchor" href="#递归"><span>递归</span></a></h1><p>啥是递归？</p><p>当函数直接或者间接调用自己时，则发生了递归</p><p>递归的定义：参见“递归的定义”</p><hr><p>递归的三要素</p><ul><li><p>递归的定义 (接收什么参数, 返回什么值, 代表什么含义)</p></li><li><p>递归的拆解 (把大问题拆解成小问题)（或者叫转移）</p></li><li><p>递归的出口 (到什么时候结束)</p></li></ul><hr><p>迭代形式与递归形式比较</p><p>时间复杂度：迭代O(n), 递归O(n)</p><p>空间复杂度：迭代O(1), 递归O(n)</p><p>递归的O(n)空间是栈空间</p><hr><h3 id="内存中的堆和栈" tabindex="-1"><a class="header-anchor" href="#内存中的堆和栈"><span>内存中的堆和栈</span></a></h3><p>堆空间</p><ul><li>存放 new 得到的对象</li><li>无限制 (剩余内存的大小)</li></ul><p>栈空间</p><ul><li>存放对象的引用</li><li>值类型变量</li><li>C++函数中的数组</li><li>有限制, 一般很小, MB量级</li><li>函数调用栈</li></ul><p>函数调用栈</p><p>想象一个“圆筒”，调用的函数需要放到筒里</p><p>第一个进入“圆筒”的是main函数</p><p>每发生一次新的函数调用，就会有一个新函数进入“圆筒”</p><p>正在执行的就是最上面的函数</p><p>一个函数执行完毕，就会被拿出来</p><p>圆筒满了怎么办？</p><p>N 如果过大，有可能还没来得及从圆筒中拿出函数圆筒就满了</p><p>递归需谨慎</p><p>递归调用容易爆栈</p><p>人为调用栈不会爆栈</p><p>除非在C/C++的函数中定义大数组——危险行为</p><hr><p>排序算法（归并排序、快速排序）、傅立叶变换（快速傅立叶变换）。</p><h2 id="参数传递" tabindex="-1"><a class="header-anchor" href="#参数传递"><span>参数传递</span></a></h2><p>Java(值传递，引用传递)</p><p>Python(引用传递)</p><p>C++(值传递，引用传递，指针传递)</p><hr><h3 id="值传递" tabindex="-1"><a class="header-anchor" href="#值传递"><span>值传递</span></a></h3><p>文件复制、克隆羊多莉</p><p>值传递相当于创建个新的变量，把值拷贝一份</p><p>修改新的变量原来的变量不会受到影响</p><hr><p>不同语言中呈现值传递的场景</p><p>Java的基本数据类型</p><p>(byte,short,int,long,float,double,char,boolean)</p><p>C++中默认值传递</p><p>Python没有值传递</p><p>基本数据类型的值传递</p><hr><p>Python 没有值传递</p><p>但是 Python 的不可变类型可以认为是值传递的</p><h3 id="引用传递" tabindex="-1"><a class="header-anchor" href="#引用传递"><span>引用传递</span></a></h3><p>可以理解为别名，代号</p><p>文件的快捷方式</p><p>所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p><p>Java 除基本数据类型以外的其他数据</p><p>C++ 中在参数列表中加地址符 &amp; 修饰</p><p>Python 中全是引用传递</p><h3 id="修改实例和修改引用" tabindex="-1"><a class="header-anchor" href="#修改实例和修改引用"><span>修改实例和修改引用</span></a></h3><p>带 “.” 或者带 “[]” 修改的是实例</p><p>否则修改的是引用</p><p>包装类和不可修改类型的传参</p><p>虽然是引用传递，但是能看成是值传递</p>',63)]))}const h=e(i,[["render",l],["__file","index.html.vue"]]),c=JSON.parse(`{"path":"/algo/summary/search/DFS/recursion/","title":"递归","lang":"en-US","frontmatter":{"description":"递归 啥是递归？ 当函数直接或者间接调用自己时，则发生了递归 递归的定义：参见“递归的定义” 递归的三要素 递归的定义 (接收什么参数, 返回什么值, 代表什么含义) 递归的拆解 (把大问题拆解成小问题)（或者叫转移） 递归的出口 (到什么时候结束) 迭代形式与递归形式比较 时间复杂度：迭代O(n), 递归O(n) 空间复杂度：迭代O(1), 递归O(...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/summary/search/DFS/recursion/"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"递归"}],["meta",{"property":"og:description","content":"递归 啥是递归？ 当函数直接或者间接调用自己时，则发生了递归 递归的定义：参见“递归的定义” 递归的三要素 递归的定义 (接收什么参数, 返回什么值, 代表什么含义) 递归的拆解 (把大问题拆解成小问题)（或者叫转移） 递归的出口 (到什么时候结束) 迭代形式与递归形式比较 时间复杂度：迭代O(n), 递归O(n) 空间复杂度：迭代O(1), 递归O(..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-01-01T21:36:31.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-01T21:36:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"递归\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-01T21:36:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":3,"title":"内存中的堆和栈","slug":"内存中的堆和栈","link":"#内存中的堆和栈","children":[]},{"level":2,"title":"参数传递","slug":"参数传递","link":"#参数传递","children":[{"level":3,"title":"值传递","slug":"值传递","link":"#值传递","children":[]},{"level":3,"title":"引用传递","slug":"引用传递","link":"#引用传递","children":[]},{"level":3,"title":"修改实例和修改引用","slug":"修改实例和修改引用","link":"#修改实例和修改引用","children":[]}]}],"git":{"createdTime":1732244737000,"updatedTime":1735767391000,"contributors":[{"name":"David Liu","email":"liudawei@seas.upenn.edu","commits":1},{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro-3.local","commits":1}]},"readingTime":{"minutes":2.36,"words":709},"filePathRelative":"algo/summary/search/DFS/recursion/README.md","localizedDate":"November 22, 2024","excerpt":"\\n<p>啥是递归？</p>\\n<p>当函数直接或者间接调用自己时，则发生了递归</p>\\n<p>递归的定义：参见“递归的定义”</p>\\n<hr>\\n<p>递归的三要素</p>\\n<ul>\\n<li>\\n<p>递归的定义 (接收什么参数, 返回什么值, 代表什么含义)</p>\\n</li>\\n<li>\\n<p>递归的拆解 (把大问题拆解成小问题)（或者叫转移）</p>\\n</li>\\n<li>\\n<p>递归的出口 (到什么时候结束)</p>\\n</li>\\n</ul>\\n<hr>\\n<p>迭代形式与递归形式比较</p>\\n<p>时间复杂度：迭代O(n), 递归O(n)</p>\\n<p>空间复杂度：迭代O(1), 递归O(n)</p>","autoDesc":true}`);export{h as comp,c as data};
