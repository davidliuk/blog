import{_ as e,V as a,W as i,a0 as r}from"./framework-705b829b.js";const d={},t=r('<h1 id="幂等性" tabindex="-1"><a class="header-anchor" href="#幂等性" aria-hidden="true">#</a> 幂等性</h1><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了侧作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣歌，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等</p><h3 id="防止消息重复消费" tabindex="-1"><a class="header-anchor" href="#防止消息重复消费" aria-hidden="true">#</a> <strong>防止消息重复消费</strong></h3><p>消费者在消费MQ中的消息时，MQ已把消息发送给消费者，消费者在给MQ返回k时网络中断，故MQ未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成诚功消费了该条消息，造成消费者消费了重复的消息，</p><p>MQ消费者的幂等性的解决一般使用全局ID或者写个唯一标识比如时间戳或者UUID或者订单消费者消费MQ中的消息也可利用MQ的该id来判断，或者可按自己的规则生成一个全局唯一id,每次消费消息时用该d先判断该消息是否已消费过，</p><p>消费端的幂等性保障</p><p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性，这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息，业界主流的幂等性有两种操作：</p><ul><li>唯一ID+指纹码机制，利用数据库主键去重，</li><li>利用redis的原子性去实现</li></ul><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h3><ul><li><p>唯一ID+指纹码机制</p><p>性能瓶颈</p></li><li><p>Redis原子性</p><p>最佳方法</p></li></ul>',11),h=[t];function n(s,l){return a(),i("div",null,h)}const p=e(d,[["render",n],["__file","幂等性.html.vue"]]);export{p as default};
