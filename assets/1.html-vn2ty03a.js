import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as n,o as a}from"./app-TGRQBxvj.js";const o={};function r(s,i){return a(),t("div",null,i[0]||(i[0]=[n('<h1 id="models-of-computation-undecidability-complexity-classes" tabindex="-1"><a class="header-anchor" href="#models-of-computation-undecidability-complexity-classes"><span>Models of Computation, Undecidability Complexity Classes</span></a></h1><p>family of functions that should be regarded as “obviously computable,”</p><p>base functions</p><ol><li>Composition</li><li>Primitive recursion</li><li>Minimization</li></ol><p>Historically, the first two models of computation are</p><ul><li>the λ-calculus of Church (1935)</li><li>the Turing machine (1936) of Turing.</li></ul><p>the λ-calculus and Turing machines have the same “computing power,” and both compute exactly the class of computable functions in the sense of Herbrand–G¨odel–Kleene.</p><h2 id="partial-functions-and-ram-programs" tabindex="-1"><a class="header-anchor" href="#partial-functions-and-ram-programs"><span>Partial Functions and RAM Programs</span></a></h2><h3 id="partial-functions" tabindex="-1"><a class="header-anchor" href="#partial-functions"><span>Partial Functions</span></a></h3><p>Partial Functions:</p><ul><li>domain, <code>dom(f)</code></li><li>undefined</li></ul><p>total function, iff dom(f)=A</p><h3 id="ram-program" tabindex="-1"><a class="header-anchor" href="#ram-program"><span>RAM Program</span></a></h3><p>A RAM program P (in linear form) consists of a finite sequence of instructions using a finite number of registers R1, . . . , Rp.</p><p>Instructions may optionally be labeled with line numbers<br> denoted as N1, . . . , Nq.<br> It is neither mandatory to label all instructions, nor to<br> use distinct line numbers!<br> Thus, the same line number can be used in more than<br> one line. As we will see later on, this makes it easier to<br> concatenate two di↵erent programs without performing a<br> renumbering of line numbers.<br> Every instruction has four fields, not necessarily all used.<br> The main field is the op-code.</p><p>Definition 1.2. RAM programs are constructed from seven types of instructions shown below</p><p><img src="https://raw.githubusercontent.com/davidliuk/images/master/blogimage-20250410102623414.png" alt="image-20250410102623414" loading="lazy"></p><p>A RAM program P is a finite sequence of instructions as in Definition 1.2, and satisfying the following conditions:</p><ul><li>(1) For every jump instruction (conditional or not), the<br> line number to be jumped to must exist in P.</li><li>(2) The last instruction of a RAM program is a continue.</li></ul><p>Definition 1.4. A RAM program P computes the partial function &#39;: (⌃⇤)n ! ⌃⇤ if the following conditions hold: For every input (x1, . . . , xn) 2 (⌃⇤)n, having initialized the input registers R1, . . . , Rn with x1, . . . , xn, the program eventually halts i↵ &#39;(x1, . . . , xn) is defined, and if and when P halts, the value of R1 is equal to &#39;(x1, . . . , xn)</p><p>A partial function &#39; is RAM-computable i↵ it is computed by some RAM program.</p><p>For example, the following program computes the erase function E defined such that</p><p>RAM-computable</p><ul><li>One way of getting new programs from previous ones is via composition.</li><li>Another one is by primitive recursion.</li></ul><p>We will investigate these constructions after introducing another model of computation, Turing machines.</p><p>Remarkably, the classes of (partial) functions computed by RAM programs and by Turing machines are identical.</p><p>This is the class of partial computable functions, also called partial recursive functions, a term which is now considered old-fashion.</p><p>This class can be given several other definitions.</p><p>Lemma 1.1. Every RAM program can be converted to an equivalent program only using the following type of instructions:</p><h2 id="definition-of-a-turing-machine" tabindex="-1"><a class="header-anchor" href="#definition-of-a-turing-machine"><span>Definition of a Turing Machine</span></a></h2><p>A quintuple (p, a, b, m, q) 2 δ is called an instruction. It is also denoted as</p><p>p, a -&gt; b, m, q</p><p>The effect of an instruction is to switch from state p to state q, overwrite the symbol currently scanned a with b, and move the read/write head either left or right, according to m.</p><p>Here is an example of a Turing machine.</p><h2 id="computations-of-turing-machines" tabindex="-1"><a class="header-anchor" href="#computations-of-turing-machines"><span>Computations of Turing Machines</span></a></h2><p>Instantaneous descriptions</p><h2 id="the-primitive-recursive-functions" tabindex="-1"><a class="header-anchor" href="#the-primitive-recursive-functions"><span>The Primitive Recursive Functions</span></a></h2><p>The base functions over ⌃ are the following functions:</p><p>For any partial or total function</p><p>Given any two partial or total functions g : Nm1 ! N and h: Nm+1 ! N (m 2), the partial or total function f : Nm ! N is defined by primitive recursion from g and h if f is given by</p><h2 id="primitive-recursive-predicates" tabindex="-1"><a class="header-anchor" href="#primitive-recursive-predicates"><span>Primitive Recursive Predicates</span></a></h2><p>An n-ary predicate P over N is any subset of Nn. We write that a tuple (x1,...,xn) satisfies P as (x1,...,xn) 2 P or as P(x1,...,xn). The characteristic function of a predicate P is the function CP : Nn ! {0, 1} defined by</p><p>A predicate P (over N) is primitive recursive i↵ its characteristic function CP is primitive recursive.</p>',43)]))}const p=e(o,[["render",r],["__file","1.html.vue"]]),u=JSON.parse(`{"path":"/education/ms/5110/part2/1.html","title":"Models of Computation, Undecidability Complexity Classes","lang":"en-US","frontmatter":{"description":"Models of Computation, Undecidability Complexity Classes family of functions that should be regarded as “obviously computable,” base functions Composition Primitive recursion Mi...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/education/ms/5110/part2/1.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"Models of Computation, Undecidability Complexity Classes"}],["meta",{"property":"og:description","content":"Models of Computation, Undecidability Complexity Classes family of functions that should be regarded as “obviously computable,” base functions Composition Primitive recursion Mi..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/davidliuk/images/master/blogimage-20250410102623414.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-05-28T16:32:52.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-28T16:32:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Models of Computation, Undecidability Complexity Classes\\",\\"image\\":[\\"https://raw.githubusercontent.com/davidliuk/images/master/blogimage-20250410102623414.png\\"],\\"dateModified\\":\\"2025-05-28T16:32:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"Partial Functions and RAM Programs","slug":"partial-functions-and-ram-programs","link":"#partial-functions-and-ram-programs","children":[{"level":3,"title":"Partial Functions","slug":"partial-functions","link":"#partial-functions","children":[]},{"level":3,"title":"RAM Program","slug":"ram-program","link":"#ram-program","children":[]}]},{"level":2,"title":"Definition of a Turing Machine","slug":"definition-of-a-turing-machine","link":"#definition-of-a-turing-machine","children":[]},{"level":2,"title":"Computations of Turing Machines","slug":"computations-of-turing-machines","link":"#computations-of-turing-machines","children":[]},{"level":2,"title":"The Primitive Recursive Functions","slug":"the-primitive-recursive-functions","link":"#the-primitive-recursive-functions","children":[]},{"level":2,"title":"Primitive Recursive Predicates","slug":"primitive-recursive-predicates","link":"#primitive-recursive-predicates","children":[]}],"git":{"createdTime":1748449972000,"updatedTime":1748449972000,"contributors":[{"name":"David","email":"l729641074@163.com","commits":1}]},"readingTime":{"minutes":2.21,"words":663},"filePathRelative":"education/ms/5110/part2/1.md","localizedDate":"May 28, 2025","excerpt":"\\n<p>family of functions that should be regarded as “obviously computable,”</p>\\n<p>base functions</p>\\n<ol>\\n<li>Composition</li>\\n<li>Primitive recursion</li>\\n<li>Minimization</li>\\n</ol>\\n<p>Historically, the first two models of computation are</p>\\n<ul>\\n<li>the λ-calculus of Church (1935)</li>\\n<li>the Turing machine (1936) of Turing.</li>\\n</ul>","autoDesc":true}`);export{p as comp,u as data};
