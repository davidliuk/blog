import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as l,o}from"./app-z8Dpj-As.js";const n={};function a(p,e){return o(),i("div",null,e[0]||(e[0]=[l('<h1 id="i-o" tabindex="-1"><a class="header-anchor" href="#i-o"><span>I/O</span></a></h1><blockquote><p><a href="https://blog.csdn.net/lixinkuan328/article/details/114198739" target="_blank" rel="noopener noreferrer">参考</a></p></blockquote><p>UNIX 系统下， IO 模型一共有 5 种：</p><ul><li>同步阻塞 I/O、</li><li>同步非阻塞 I/O、</li><li>事件驱动 I/O （多路复用 I/O）</li><li>信号驱动 I/O</li><li>异步 I/O</li></ul><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/83871b6390d8c993af4c9b02b8dccf31.png" alt="img" loading="lazy"></p><p>为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p><p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</p><p>并且，用户空间的程序不能直接访问内核空间。</p><p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p><p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p><p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。</p><p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><p>当应用程序发起 I/O 调用后，会经历两个步骤：</p><ol><li>内核等待 I/O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间</li></ol><h2 id="多路复用-multiplexing" tabindex="-1"><a class="header-anchor" href="#多路复用-multiplexing"><span>多路复用 Multiplexing</span></a></h2><p>select</p><p>poll</p><p>epoll</p><p>IO multiplexing 就是我们说的select，poll，epoll，也称为event driven IO。java中NIO使用的就是该模型，也就是使用的Linux的epoll库。JDK1.4之前只支持阻塞IO，在JDK1.4引入了NIO，在JDK1.7对NIO包进行了升级，支持了异步IO。现在手写NIO的比较少了，大都是直接使用netty进行开发。它们用到的就是经典的reactor模式。</p><p>由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。UNIX/Linux 下的 select、poll、epoll 就是干这个的（epoll 比 poll、select 效率高，做的事情是一样的）。这就是所谓的 “IO 多路复用”。</p><p>select调用是内核级别的，select轮询能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。所以IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。</p><p>对于多路复用其实也就是轮询多个socket。具体流程，如下图所示：</p><h2 id="异步-i-o" tabindex="-1"><a class="header-anchor" href="#异步-i-o"><span>异步 I/O</span></a></h2><p>asynchronous IO 即经典的Proactor设计模式相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。Linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。异步过程如下图所示：</p>',24)]))}const c=t(n,[["render",a],["__file","index.html.vue"]]),d=JSON.parse(`{"path":"/cs/basic/os/io/","title":"I/O","lang":"en-US","frontmatter":{"description":"I/O 参考 UNIX 系统下， IO 模型一共有 5 种： 同步阻塞 I/O、 同步非阻塞 I/O、 事件驱动 I/O （多路复用 I/O） 信号驱动 I/O 异步 I/O img 为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space ） 。 像我们平常运行的应用程序都是...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/cs/basic/os/io/"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"I/O"}],["meta",{"property":"og:description","content":"I/O 参考 UNIX 系统下， IO 模型一共有 5 种： 同步阻塞 I/O、 同步非阻塞 I/O、 事件驱动 I/O （多路复用 I/O） 信号驱动 I/O 异步 I/O img 为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space ） 。 像我们平常运行的应用程序都是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/83871b6390d8c993af4c9b02b8dccf31.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-22T03:06:21.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-22T03:06:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"I/O\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/83871b6390d8c993af4c9b02b8dccf31.png\\"],\\"dateModified\\":\\"2024-11-22T03:06:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"多路复用 Multiplexing","slug":"多路复用-multiplexing","link":"#多路复用-multiplexing","children":[]},{"level":2,"title":"异步 I/O","slug":"异步-i-o","link":"#异步-i-o","children":[]}],"git":{"createdTime":1715153702000,"updatedTime":1732244781000,"contributors":[{"name":"David Liu","email":"liudawei@seas.upenn.edu","commits":1},{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":1}]},"readingTime":{"minutes":3.35,"words":1004},"filePathRelative":"cs/basic/os/io/README.md","localizedDate":"May 8, 2024","excerpt":"\\n<blockquote>\\n<p><a href=\\"https://blog.csdn.net/lixinkuan328/article/details/114198739\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">参考</a></p>\\n</blockquote>\\n<p>UNIX 系统下， IO 模型一共有 5 种：</p>\\n<ul>\\n<li>同步阻塞 I/O、</li>\\n<li>同步非阻塞 I/O、</li>\\n<li>事件驱动 I/O （多路复用 I/O）</li>\\n<li>信号驱动 I/O</li>\\n<li>异步 I/O</li>\\n</ul>\\n<p><img src=\\"https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/83871b6390d8c993af4c9b02b8dccf31.png\\" alt=\\"img\\" loading=\\"lazy\\"></p>","autoDesc":true}`);export{c as comp,d as data};
