import{_ as e,V as a,W as s,a0 as n}from"./framework-705b829b.js";const p={},r=n(`<h1 id="使用原则" tabindex="-1"><a class="header-anchor" href="#使用原则" aria-hidden="true">#</a> 使用原则</h1><h2 id="最左前缀法则" tabindex="-1"><a class="header-anchor" href="#最左前缀法则" aria-hidden="true">#</a> 最左前缀法则</h2><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。</p><p>如果跳跃某一列，索引将部分失效(后面的字段索引失效)。</p><p>最左边的列必须存在，否则不走索引（索引不生效）</p><blockquote><p>右边缺省不影响，可以索引的右边部分失效</p></blockquote><h3 id="范围查询" tabindex="-1"><a class="header-anchor" href="#范围查询" aria-hidden="true">#</a> 范围查询</h3><p>范围查询（&gt;, &lt;）右边的列的部分索引失效</p><blockquote><p><code>&gt;=</code>, <code>&lt;=</code>不会导致索引失效，所以尽量使用这两个</p></blockquote><p>字符串不加单引号，不会走索引（虽然可以走普通的查）</p><h3 id="模糊查询" tabindex="-1"><a class="header-anchor" href="#模糊查询" aria-hidden="true">#</a> 模糊查询</h3><p>如果仅仅是尾部模糊查询，索引不会失效，如果头部模糊查询，索引失效</p><ul><li><code>A%</code> 可以</li><li><code>%A</code> 不行</li></ul><h2 id="索引失效" tabindex="-1"><a class="header-anchor" href="#索引失效" aria-hidden="true">#</a> 索引失效</h2><h3 id="索引列函数" tabindex="-1"><a class="header-anchor" href="#索引列函数" aria-hidden="true">#</a> 索引列函数</h3><p>不要在索引列上进行运算操作，索引将失效。不能进行的运算包括：</p><ul><li>表达式</li><li>函数调用</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> substring<span class="token punctuation">(</span>phone<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&#39;15&#39;</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> id <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="索引列隐式转换" tabindex="-1"><a class="header-anchor" href="#索引列隐式转换" aria-hidden="true">#</a> 索引列隐式转换</h3><p>MySQL隐式转换规则：<strong>在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。</p><p>如果索引字段是字符串存的纯数字序列，查询的时候用的整数去匹配的就会发生隐式转换，将字符串转化为整数进行比较，从而发生索引失效（因为相当于对索引列进行了CAST函数），例如：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token number">15000000000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="模糊查询-1" tabindex="-1"><a class="header-anchor" href="#模糊查询-1" aria-hidden="true">#</a> 模糊查询</h3><p>如果仅仅是尾部模糊查询，索引不会失效，如果头部模糊查询，索引失效</p><ul><li><code>A%</code> 可以索引</li><li><code>%A</code> 不能索引</li></ul><h3 id="or连接的条件" tabindex="-1"><a class="header-anchor" href="#or连接的条件" aria-hidden="true">#</a> or连接的条件</h3><p>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p><blockquote><p>都有索引就可以生效</p></blockquote><h3 id="数据分布影响" tabindex="-1"><a class="header-anchor" href="#数据分布影响" aria-hidden="true">#</a> 数据分布影响</h3><p>如果MySQL评估使用索引比全表更慢，则不使用索引。根据代价（优化器自动评估）</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">&gt;=</span> <span class="token string">&#39;150000000&#39;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">&gt;=</span> <span class="token string">&#39;150000015&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="sql提示" tabindex="-1"><a class="header-anchor" href="#sql提示" aria-hidden="true">#</a> SQL提示</h2><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>use index：建议用哪个索引</p><p><code>explain select * from tb_user use(idx_user_pro) where profession=&#39;1&#39;</code></p><p>ignore index：忽略哪个索引</p><p><code>explain select * from tb_user ignore(idx_user_pro)</code></p><p>Force index：必须用这个索引</p><h2 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引" aria-hidden="true">#</a> 覆盖索引</h2><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），可以减少回表查询，提高效率。</p><blockquote><p>减少<code>select *</code>。这样及容产生回表查询</p></blockquote><p>知识小贴士：</p><ul><li>using index condition:查找使用了索引，但是需要回表查询数据</li><li>using where; using index:查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-25 20.48.48.png" alt="截屏2023-02-25 20.48.48" loading="lazy"></p><p>eg. 优化如下SQL，<code>select id, name, password from table where name = &#39;li&#39;</code>，如何建立索引效率最高</p><p>建立(name, password)链和索引</p><h2 id="前缀索引" tabindex="-1"><a class="header-anchor" href="#前缀索引" aria-hidden="true">#</a> 前缀索引</h2><p>当字段类型为字符串(varchar,text等)时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘O,影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：</p><p><code>create index idx_xxx on table_name(column(n))</code></p><p>长度：</p><p>找区分度比较好的字符前缀个数即可，尽量短</p><h2 id="单列索引与联合索引" tabindex="-1"><a class="header-anchor" href="#单列索引与联合索引" aria-hidden="true">#</a> 单列索引与联合索引</h2><ul><li>单列索引：即一个索引只包含单个列：</li><li>联合素引：即一个索引包含了多个列。</li><li>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立素引时，建议建立联合索引，而非单列索引。</li></ul><p>在MySQL中使用!=还能走索引吗？</p><p>走不走索引，只取决于一个因素，那就是成本。</p><p>我们知道，MySQL中有一个叫做优化器的东西，他会对每一条查询sql做成本分析，然后根据分析结果选择是否使用索引或者全表扫描。</p><p>如果使用二级索引的成本更低，MySQL就会倾向于使用二级索引。</p><p>如果使用二级索引扫描的行数占比过高，导致需要频繁的回表，MySQL经过计算之后觉得走二级索引的代价太大了，就会使用全表扫描。</p>`,59),o=[r];function d(l,i){return a(),s("div",null,o)}const c=e(p,[["render",d],["__file","4. 使用规则.html.vue"]]);export{c as default};
