const e=JSON.parse(`{"key":"v-279ee58f","path":"/se/lang/java/jvm/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%E5%88%A4%E5%AE%9A.html","title":"对象死亡判定","lang":"en-US","frontmatter":{"description":"对象死亡判定 引用计数 优点： 原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。 缺点： 占用了一些额外的内存空间来进行计数 难以解决循环引用的问题；它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也 就无法回收它们。 可达性分析 这个算法的基本思路就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到 GC Roots 间没有任何引用链相连， 或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/se/lang/java/jvm/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%E5%88%A4%E5%AE%9A.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"对象死亡判定"}],["meta",{"property":"og:description","content":"对象死亡判定 引用计数 优点： 原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。 缺点： 占用了一些额外的内存空间来进行计数 难以解决循环引用的问题；它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也 就无法回收它们。 可达性分析 这个算法的基本思路就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到 GC Roots 间没有任何引用链相连， 或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-01-08T03:06:14.000Z"}],["meta",{"property":"article:author","content":"David Liu"}],["meta",{"property":"article:modified_time","content":"2024-01-08T03:06:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"对象死亡判定\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-01-08T03:06:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"引用计数","slug":"引用计数","link":"#引用计数","children":[]},{"level":2,"title":"可达性分析","slug":"可达性分析","link":"#可达性分析","children":[{"level":3,"title":"GC Roots 的选择","slug":"gc-roots-的选择","link":"#gc-roots-的选择","children":[]},{"level":3,"title":"生存还是死亡","slug":"生存还是死亡","link":"#生存还是死亡","children":[]}]},{"level":2,"title":"回收方法区","slug":"回收方法区","link":"#回收方法区","children":[{"level":3,"title":"废弃常量","slug":"废弃常量","link":"#废弃常量","children":[]},{"level":3,"title":"不再使用的类型","slug":"不再使用的类型","link":"#不再使用的类型","children":[]}]}],"git":{"createdTime":1704683174000,"updatedTime":1704683174000,"contributors":[{"name":"davidliu","email":"liudawei47@jd.com","commits":1}]},"readingTime":{"minutes":6.13,"words":1838},"filePathRelative":"se/lang/java/jvm/内存管理/垃圾回收/对象死亡判定.md","localizedDate":"January 8, 2024","excerpt":"<h1> 对象死亡判定</h1>\\n<h2> 引用计数</h2>\\n<p>优点：</p>\\n<ul>\\n<li>原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。</li>\\n</ul>\\n<p>缺点：</p>\\n<ul>\\n<li>占用了一些额外的内存空间来进行计数</li>\\n<li>难以解决循环引用的问题；它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也 就无法回收它们。</li>\\n</ul>\\n<h2> 可达性分析</h2>\\n<p>这个算法的基本思路就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到 GC Roots 间没有任何引用链相连， 或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。</p>","autoDesc":true}`);export{e as data};
