import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as t,o as a}from"./app-DIqbhby7.js";const n={};function l(p,e){return a(),i("div",null,e[0]||(e[0]=[t(`<h1 id="comet-推送" tabindex="-1"><a class="header-anchor" href="#comet-推送"><span>Comet 推送</span></a></h1><ul><li><p><strong>WebSocket</strong></p></li><li><p>SSE（Server-Sent Events）</p></li><li><p>Polling</p></li><li><p>mqtt</p></li></ul><h2 id="polling-轮询" tabindex="-1"><a class="header-anchor" href="#polling-轮询"><span>Polling 轮询</span></a></h2><p><strong>轮询(polling)</strong> 应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。</p><h3 id="短轮询" tabindex="-1"><a class="header-anchor" href="#短轮询"><span>短轮询</span></a></h3><p>短轮询很好理解，指定的时间间隔，由浏览器向服务器发出 HTTP 请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。</p><p>一个简单的 JS 定时器就可以搞定，每秒钟请求一次未读消息数接口，返回的数据展示即可。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setInterval</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 方法请求</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  messageCount</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">res</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">res</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">code</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> ===</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 200</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">      this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">messageCount</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> res</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  });</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果还是可以的，短轮询实现固然简单，缺点也是显而易见，由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求，势必会对服务端造成很大压力，浪费带宽和服务器资源。</p><h3 id="长轮询" tabindex="-1"><a class="header-anchor" href="#长轮询"><span>长轮询</span></a></h3><p>长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如 Nacos 和 Apollo 配置中心，消息队列 Kafka、RocketMQ 中都有用到长轮询。</p><p><a href="https://mp.weixin.qq.com/s/94ftESkDoZI9gAGflLiGwg" target="_blank" rel="noopener noreferrer">Nacos 配置中心交互模型是 push 还是 pull？</a>一文中我详细介绍过 Nacos 长轮询的实现原理，感兴趣的小伙伴可以瞅瞅。</p><p>长轮询其实原理跟轮询差不多，都是采用轮询的方式。不过，如果服务端的数据没有发生变更，会一直 hold 住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询。</p><p>这次我使用 Apollo 配置中心实现长轮询的方式，应用了一个类<code>DeferredResult</code>，它是在 Servlet3.0 后经过 Spring 封装提供的一种异步请求机制，直意就是延迟结果。</p><h3 id="推与拉模型" tabindex="-1"><a class="header-anchor" href="#推与拉模型"><span>推与拉模型</span></a></h3><p>客户端与配置中心的数据交互方式其实无非就两种，要么推<code>push</code>，要么拉<code>pull</code>。</p><p><strong>推模型</strong></p><p>客户端与服务端建立<code>TCP</code>长连接，当服务端配置数据有变动，立刻通过建立的长连接将数据推送给客户端。</p><p>优势：长链接的优点是实时性，一旦数据变动，立即推送变更数据给客户端，而且对于客户端而言，这种方式更为简单，只建立连接接收数据，并不需要关心是否有数据变更这类逻辑的处理。</p><p>弊端：长连接可能会因为网络问题，导致不可用，也就是俗称的<code>假死</code>。连接状态正常，但实际上已无法通信，所以要有的心跳机制<code>KeepAlive</code>来保证连接的可用性，才可以保证配置数据的成功推送。</p><p><strong>拉模型</strong></p><p>客户端主动的向服务端发请求拉配置数据，常见的方式就是轮询，比如每3s向服务端请求一次配置数据。</p><p>轮询的优点是实现比较简单。但弊端也显而易见，轮询无法保证数据的实时性，什么时候请求？间隔多长时间请求一次？都是不得不考虑的问题，而且轮询方式对服务端还会产生不小的压力。</p><h2 id="sse-server-sent-events" tabindex="-1"><a class="header-anchor" href="#sse-server-sent-events"><span>SSE (Server-Sent Events)</span></a></h2><p>很多人可能不知道，服务端向客户端推送消息，其实除了可以用<code>WebSocket</code>这种耳熟能详的机制外，还有一种服务器发送事件(Server-Sent Events)，简称 SSE。这是一种服务器端到客户端(浏览器)的单向消息推送。</p><p>大名鼎鼎的 ChatGPT 就是采用的 SSE。对于需要长时间等待响应的对话场景，ChatGPT 采用了一种巧妙的策略：它会将已经计算出的数据“推送”给用户，并利用 SSE 技术在计算过程中持续返回数据。这样做的好处是可以避免用户因等待时间过长而选择关闭页面。</p><p>SSE 基于 HTTP 协议的，我们知道一般意义上的 HTTP 协议是无法做到服务端主动向客户端推送消息的，但 SSE 是个例外，它变换了一种思路。</p><p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192390.png" alt="img" loading="lazy"></p><p>SSE 在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是<code>text/event-stream</code>类型的数据流信息，在有数据变更时从服务器流式传输到客户端。</p><p>整体的实现思路有点类似于在线视频播放，视频流会连续不断的推送到浏览器，你也可以理解成，客户端在完成一次用时很长（网络不畅）的下载。</p><p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192391.png" alt="SSE 示意图" loading="lazy">SSE 示意图</p><p>SSE 与 WebSocket 作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：</p><ul><li>SSE 是基于 HTTP 协议的，它们不需要特殊的协议或服务器实现即可工作；WebSocket 需单独服务器来处理协议。</li><li>SSE 单向通信，只能由服务端向客户端单向通信；WebSocket 全双工通信，即通信的双方可以同时发送和接受信息。</li><li>SSE 实现简单开发成本低，无需引入其他组件；WebSocket 传输数据需做二次解析，开发门槛高一些。</li><li>SSE 默认支持断线重连；WebSocket 则需要自己实现。</li><li>SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket 默认支持传送二进制数据。</li></ul><h2 id="websocket" tabindex="-1"><a class="header-anchor" href="#websocket"><span>WebSocket</span></a></h2>`,34)]))}const o=s(n,[["render",l],["__file","comet.html.vue"]]),d=JSON.parse(`{"path":"/se/design/system/comet.html","title":"Comet 推送","lang":"en-US","frontmatter":{"description":"Comet 推送 WebSocket SSE（Server-Sent Events） Polling mqtt Polling 轮询 轮询(polling) 应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。 短轮询 短轮询很好理解，指定的时间间隔，由浏览器向服务器发出 HTTP 请求，服务器实时返回未读消息数据给客户端，浏览...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/se/design/system/comet.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"Comet 推送"}],["meta",{"property":"og:description","content":"Comet 推送 WebSocket SSE（Server-Sent Events） Polling mqtt Polling 轮询 轮询(polling) 应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。 短轮询 短轮询很好理解，指定的时间间隔，由浏览器向服务器发出 HTTP 请求，服务器实时返回未读消息数据给客户端，浏览..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192390.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-22T03:15:57.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-22T03:15:57.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Comet 推送\\",\\"image\\":[\\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192390.png\\",\\"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192391.png\\"],\\"dateModified\\":\\"2024-11-22T03:15:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"Polling 轮询","slug":"polling-轮询","link":"#polling-轮询","children":[{"level":3,"title":"短轮询","slug":"短轮询","link":"#短轮询","children":[]},{"level":3,"title":"长轮询","slug":"长轮询","link":"#长轮询","children":[]},{"level":3,"title":"推与拉模型","slug":"推与拉模型","link":"#推与拉模型","children":[]}]},{"level":2,"title":"SSE (Server-Sent Events)","slug":"sse-server-sent-events","link":"#sse-server-sent-events","children":[]},{"level":2,"title":"WebSocket","slug":"websocket","link":"#websocket","children":[]}],"git":{"createdTime":1732245357000,"updatedTime":1732245357000,"contributors":[{"name":"David Liu","email":"liudawei@seas.upenn.edu","commits":1}]},"readingTime":{"minutes":4.9,"words":1471},"filePathRelative":"se/design/system/comet.md","localizedDate":"November 22, 2024","excerpt":"\\n<ul>\\n<li>\\n<p><strong>WebSocket</strong></p>\\n</li>\\n<li>\\n<p>SSE（Server-Sent Events）</p>\\n</li>\\n<li>\\n<p>Polling</p>\\n</li>\\n<li>\\n<p>mqtt</p>\\n</li>\\n</ul>\\n<h2>Polling 轮询</h2>\\n<p><strong>轮询(polling)</strong> 应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。</p>\\n<h3>短轮询</h3>\\n<p>短轮询很好理解，指定的时间间隔，由浏览器向服务器发出 HTTP 请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。</p>","autoDesc":true}`);export{o as comp,d as data};
