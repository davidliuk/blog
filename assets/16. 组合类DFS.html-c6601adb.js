const n=JSON.parse(`{"key":"v-40426b8c","path":"/cs/algo/summary/16.%20%E7%BB%84%E5%90%88%E7%B1%BBDFS.html","title":"DFS组合类","lang":"en-US","frontmatter":{"description":"DFS组合类 dfs构建的过程中，思考的方式：递归的那一行不需要往下去思考，就直接考虑到递归出口的效果即可当做这一行执行完了，然后继续往下考虑。 回溯的时候，i这些整数，不需要进行回溯，因为整数这些基本类型是深拷贝的，只有数组对象这些东西，需要回溯，因为他们是引用传递的，其实也可以通过深拷贝来代替回溯 本问题下：深度优先搜索是一种更加灵活的方式，可以不知道循环的层数 所有子集 实现一，实现subset所有子集的方法 是0-1法，只有搜索树的叶子是所需要的结果 public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) { return results; } Arrays.sort(nums); dfs(nums, 0, new ArrayLisy&lt;Integer&gt;(), results); return results; } // 1. 递归的定义 public void dfs( \\tint[] nums, int index, List&lt;Integer&gt; subset, List&lt;List&lt;Integer&gt;&gt; results ) { // 3. 递归的出口 if (index == nums.length) { // 深拷贝 results.add(new ArrayList&lt;Integer&gt;(result)); return; } // 2. 递归的拆解 // 选 nums[index] subset.add(nums[index]); dfs(nums, i + 1, subset, result); subset.remove(subset.size() - 1); dfs(nums, i + 1, subset, result); }","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/cs/algo/summary/16.%20%E7%BB%84%E5%90%88%E7%B1%BBDFS.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"DFS组合类"}],["meta",{"property":"og:description","content":"DFS组合类 dfs构建的过程中，思考的方式：递归的那一行不需要往下去思考，就直接考虑到递归出口的效果即可当做这一行执行完了，然后继续往下考虑。 回溯的时候，i这些整数，不需要进行回溯，因为整数这些基本类型是深拷贝的，只有数组对象这些东西，需要回溯，因为他们是引用传递的，其实也可以通过深拷贝来代替回溯 本问题下：深度优先搜索是一种更加灵活的方式，可以不知道循环的层数 所有子集 实现一，实现subset所有子集的方法 是0-1法，只有搜索树的叶子是所需要的结果 public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) { return results; } Arrays.sort(nums); dfs(nums, 0, new ArrayLisy&lt;Integer&gt;(), results); return results; } // 1. 递归的定义 public void dfs( \\tint[] nums, int index, List&lt;Integer&gt; subset, List&lt;List&lt;Integer&gt;&gt; results ) { // 3. 递归的出口 if (index == nums.length) { // 深拷贝 results.add(new ArrayList&lt;Integer&gt;(result)); return; } // 2. 递归的拆解 // 选 nums[index] subset.add(nums[index]); dfs(nums, i + 1, subset, result); subset.remove(subset.size() - 1); dfs(nums, i + 1, subset, result); }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-01-01T04:24:51.000Z"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2023-01-01T04:24:51.000Z"}],["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://davidliuk.github.io/blog/blog/zh/cs/algo/summary/16.%20%E7%BB%84%E5%90%88%E7%B1%BBDFS.html"}]]},"headers":[],"git":{"createdTime":1670121259000,"updatedTime":1672547091000,"contributors":[{"name":"DavidLiu","email":"l729641074@163.com","commits":1},{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":1}]},"readingTime":{"minutes":1.99,"words":597},"localizedDate":"December 4, 2022","filePathRelative":"cs/algo/summary/16. 组合类DFS.md","excerpt":"<h1> DFS组合类</h1>\\n<p>dfs构建的过程中，思考的方式：递归的那一行不需要往下去思考，就直接考虑到递归出口的效果即可当做这一行执行完了，然后继续往下考虑。</p>\\n<p>回溯的时候，i这些整数，不需要进行回溯，因为整数这些基本类型是深拷贝的，只有数组对象这些东西，需要回溯，因为他们是引用传递的，其实也可以通过深拷贝来代替回溯</p>\\n<p>本问题下：深度优先搜索是一种更加灵活的方式，可以不知道循环的层数</p>\\n<p>所有子集</p>\\n<p>实现一，实现subset所有子集的方法</p>\\n<p>是0-1法，只有搜索树的叶子是所需要的结果</p>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">public</span> <span class=\\"token class-name\\">List</span><span class=\\"token generics\\"><span class=\\"token punctuation\\">&lt;</span><span class=\\"token class-name\\">List</span><span class=\\"token punctuation\\">&lt;</span><span class=\\"token class-name\\">Integer</span><span class=\\"token punctuation\\">&gt;</span><span class=\\"token punctuation\\">&gt;</span></span> <span class=\\"token function\\">subsets</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">int</span><span class=\\"token punctuation\\">[</span><span class=\\"token punctuation\\">]</span> nums<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token class-name\\">List</span><span class=\\"token generics\\"><span class=\\"token punctuation\\">&lt;</span><span class=\\"token class-name\\">List</span><span class=\\"token punctuation\\">&lt;</span><span class=\\"token class-name\\">Integer</span><span class=\\"token punctuation\\">&gt;</span><span class=\\"token punctuation\\">&gt;</span></span> results <span class=\\"token operator\\">=</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">ArrayList</span><span class=\\"token generics\\"><span class=\\"token punctuation\\">&lt;</span><span class=\\"token punctuation\\">&gt;</span></span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token keyword\\">if</span> <span class=\\"token punctuation\\">(</span>nums <span class=\\"token operator\\">==</span> <span class=\\"token keyword\\">null</span> <span class=\\"token operator\\">||</span> nums<span class=\\"token punctuation\\">.</span>length <span class=\\"token operator\\">==</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n        <span class=\\"token keyword\\">return</span> results<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n    <span class=\\"token class-name\\">Arrays</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">sort</span><span class=\\"token punctuation\\">(</span>nums<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token function\\">dfs</span><span class=\\"token punctuation\\">(</span>nums<span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">,</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">ArrayLisy</span><span class=\\"token generics\\"><span class=\\"token punctuation\\">&lt;</span><span class=\\"token class-name\\">Integer</span><span class=\\"token punctuation\\">&gt;</span></span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">,</span> results<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token keyword\\">return</span> results<span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n\\n<span class=\\"token comment\\">// 1. 递归的定义</span>\\n<span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">dfs</span><span class=\\"token punctuation\\">(</span>\\n\\t<span class=\\"token keyword\\">int</span><span class=\\"token punctuation\\">[</span><span class=\\"token punctuation\\">]</span> nums<span class=\\"token punctuation\\">,</span>\\n    <span class=\\"token keyword\\">int</span> index<span class=\\"token punctuation\\">,</span>\\n    <span class=\\"token class-name\\">List</span><span class=\\"token generics\\"><span class=\\"token punctuation\\">&lt;</span><span class=\\"token class-name\\">Integer</span><span class=\\"token punctuation\\">&gt;</span></span> subset<span class=\\"token punctuation\\">,</span>\\n    <span class=\\"token class-name\\">List</span><span class=\\"token generics\\"><span class=\\"token punctuation\\">&lt;</span><span class=\\"token class-name\\">List</span><span class=\\"token punctuation\\">&lt;</span><span class=\\"token class-name\\">Integer</span><span class=\\"token punctuation\\">&gt;</span><span class=\\"token punctuation\\">&gt;</span></span> results\\n<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token comment\\">// 3. 递归的出口</span>\\n    <span class=\\"token keyword\\">if</span> <span class=\\"token punctuation\\">(</span>index <span class=\\"token operator\\">==</span> nums<span class=\\"token punctuation\\">.</span>length<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n        <span class=\\"token comment\\">// 深拷贝</span>\\n        results<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">add</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">ArrayList</span><span class=\\"token generics\\"><span class=\\"token punctuation\\">&lt;</span><span class=\\"token class-name\\">Integer</span><span class=\\"token punctuation\\">&gt;</span></span><span class=\\"token punctuation\\">(</span>result<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n        <span class=\\"token keyword\\">return</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n    <span class=\\"token comment\\">// 2. 递归的拆解</span>\\n    <span class=\\"token comment\\">// 选 nums[index]</span>\\n    subset<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">add</span><span class=\\"token punctuation\\">(</span>nums<span class=\\"token punctuation\\">[</span>index<span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token function\\">dfs</span><span class=\\"token punctuation\\">(</span>nums<span class=\\"token punctuation\\">,</span> i <span class=\\"token operator\\">+</span> <span class=\\"token number\\">1</span><span class=\\"token punctuation\\">,</span> subset<span class=\\"token punctuation\\">,</span> result<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    subset<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">remove</span><span class=\\"token punctuation\\">(</span>subset<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">size</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">-</span> <span class=\\"token number\\">1</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token function\\">dfs</span><span class=\\"token punctuation\\">(</span>nums<span class=\\"token punctuation\\">,</span> i <span class=\\"token operator\\">+</span> <span class=\\"token number\\">1</span><span class=\\"token punctuation\\">,</span> subset<span class=\\"token punctuation\\">,</span> result<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}`);export{n as data};
