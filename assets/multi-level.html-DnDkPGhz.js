import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as t,o}from"./app-lHiwVl-u.js";const p={};function n(c,e){return o(),i("div",null,e[0]||(e[0]=[t('<h1 id="多级缓存" tabindex="-1"><a class="header-anchor" href="#多级缓存"><span>多级缓存</span></a></h1><ol><li>一级缓存：Caffeine是一个一个高性能的 Java 缓存库；使用 Window TinyLfu 回收策略，提供了一个近乎最佳的命中率。</li><li>二级缓存：Redis 是一高性能、高可用的 key-value 数据库，支持多种数据类型，支持集群，和应用服务器分开部署易于横向扩展。</li></ol><p>in-memory cache</p><p>日常开发中，基本上每个项目中都会使用到Redis、MongoDB等缓存中间件，它能够很好的作为分布式缓存组件提供多个服务间的缓存，但是还是需要网络开销，增加时耗。</p><p>除了分布式缓存，其实还有一种缓存 - 本地缓存：直接从本地内存中读取，没有网络开销，在某些场景比远程缓存更合适。Guava cache、ehcache、Caffeine是目前比较流行的本地缓存组件，但Caffeine号称是本地缓存绝对的王者。</p><p>Caffeine 是一个基于 Java8 开发的提供了近乎最佳命中率的高性能的缓存库。缓存和 ConcurrentMap 有点相似，但还是有所区别，最根本的区别是 ConcurrentMap 将会持有所有加入到缓存当中的元素，直到它们被从缓存当中手动移除。</p><p>Caffeine 的底层使用了 ConcurrentHashMap，支持按照一定的规则或者自定义的规则使缓存的数据过期，然后销毁。在 Spring5 (springboot 2.x) 后，Spring 官方放弃了 Guava，而使用了性能更优秀的 Caffeine 作为默认缓存组件。</p><p><img src="https://img-blog.csdnimg.cn/14b2973946d84c0c8ac1daaa277966d6.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-P5aSp6YO96KaB6L-b5q2l5LiA54K554K5,size_14,color_FFFFFF,t_70,g_se,x_16" alt="img" loading="lazy"></p><p>查询：Caffeine 作为一级缓存，Redis 作为二级缓存，对于指定的高热key，</p><ol><li>优先访问一级缓存，</li><li>没有再去访问二级缓存，</li><li>再没有去执行接口更新删除：通过redis订阅topic，通知所有节点去删除本地缓存和redis缓存</li></ol><p>优点：提高缓存速度，减少网络io 缺点：多节点下缓存的维护与同步成本增加，对于会更新的key，不可靠性加大（难以保证一致性）</p><hr><p><strong>具体的缓存时间可以根据自己业务数据的更新频率来确定 ，原则上：本地缓存的时长要比redis更短一些，因为redis中的数据我们通常会采用同步机制来更新， 而本地缓存因为在各台web服务内部，所以时间上不要太长！</strong></p><h2 id="实现" tabindex="-1"><a class="header-anchor" href="#实现"><span>实现</span></a></h2><blockquote><p><a href="https://juejin.cn/post/7264236820724482104" target="_blank" rel="noopener noreferrer">参考</a></p></blockquote><p>Spring 本来就提供了Cache的支持，最核心的就是实现Cache和CacheManager接口。但是Spring Cache存在以下问题：</p><ul><li><p>Spring Cache 仅支持单一的缓存来源，即：只能选择 Redis 实现或者 Caffeine 实现，并不能同时使用。</p><p>可以Spring Cache 本地缓存（注解自动），Spring Data Redis 二级缓存（手动）</p></li><li><p>数据一致性：各层缓存之间的数据一致性问题，如应用层缓存和分布式缓存之前的数据一致性问题。</p></li></ul><p>由此我们可以通过重新实现 Cache 和 CacheManager 接口，整合redis和caffeine，从而实现多级缓存。在讲实现原理之前先看看多级缓存调用逻辑图：</p><p>双写一致性：先更新二级缓存再删除一级缓存</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8206e5fa0e342ddafd8ae9d2cd2d83a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img" loading="lazy"></p>',20)]))}const s=a(p,[["render",n],["__file","multi-level.html.vue"]]),d=JSON.parse(`{"path":"/cs/database/redis/availability/multi-level.html","title":"多级缓存","lang":"en-US","frontmatter":{"description":"多级缓存 一级缓存：Caffeine是一个一个高性能的 Java 缓存库；使用 Window TinyLfu 回收策略，提供了一个近乎最佳的命中率。 二级缓存：Redis 是一高性能、高可用的 key-value 数据库，支持多种数据类型，支持集群，和应用服务器分开部署易于横向扩展。 in-memory cache 日常开发中，基本上每个项目中都会使用...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/cs/database/redis/availability/multi-level.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"多级缓存"}],["meta",{"property":"og:description","content":"多级缓存 一级缓存：Caffeine是一个一个高性能的 Java 缓存库；使用 Window TinyLfu 回收策略，提供了一个近乎最佳的命中率。 二级缓存：Redis 是一高性能、高可用的 key-value 数据库，支持多种数据类型，支持集群，和应用服务器分开部署易于横向扩展。 in-memory cache 日常开发中，基本上每个项目中都会使用..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://img-blog.csdnimg.cn/14b2973946d84c0c8ac1daaa277966d6.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-P5aSp6YO96KaB6L-b5q2l5LiA54K554K5,size_14,color_FFFFFF,t_70,g_se,x_16"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-22T03:06:21.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-22T03:06:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"多级缓存\\",\\"image\\":[\\"https://img-blog.csdnimg.cn/14b2973946d84c0c8ac1daaa277966d6.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-P5aSp6YO96KaB6L-b5q2l5LiA54K554K5,size_14,color_FFFFFF,t_70,g_se,x_16\\",\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8206e5fa0e342ddafd8ae9d2cd2d83a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp\\"],\\"dateModified\\":\\"2024-11-22T03:06:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"实现","slug":"实现","link":"#实现","children":[]}],"git":{"createdTime":1715153702000,"updatedTime":1732244781000,"contributors":[{"name":"David Liu","email":"liudawei@seas.upenn.edu","commits":1},{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":1}]},"readingTime":{"minutes":2.82,"words":845},"filePathRelative":"cs/database/redis/availability/multi-level.md","localizedDate":"May 8, 2024","excerpt":"\\n<ol>\\n<li>一级缓存：Caffeine是一个一个高性能的 Java 缓存库；使用 Window TinyLfu 回收策略，提供了一个近乎最佳的命中率。</li>\\n<li>二级缓存：Redis 是一高性能、高可用的 key-value 数据库，支持多种数据类型，支持集群，和应用服务器分开部署易于横向扩展。</li>\\n</ol>\\n<p>in-memory cache</p>\\n<p>日常开发中，基本上每个项目中都会使用到Redis、MongoDB等缓存中间件，它能够很好的作为分布式缓存组件提供多个服务间的缓存，但是还是需要网络开销，增加时耗。</p>\\n<p>除了分布式缓存，其实还有一种缓存 - 本地缓存：直接从本地内存中读取，没有网络开销，在某些场景比远程缓存更合适。Guava cache、ehcache、Caffeine是目前比较流行的本地缓存组件，但Caffeine号称是本地缓存绝对的王者。</p>","autoDesc":true}`);export{s as comp,d as data};
