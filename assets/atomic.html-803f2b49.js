const e=JSON.parse(`{"key":"v-bd3feee8","path":"/cs/database/redis/practice/problem/atomic.html","title":"原子性保证","lang":"en-US","frontmatter":{"description":"原子性保证 Redis 并不保证原子性。但是 Redis中有一些原子操作。 原子性：事务中的命令要不全部成功，要不全部失败并回滚）。 原子操作：原子操作是指在多线程或并发编程中，一个无法或不需要进一步分割的最小的操作单元。这种操作要么完全执行，要么完全不执行，且其执行过程中不会被其他线程或操作打断。原子操作是并发控制中用于防止竞态条件的重要概念。 原子操作本身的定义主要关注于其不可分割的性质，并不直接包括错误处理或回滚机制。 并不保证出错会回滚，eg. 硬件级原子操作：如处理器指令实现的原子操作，如果发生错误（例如内存访问错误），这类操作通常不会执行任何回滚操作。 软件级原子操作：在软件层面，原子操作通常通过锁或其他同步机制实现。如果这些操作在执行过程中遇到错误，它们不会自动回滚之前的操作，但是可以由程序员设计错误处理逻辑来决定如何响应错误。这可能包括释放获取的锁，记录错误信息，或者重试操作。","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/cs/database/redis/practice/problem/atomic.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"原子性保证"}],["meta",{"property":"og:description","content":"原子性保证 Redis 并不保证原子性。但是 Redis中有一些原子操作。 原子性：事务中的命令要不全部成功，要不全部失败并回滚）。 原子操作：原子操作是指在多线程或并发编程中，一个无法或不需要进一步分割的最小的操作单元。这种操作要么完全执行，要么完全不执行，且其执行过程中不会被其他线程或操作打断。原子操作是并发控制中用于防止竞态条件的重要概念。 原子操作本身的定义主要关注于其不可分割的性质，并不直接包括错误处理或回滚机制。 并不保证出错会回滚，eg. 硬件级原子操作：如处理器指令实现的原子操作，如果发生错误（例如内存访问错误），这类操作通常不会执行任何回滚操作。 软件级原子操作：在软件层面，原子操作通常通过锁或其他同步机制实现。如果这些操作在执行过程中遇到错误，它们不会自动回滚之前的操作，但是可以由程序员设计错误处理逻辑来决定如何响应错误。这可能包括释放获取的锁，记录错误信息，或者重试操作。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-01-08T03:06:14.000Z"}],["meta",{"property":"article:author","content":"David Liu"}],["meta",{"property":"article:modified_time","content":"2024-01-08T03:06:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"原子性保证\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-01-08T03:06:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"事务","slug":"事务","link":"#事务","children":[{"level":3,"title":"命令","slug":"命令","link":"#命令","children":[]},{"level":3,"title":"异常处理","slug":"异常处理","link":"#异常处理","children":[]}]},{"level":2,"title":"Lua","slug":"lua","link":"#lua","children":[]}],"git":{"createdTime":1680090419000,"updatedTime":1704683174000,"contributors":[{"name":"davidliuk","email":"l729641074@163.com","commits":2},{"name":"davidliu","email":"liudawei47@jd.com","commits":1},{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":1}]},"readingTime":{"minutes":3.94,"words":1182},"filePathRelative":"cs/database/redis/practice/problem/atomic.md","localizedDate":"March 29, 2023","excerpt":"<h1> 原子性保证</h1>\\n<p><strong>Redis 并不保证原子性</strong>。但是 Redis中有一些原子操作。</p>\\n<ul>\\n<li>\\n<p>原子性：事务中的命令要不全部成功，要不全部失败并回滚）。</p>\\n</li>\\n<li>\\n<p>原子操作：原子操作是指在多线程或并发编程中，一个无法或不需要进一步分割的最小的操作单元。这种操作要么完全执行，要么完全不执行，且其执行过程中<strong>不会被其他线程或操作打断</strong>。原子操作是并发控制中用于防止竞态条件的重要概念。</p>\\n<p>原子操作本身的定义主要关注于其不可分割的性质，并不直接包括错误处理或回滚机制。</p>\\n<p>并不保证出错会回滚，eg.</p>\\n<ul>\\n<li><strong>硬件级原子操作</strong>：如处理器指令实现的原子操作，如果发生错误（例如内存访问错误），这类操作通常不会执行任何回滚操作。</li>\\n<li><strong>软件级原子操作</strong>：在软件层面，原子操作通常通过锁或其他同步机制实现。如果这些操作在执行过程中遇到错误，它们不会自动回滚之前的操作，但是可以由程序员设计错误处理逻辑来决定如何响应错误。这可能包括释放获取的锁，记录错误信息，或者重试操作。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}`);export{e as data};
