import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as e,o as n}from"./app-UiaY2OnX.js";const t={};function o(a,l){return n(),i("div",null,l[0]||(l[0]=[e('<h1 id="复杂度理论" tabindex="-1"><a class="header-anchor" href="#复杂度理论"><span>复杂度理论</span></a></h1><p>四个复杂度</p><ol><li>时间复杂度 - 核心考察点</li><li>空间复杂度 - 次要考察点</li><li>编程复杂度 - 能看得懂</li><li>思维复杂度 - 能想得出</li></ol><p>双指针线性复杂度</p><p>但有的时候，很明显的小数据的情况下，可以略微损失一点时间复杂度来降低编程复杂度，提高可读性</p><h2 id="时间复杂度" tabindex="-1"><a class="header-anchor" href="#时间复杂度"><span>时间复杂度</span></a></h2><p>只考虑最高项，不考虑常数项和系数项</p><p>O(2<sup>N+N</sup>2) = O(2^N)</p><p>O(N<sup>3+1000N</sup>2) = O(N^3)</p><p>O(logN) = O(log(N^2)) = O(log4(N))</p><p>Omax(n, m) = O(n+m)</p><h3 id="p-问题-polynomial" tabindex="-1"><a class="header-anchor" href="#p-问题-polynomial"><span>P 问题 Polynomial</span></a></h3><p>（多项式问题）</p><ul><li>On，On2，On3</li><li>O1，On0.5, Om+n</li><li>Ologn，Onlogn</li></ul><h3 id="np-问题" tabindex="-1"><a class="header-anchor" href="#np-问题"><span>NP 问题</span></a></h3><ul><li>O2n，On^n, On!</li></ul><h2 id="分类" tabindex="-1"><a class="header-anchor" href="#分类"><span>分类</span></a></h2><p>O(IogN)二分法比较多<br> O(N0.5)分解质因数（极少）<br> O(N)双指针，单调栈，枚举法<br> O(NlogN)排序，O(N*logN的数据结构上的操作)<br> O(N2),O(N3),动态规划等<br> O(2n)组合类(combination)的搜索问题<br> O(N!)排列类(permutation)的搜索问题</p><p>根据时间复杂度来倒推算法</p><p>On 算法有</p><ol><li>双指针算法：最常见，频率远大于后面的所有算法的和</li><li>打擂台算法：找最大值（一开始赋值成负无穷，每次把最大的打下来）</li><li>单调栈算法：四五道题稍微多一些</li><li>单调队列算法</li></ol><p>双指针</p><ol><li><p>相向双指针</p><p>两根指针一头一尾，向中间靠拢直到相遇</p><ol><li><p>Reverse 型（题目不多）</p><p>翻转字符串</p><p>判断回文串</p></li><li><p>Two Sum 型（两位数题）</p><p>两数之和</p><ol><li>Hashmap: On, On</li><li>排序+双指针: Onlogn, O1</li></ol><p>三数之和</p></li><li><p>Partition 型（两位数题）</p><p>快速排序</p><p>颜色排序</p></li></ol></li><li><p>同向双指针</p><ol><li>滑动窗口类</li><li>快慢指针类</li></ol></li><li><p>背向双指针</p><p>非常少见，就几个题</p><p>最长回文串</p><p>k closest element</p></li></ol><p>如果while或if里面过长，则可以考虑可以拆出来一个函数来处理，过长的时候不容易读懂，然后可能出错</p><p>返回多个值，需要构建类</p><p>两数之和，有十种变形</p><p>follow up</p><ol><li><p>排好序的情况下，哪种更好</p><p>双指针</p></li><li><p>需要返回下标的时候，哪种更好</p><p>hashmap更好</p><p>否则双指针需要将数组转换成一个pair的数组进行排序，保存数值和原来的位置</p></li></ol>',28)]))}const m=p(t,[["render",o],["__file","4. 复杂度理论.html.vue"]]),c=JSON.parse(`{"path":"/algo/summary/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/4.%20%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA.html","title":"复杂度理论","lang":"en-US","frontmatter":{"description":"复杂度理论 四个复杂度 时间复杂度 - 核心考察点 空间复杂度 - 次要考察点 编程复杂度 - 能看得懂 思维复杂度 - 能想得出 双指针线性复杂度 但有的时候，很明显的小数据的情况下，可以略微损失一点时间复杂度来降低编程复杂度，提高可读性 时间复杂度 只考虑最高项，不考虑常数项和系数项 O(2N+N2) = O(2^N) O(N3+1000N2) =...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/summary/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/4.%20%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"复杂度理论"}],["meta",{"property":"og:description","content":"复杂度理论 四个复杂度 时间复杂度 - 核心考察点 空间复杂度 - 次要考察点 编程复杂度 - 能看得懂 思维复杂度 - 能想得出 双指针线性复杂度 但有的时候，很明显的小数据的情况下，可以略微损失一点时间复杂度来降低编程复杂度，提高可读性 时间复杂度 只考虑最高项，不考虑常数项和系数项 O(2N+N2) = O(2^N) O(N3+1000N2) =..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-22T03:05:37.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-22T03:05:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"复杂度理论\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-22T03:05:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"时间复杂度","slug":"时间复杂度","link":"#时间复杂度","children":[{"level":3,"title":"P 问题 Polynomial","slug":"p-问题-polynomial","link":"#p-问题-polynomial","children":[]},{"level":3,"title":"NP 问题","slug":"np-问题","link":"#np-问题","children":[]}]},{"level":2,"title":"分类","slug":"分类","link":"#分类","children":[]}],"git":{"createdTime":1732244737000,"updatedTime":1732244737000,"contributors":[{"name":"David Liu","email":"liudawei@seas.upenn.edu","commits":1}]},"readingTime":{"minutes":2,"words":599},"filePathRelative":"algo/summary/九章算法/4. 复杂度理论.md","localizedDate":"November 22, 2024","excerpt":"\\n<p>四个复杂度</p>\\n<ol>\\n<li>时间复杂度 - 核心考察点</li>\\n<li>空间复杂度 - 次要考察点</li>\\n<li>编程复杂度 - 能看得懂</li>\\n<li>思维复杂度 - 能想得出</li>\\n</ol>\\n<p>双指针线性复杂度</p>\\n<p>但有的时候，很明显的小数据的情况下，可以略微损失一点时间复杂度来降低编程复杂度，提高可读性</p>\\n<h2>时间复杂度</h2>\\n<p>只考虑最高项，不考虑常数项和系数项</p>\\n<p>O(2<sup>N+N</sup>2) = O(2^N)</p>\\n<p>O(N<sup>3+1000N</sup>2) = O(N^3)</p>\\n","autoDesc":true}`);export{m as comp,c as data};
