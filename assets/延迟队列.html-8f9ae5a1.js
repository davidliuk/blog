import{_ as l,V as t,W as r,X as e,Y as a,$ as n,Z as d,E as s}from"./framework-e5d7a6b2.js";const h={},c=e("h1",{id:"延迟队列",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#延迟队列","aria-hidden":"true"},"#"),a(" 延迟队列")],-1),o={href:"https://blog.csdn.net/m0_56079407/article/details/125858748",target:"_blank",rel:"noopener noreferrer"},_=d('<h3 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式" aria-hidden="true">#</a> 实现方式</h3><ul><li>基于死信：在队列里面，通过ttl</li><li>基于插件：在交换机里面</li></ul><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h3><ol><li>订单在十分钟之内未支付则自动取消</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒。</li><li>用户发起退款，如果三天内没有得到收处理则通知相关运营人员。</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li></ol><h3 id="轮训和定时任务的缺点" tabindex="-1"><a class="header-anchor" href="#轮训和定时任务的缺点" aria-hidden="true">#</a> 轮训和定时任务的缺点</h3><ul><li>数据量小：可以采用每秒轮训实现上述功能（数据量大时会导致轮训瞬间处理太多）</li><li>对时间要求不严格：那么可以每天凌晨跑定时任务来实现（例如生成一些日报）</li></ul><p>对于大数据量、时效性强的场景，需要用到延迟队列</p><p>延迟队列的优点</p><ul><li>延迟功能有保障（时间要求严格）</li><li>不会像轮训一样一瞬间处理太多</li></ul><h2 id="基于死信" tabindex="-1"><a class="header-anchor" href="#基于死信" aria-hidden="true">#</a> 基于死信</h2><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/928a035b6dca4d76976c0505627aed56.png" alt="基于死信队列"></p><p>缺点：</p><ul><li>注意：由于队列的先进先出特性，只有当过期的消息到了队列的顶端（队首），才会被真正的丢弃或者进入死信队列。</li><li><strong>如果遇到不同的任务类型需要不同的延时的话，需要为每一种不同延迟时间的消息建立单独的消息队列。</strong></li></ul><h2 id="基于插件" tabindex="-1"><a class="header-anchor" href="#基于插件" aria-hidden="true">#</a> 基于插件</h2><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/e75e296161794b6eb58eeeba5d4f3d34.png" alt="基于插件"></p>',15);function p(u,f){const i=s("ExternalLinkIcon");return t(),r("div",null,[c,e("p",null,[e("a",o,[a("https://blog.csdn.net/m0_56079407/article/details/125858748"),n(i)])]),_])}const b=l(h,[["render",p],["__file","延迟队列.html.vue"]]);export{b as default};
