import{_ as a,V as n,W as s,a0 as e}from"./framework-705b829b.js";const l={},p=e(`<h1 id="表级锁" tabindex="-1"><a class="header-anchor" href="#表级锁" aria-hidden="true">#</a> 表级锁</h1><p>每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB</p><h3 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h3><p>对于表级锁，主要分为以下三类：</p><ul><li>表锁</li><li>元数据锁（MDL）</li><li>意向锁</li><li>AUTO-INC 锁</li></ul><h3 id="表锁" tabindex="-1"><a class="header-anchor" href="#表锁" aria-hidden="true">#</a> 表锁</h3><p>对于表锁，分为两类：</p><ol><li><p>表共享读锁（read lock）</p><p>加锁以后可以自己读，但是不可以写（会拒绝执行）</p><p>不会阻塞其他客户端的读，会阻塞其他客户端的写</p></li><li><p>表独占写锁（write lock）</p><p>加锁以后自己可以读写</p><p>但是会阻塞别的客户端的读写</p></li></ol><p>使用方式</p><ol><li><p>加锁：</p><p><code>lock tables &lt;表名, ...&gt; read/write</code></p></li><li><p>释放锁：</p><ul><li><code>unlock tables</code></li><li>客户端断开连接</li></ul></li></ol><h3 id="元数据锁-mdl" tabindex="-1"><a class="header-anchor" href="#元数据锁-mdl" aria-hidden="true">#</a> 元数据锁（MDL）</h3><p>目的：避免执行DML和DDL语句的冲突问题。</p><p>不用手动加，加锁过程是系统自动控制，无需显示使用，在访问一张表的时候会自动加上。</p><ul><li>对一张表进行 CRUD 操作（DML）的时候，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作（DDL）的时候，加的是 <strong>MDL 写锁</strong>；</li></ul><p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p><p>这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p><p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p><h3 id="意向锁" tabindex="-1"><a class="header-anchor" href="#意向锁" aria-hidden="true">#</a> 意向锁</h3><p>目的：规避行锁和表锁之间在加锁时的冲突问题，避免表锁在加锁的时候逐行地去检查这张表行锁的情况。</p><p>不用手动加，是系统自动控制</p><ul><li><p>意向共享锁 IS</p><p>与表锁共享锁（read）兼容，与表锁排他锁互斥</p></li><li><p>意向排他锁 IX</p></li></ul><p>意向锁之间不互斥</p><ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li></ul><p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p><p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p><p>不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">//先在表上加上意向共享锁，然后对读取的记录加共享锁</span>
<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>

<span class="token comment">//先表上加上意向独占锁，然后对读取的记录加独占锁</span>
<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="auto-inc-锁" tabindex="-1"><a class="header-anchor" href="#auto-inc-锁" aria-hidden="true">#</a> AUTO-INC 锁</h3><p>目的：实现主键自增</p>`,31),i=[p];function t(o,c){return n(),s("div",null,i)}const d=a(l,[["render",t],["__file","2. 表级锁.html.vue"]]);export{d as default};
