const e=JSON.parse(`{"key":"v-5c8a8371","path":"/cs/algo/faq/%E4%BA%8C%E5%8F%89%E6%A0%91.html","title":"二叉树","lang":"en-US","frontmatter":{"description":"二叉树 引言： 力扣上很多树的题目都是可以用递归很快地解决的，而这一系列递归解法中蕴含了一种很强大的递归思维：对称性递归(symmetric recursion) 什么是对称性递归？就是对一个对称的数据结构（这里指二叉树）从整体的对称性思考，把大问题分解成子问题进行递归，即不是单独考虑一部分(比如树的左子树)，而是同时考虑对称的两部分(左右子树)，从而写出对称性的递归代码 题型分类： 可以用对称性递归解决的二叉树问题大多是判断性问题(bool 类型函数),这一类问题又可以分为以下两类： 不需要构造辅助函数。 这一类题目有两种情况： 第一种是单树问题，且不需要用到子树的某一部分(比如根节点左子树的右子树)，只要利用根节点左右子树的对称性即可进行递归。 第二种是双树问题，即本身题目要求比较两棵树，那么不需要构造新函数。 该类型题目如下： 相同的树 翻转二叉树 二叉树的最大深度 平衡二叉树 二叉树的直径 合并二叉树 另一个树的子树 单值二叉树 需要构造辅助函数。 这类题目通常只用根节点子树对称性无法完全解决问题，必须要用到子树的某一部分进行递归，即要调用辅助函数比较两个部分子树。形式上主函数参数列表只有一个根节点，辅助函数参数列表有两个节点。该类型题目如下： 对称二叉树 剑指 Offer 26. 树的子结构","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/cs/algo/faq/%E4%BA%8C%E5%8F%89%E6%A0%91.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"二叉树"}],["meta",{"property":"og:description","content":"二叉树 引言： 力扣上很多树的题目都是可以用递归很快地解决的，而这一系列递归解法中蕴含了一种很强大的递归思维：对称性递归(symmetric recursion) 什么是对称性递归？就是对一个对称的数据结构（这里指二叉树）从整体的对称性思考，把大问题分解成子问题进行递归，即不是单独考虑一部分(比如树的左子树)，而是同时考虑对称的两部分(左右子树)，从而写出对称性的递归代码 题型分类： 可以用对称性递归解决的二叉树问题大多是判断性问题(bool 类型函数),这一类问题又可以分为以下两类： 不需要构造辅助函数。 这一类题目有两种情况： 第一种是单树问题，且不需要用到子树的某一部分(比如根节点左子树的右子树)，只要利用根节点左右子树的对称性即可进行递归。 第二种是双树问题，即本身题目要求比较两棵树，那么不需要构造新函数。 该类型题目如下： 相同的树 翻转二叉树 二叉树的最大深度 平衡二叉树 二叉树的直径 合并二叉树 另一个树的子树 单值二叉树 需要构造辅助函数。 这类题目通常只用根节点子树对称性无法完全解决问题，必须要用到子树的某一部分进行递归，即要调用辅助函数比较两个部分子树。形式上主函数参数列表只有一个根节点，辅助函数参数列表有两个节点。该类型题目如下： 对称二叉树 剑指 Offer 26. 树的子结构"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-01-08T03:06:14.000Z"}],["meta",{"property":"article:author","content":"David Liu"}],["meta",{"property":"article:modified_time","content":"2024-01-08T03:06:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二叉树\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-01-08T03:06:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":3,"title":"题型分类：","slug":"题型分类","link":"#题型分类","children":[]},{"level":3,"title":"解题模板","slug":"解题模板","link":"#解题模板","children":[]},{"level":3,"title":"题目解读","slug":"题目解读","link":"#题目解读","children":[]}],"git":{"createdTime":1703688112000,"updatedTime":1704683174000,"contributors":[{"name":"davidliu","email":"liudawei47@jd.com","commits":2}]},"readingTime":{"minutes":7.11,"words":2133},"filePathRelative":"cs/algo/faq/二叉树.md","localizedDate":"December 27, 2023","excerpt":"<h1> 二叉树</h1>\\n<p>引言：</p>\\n<p>力扣上很多树的题目都是可以用递归很快地解决的，而这一系列递归解法中蕴含了一种很强大的递归思维：对称性递归(symmetric recursion)<br>\\n什么是对称性递归？就是对一个对称的数据结构（这里指二叉树）从整体的对称性思考，把大问题分解成子问题进行递归，即不是单独考虑一部分(比如树的左子树)，而是同时考虑对称的两部分(左右子树)，从而写出对称性的递归代码</p>\\n<h3> 题型分类：</h3>\\n<p>可以用对称性递归解决的二叉树问题大多是判断性问题(bool 类型函数),这一类问题又可以分为以下两类：</p>\\n<ol>\\n<li>\\n<p>不需要构造辅助函数。</p>\\n<p>这一类题目有两种情况：</p>\\n<ul>\\n<li>第一种是单树问题，且不需要用到子树的某一部分(比如根节点左子树的右子树)，只要利用根节点左右子树的对称性即可进行递归。</li>\\n<li>第二种是双树问题，即本身题目要求比较两棵树，那么不需要构造新函数。</li>\\n</ul>\\n<p>该类型题目如下：</p>\\n<ol start=\\"100\\">\\n<li>相同的树</li>\\n<li>翻转二叉树</li>\\n<li>二叉树的最大深度</li>\\n<li>平衡二叉树</li>\\n<li>二叉树的直径</li>\\n<li>合并二叉树</li>\\n<li>另一个树的子树</li>\\n<li>单值二叉树</li>\\n</ol>\\n</li>\\n<li>\\n<p>需要构造辅助函数。</p>\\n<p>这类题目通常只用根节点子树对称性无法完全解决问题，必须要用到子树的某一部分进行递归，即要调用辅助函数比较两个部分子树。形式上主函数参数列表只有一个根节点，辅助函数参数列表有两个节点。该类型题目如下：</p>\\n<ol start=\\"101\\">\\n<li>对称二叉树</li>\\n</ol>\\n<p>剑指 Offer 26. 树的子结构</p>\\n</li>\\n</ol>","autoDesc":true}`);export{e as data};
