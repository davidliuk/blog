const e=JSON.parse(`{"key":"v-4f81662d","path":"/se/lang/java/JUC/thread/%E7%BA%BF%E7%A8%8B.html","title":"线程","lang":"en-US","frontmatter":{"description":"线程 线程的概念 线程与进程的比较 线程与进程的比较如下： 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销； 对于，线程相比进程能减少开销，体现在： 线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们； 线程的终止时间比进程快，因为线程释放的资源相比进程少很多； 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的； 由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/se/lang/java/JUC/thread/%E7%BA%BF%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"线程"}],["meta",{"property":"og:description","content":"线程 线程的概念 线程与进程的比较 线程与进程的比较如下： 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销； 对于，线程相比进程能减少开销，体现在： 线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们； 线程的终止时间比进程快，因为线程释放的资源相比进程少很多； 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的； 由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-08-21T10:17:45.000Z"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2023-08-21T10:17:45.000Z"}],["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://davidliuk.github.io/blog/blog/zh/se/lang/java/JUC/thread/%E7%BA%BF%E7%A8%8B.html"}]]},"headers":[{"level":2,"title":"线程的概念","slug":"线程的概念","link":"#线程的概念","children":[{"level":3,"title":"线程与进程的比较","slug":"线程与进程的比较","link":"#线程与进程的比较","children":[]},{"level":3,"title":"线程上下文切换","slug":"线程上下文切换","link":"#线程上下文切换","children":[]}]},{"level":2,"title":"线程的创建","slug":"线程的创建","link":"#线程的创建","children":[{"level":3,"title":"继承 Thread 类创建线程类","slug":"继承-thread-类创建线程类","link":"#继承-thread-类创建线程类","children":[]},{"level":3,"title":"通过 Runnable 接口创建线程类","slug":"通过-runnable-接口创建线程类","link":"#通过-runnable-接口创建线程类","children":[]},{"level":3,"title":"通过 Callable 和 Future 创建线程","slug":"通过-callable-和-future-创建线程","link":"#通过-callable-和-future-创建线程","children":[]},{"level":3,"title":"实现 Runnable 和实现 Callable 接口的区别","slug":"实现-runnable-和实现-callable-接口的区别","link":"#实现-runnable-和实现-callable-接口的区别","children":[]},{"level":3,"title":"通过 Executor 框架","slug":"通过-executor-框架","link":"#通过-executor-框架","children":[]}]},{"level":2,"title":"并发编程","slug":"并发编程","link":"#并发编程","children":[{"level":3,"title":"使用多线程可能带来什么问题?","slug":"使用多线程可能带来什么问题","link":"#使用多线程可能带来什么问题","children":[]},{"level":3,"title":"如何理解线程安全和不安全？","slug":"如何理解线程安全和不安全","link":"#如何理解线程安全和不安全","children":[]}]}],"git":{"createdTime":1680090419000,"updatedTime":1692613065000,"contributors":[{"name":"davidliuk","email":"l729641074@163.com","commits":2},{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":2},{"name":"liudawei47","email":"liudawei47@jd.com","commits":1}]},"readingTime":{"minutes":7.91,"words":2372},"localizedDate":"March 29, 2023","filePathRelative":"se/lang/java/JUC/thread/线程.md","excerpt":"<h1> 线程</h1>\\n<h2> 线程的概念</h2>\\n<h3> 线程与进程的比较</h3>\\n<p>线程与进程的比较如下：</p>\\n<ul>\\n<li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；</li>\\n<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li>\\n<li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li>\\n<li>线程能减少并发执行的时间和空间开销；</li>\\n</ul>\\n<p>对于，线程相比进程能减少开销，体现在：</p>\\n<ul>\\n<li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li>\\n<li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li>\\n<li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li>\\n<li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li>\\n</ul>","autoDesc":true}`);export{e as data};
