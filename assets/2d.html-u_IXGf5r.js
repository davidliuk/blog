import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,a as o,o as c}from"./app-BXVo6w5b.js";const d={};function t(a,e){return c(),p("div",null,e[0]||(e[0]=[o('<h1 id="二维型" tabindex="-1"><a class="header-anchor" href="#二维型"><span>二维型</span></a></h1><p>Unique Paths</p><p>状态：<code>f[i][j]</code>表示到坐标i,j位置的方案数</p><p>转移：<code>f[i][j]=f[i-1][j]+f[i][j-1]</code></p><p>边界：<code>f[0][0]=1</code></p><hr><p>Unique Paths II</p><blockquote><p>有些各自有障碍物，不能通过</p></blockquote><p>状态：<code>f[i][j]</code>表示到坐标i,j位置的方案数</p><p>转移：<code>f[i][j]=f[i-1][j]+f[i][j-1], 0|g[i][j]==1</code></p><p>边界：<code>f[0][0]=1</code></p><hr><p>Minimum Path Sum</p><blockquote><p>(0,0)到(m-1,n-1)的最小花费</p></blockquote><p>状态：<code>f[i][j]</code>表示到坐标i,j位置的最小花费</p><p>转移：<code>f[i][j]=min{f[i-1][j], f[i][j-1]}+A[i][j]</code></p><p>边界：<code>f[0][j], f[i][0]</code></p><p>空间优化：如果只依赖于前面的k列，则可以滚动数组</p><hr><p>Triangle 数字三角形</p><p>状态：<code>f[i][j]</code>表示到坐标i,j位置的最小花费</p><p>转移：<code>f[i][j]=min{f[i-1][j],f[i][j-1]}+a[i][j]</code></p><p>边界：<code>f[0][0]=a[0][0]</code></p><p>答案：<code>min{f[n-1][j]}</code></p><hr><p>Maximal Square 全1正方形</p><blockquote><p>求一个01矩阵中，全为1的正方形个数</p></blockquote><p>状态：</p><ul><li><code>f[i][j]</code>表示到坐标i,j位置的方案数</li><li><code>left[i][j]</code>表示i,j往左连续的1最长多长</li><li><code>up[i][j]</code>表示i,j往上连续的1最长多长</li></ul><p>转移：</p><p><code>0|m[i][j]==0</code></p><ul><li><code>left[i][j]=left[i][j-1]+1</code></li><li><code>up[i][j]=up[i-1][j]+1</code></li><li><code>f[i][j]=min{up[i-1][j], left[i][j-1], f[i-1][j-1]}+1</code></li></ul><p>边界：</p><ul><li><code>d[i][0],left[i][0],up[i][0]=m[i][0]</code></li><li><code>d[0][j],left[0][j],up[0][j=m[0][j]</code></li></ul><p>答案：<code>sum{dp[i][j]}</code></p><p>滚动数组，滚i，开2大小，答案在计算dp数组的时候累计</p><hr><p>Maximal Square II</p><blockquote><p>找最大的对角线全1其他都0的正方形</p></blockquote><hr><p>Knight Shortest Paths II</p><blockquote><p>只能向右面的 4 个方向跳，求左上到右下最短路径</p></blockquote><p>状态：<code>f[i][j]</code>表示到坐标i,j位置的最小步数</p><p>转移：<code>min{f[i-][j-]}</code></p><p>边界：<code>f[i][j]=inf,f[0][0]=0</code></p><p>答案：<code>f[n-1][m-1]</code></p><h3 id="逆向" tabindex="-1"><a class="header-anchor" href="#逆向"><span>逆向</span></a></h3><p>矩阵的终点的状态已知，起点状态为止，求起点状态</p><p>174 地下城游戏</p><p>状态：<code>f[i][j]</code>表示从i,j到n-1,m-1的最小HP</p><p>转移：<code>f[i][j]=max{1,max{f[i+1][j],f[i][j+1]}-grid[i][j]}</code></p><p>边界：<code>f[n][i]=inf,f[n][m-1]=1</code></p><p>答案：<code>f[0][0]</code></p><hr><p>1444 Number of Ways of Cutting a Pizza</p><p>状态：<code>f[k][i][j]</code>表示切k刀从i,j到n-1,m-1的方案数</p><p>转移：<code>f[k][i][j]=sum{f[k-1][i][j2]}+sum{f[k-1][i2][j]}</code></p><p>边界：<code>f[0][i][j]=1,sufSum(i,j)&gt;0</code></p><p>答案：<code>f[k][0][0]</code></p><h2 id="子矩阵" tabindex="-1"><a class="header-anchor" href="#子矩阵"><span>子矩阵</span></a></h2><blockquote><p>从子串型延展的，依然 Kadane 算法</p></blockquote><p>3148 矩阵中的最大得分</p><p>状态：<code>f[i][j]</code>表示以坐标i,j结尾的最大分数</p><p>转移：<code>f[i][j]=grid[i][j]+Math.max(Math.max(0,f[i-1][j])-grid[i-1][j], Math.max(0,f[i][j-1])-grid[i][j-1])</code></p><p>答案：<code>max{f[i][j]}</code></p><p>统计全为 1 的正方形子矩阵</p><hr><p><a href="https://leetcode.cn/problems/max-submatrix-lcci/" target="_blank" rel="noopener noreferrer">面试题 17.24. 最大子矩阵</a></p><p>状态：</p><h2 id="限制" tabindex="-1"><a class="header-anchor" href="#限制"><span>限制</span></a></h2><h3 id="背包型" tabindex="-1"><a class="header-anchor" href="#背包型"><span>背包型</span></a></h3><p>lc1235 矩阵中和能被 K 整除的路径</p><p>状态：<code>f[i][j][k]</code>表示以坐标i,j结尾余数为k的路径数量</p><p>转移：<code>f[i][j][(k + grid[i][j]%k)]=(f[i-1][j][k]+f[i][j-1][k])%mod</code></p><p>答案：<code>f[m-1][n-1][0]</code></p><h3 id="从递归入手二维动态规划" tabindex="-1"><a class="header-anchor" href="#从递归入手二维动态规划"><span>从递归入手二维动态规划</span></a></h3><p>动态规划表的大小：每个可变参数的可能性数量相乘<br> 动态规划方法的时间复杂度：动态规划表的大小*每个格子的枚举代价</p><p>二维动态规划依然需要去整理动态规划表的格子之间的依赖关系<br> 找寻依赖关系，往往通过画图来建立空间感，使其更显而易见<br> 然后依然是从简单格子填写到复杂格子的过程，即严格位置依赖的动态规划（从底到顶）</p><p>二维动态规划的压缩空间技巧原理不难，会了之后千篇一律<br> 但是不同题目依赖关系不一样，需要很细心的画图来整理具体题目的依赖关系<br> 最后进行空间压缩的实现</p><p>俯改成动态规划的速归，统一特征：</p><p><strong>决定返回值</strong>的可变参数类型往往都比较简单，一般不会比1t类型更复杂。为什么？</p><blockquote><p>eg. 单词搜索这个题，决定返回值的，不仅是左边 i, j, idx 还有board哪里被访问过的一个seen二维数组（这个可以用状压，但是没必要）</p></blockquote><p>从这个角度，可以解释带路径的递归（可变参数类型复杂），不适合或者说没有必要改成动态规划<br> 题目2就是说明这一点的</p><p>不管几维动态规划<br> 经常从递归的定义出发，避免后续进行很多边界讨论<br> 这需要一定的经验来预知</p><p><strong>带路径的递归不适合改dp</strong></p>',85)]))}const r=i(d,[["render",t],["__file","2d.html.vue"]]),f=JSON.parse(`{"path":"/algo/summary/optimise/dynamic-programming/%E5%9D%90%E6%A0%87/2d.html","title":"二维型","lang":"en-US","frontmatter":{"description":"二维型 Unique Paths 状态：f[i][j]表示到坐标i,j位置的方案数 转移：f[i][j]=f[i-1][j]+f[i][j-1] 边界：f[0][0]=1 Unique Paths II 有些各自有障碍物，不能通过 状态：f[i][j]表示到坐标i,j位置的方案数 转移：f[i][j]=f[i-1][j]+f[i][j-1], 0|g[...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/summary/optimise/dynamic-programming/%E5%9D%90%E6%A0%87/2d.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"二维型"}],["meta",{"property":"og:description","content":"二维型 Unique Paths 状态：f[i][j]表示到坐标i,j位置的方案数 转移：f[i][j]=f[i-1][j]+f[i][j-1] 边界：f[0][0]=1 Unique Paths II 有些各自有障碍物，不能通过 状态：f[i][j]表示到坐标i,j位置的方案数 转移：f[i][j]=f[i-1][j]+f[i][j-1], 0|g[..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-01-01T21:36:31.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-01T21:36:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二维型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-01T21:36:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":3,"title":"逆向","slug":"逆向","link":"#逆向","children":[]},{"level":2,"title":"子矩阵","slug":"子矩阵","link":"#子矩阵","children":[]},{"level":2,"title":"限制","slug":"限制","link":"#限制","children":[{"level":3,"title":"背包型","slug":"背包型","link":"#背包型","children":[]},{"level":3,"title":"从递归入手二维动态规划","slug":"从递归入手二维动态规划","link":"#从递归入手二维动态规划","children":[]}]}],"git":{"createdTime":1733274761000,"updatedTime":1735767391000,"contributors":[{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro-3.local","commits":3}]},"readingTime":{"minutes":4.13,"words":1240},"filePathRelative":"algo/summary/optimise/dynamic-programming/坐标/2d.md","localizedDate":"December 4, 2024","excerpt":"\\n<p>Unique Paths</p>\\n<p>状态：<code>f[i][j]</code>表示到坐标i,j位置的方案数</p>\\n<p>转移：<code>f[i][j]=f[i-1][j]+f[i][j-1]</code></p>\\n<p>边界：<code>f[0][0]=1</code></p>\\n<hr>\\n<p>Unique Paths II</p>\\n<blockquote>\\n<p>有些各自有障碍物，不能通过</p>\\n</blockquote>\\n<p>状态：<code>f[i][j]</code>表示到坐标i,j位置的方案数</p>\\n<p>转移：<code>f[i][j]=f[i-1][j]+f[i][j-1], 0|g[i][j]==1</code></p>","autoDesc":true}`);export{r as comp,f as data};
