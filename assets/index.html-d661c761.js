import{_ as p,V as i,W as e,a0 as l}from"./framework-705b829b.js";const a={},F=l('<h1 id="搜索" tabindex="-1"><a class="header-anchor" href="#搜索" aria-hidden="true">#</a> 搜索</h1><p>搜索的分类：</p><ul><li>FOR循环</li><li>DFS深搜</li><li>BFS广搜</li></ul><h3 id="dfs对bfs优势" tabindex="-1"><a class="header-anchor" href="#dfs对bfs优势" aria-hidden="true">#</a> DFS对BFS优势</h3><ol><li><p>后序传值</p><p>DFS专属后序位置，可以让父收到子传的值</p></li><li><p>先序回溯</p><p>DFS优点，可以节省空间</p></li><li><p>宽树搜索</p><p>空间复杂度对比：</p><p>BFS：树的最大宽度</p><p>DFS：树的最大深度</p><p>宽树搜索，必须DFS</p></li></ol><p>也就是说在这两种特定场景下只能用DFS。那既然BFS这么弱，我们还要BFS有什么用呢？请问何种数据结构的搜索必须要BFS呢？BFS的搜索过程不像DFS，DFS的栈对使用者是不可见的，但BFS的队列却是可见的，请问这种可见性带来了什么样的好处，请谈谈你的想法？</p><h3 id="bfs对dfs优势" tabindex="-1"><a class="header-anchor" href="#bfs对dfs优势" aria-hidden="true">#</a> BFS对DFS优势</h3><ol><li><p>最短路径</p></li><li><p>拓扑排序</p></li><li><p>请问根据你所实现栈模拟代码，谈一下为什么编程语言要有递归这个功能，如果没有麻烦的点在哪里？</p><p>如果显示的实现递归，需要手动模拟栈来维护每个状态节点的信息，较为繁琐，编程语言实现的递归有利于简化操作。</p></li><li><p>为什么DFS是运行时栈，而BFS是等待队列呢？</p><p>DFS：运行时栈 → 入栈代表开始执行，出栈代表执行完毕 → 先序（入栈） + 后序（出栈）</p><p>BFS：等待队列 → 入队代表已经访问完毕，出队代表开始扩展邻接 → 先序</p></li><li><p>为什么DFS支持先序和后序、而BFS仅支持先序？</p><p>DFS的入栈顺序可以进行先序传值，DFS的出栈时候可以进行后序传值</p><p>BFS只有在出队的时候进行传值</p></li></ol>',8),S=[F];function d(s,r){return i(),e("div",null,S)}const n=p(a,[["render",d],["__file","index.html.vue"]]);export{n as default};
