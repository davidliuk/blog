import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as t,o as p}from"./app-UiaY2OnX.js";const m={};function e(l,s){return p(),n("div",null,s[0]||(s[0]=[t('<h1 id="区块链技术发展进展-以认证数据结构为例" tabindex="-1"><a class="header-anchor" href="#区块链技术发展进展-以认证数据结构为例"><span>区块链技术发展进展-以认证数据结构为例</span></a></h1><p><a href="https://www.wwsww.cn/jishu/2081.html" target="_blank" rel="noopener noreferrer">https://www.wwsww.cn/jishu/2081.html</a></p><h2 id="区块链技术发展概览" tabindex="-1"><a class="header-anchor" href="#区块链技术发展概览"><span>区块链技术发展概览</span></a></h2><blockquote><p>这部分主要参考这篇文章：</p><p><a href="https://www.ccvalue.cn/article/414856.html" target="_blank" rel="noopener noreferrer">清华区块链报告：深度剖析国内外区块链最新进展 | 附报告全文 - 碳链价值 (ccvalue.cn)</a></p><p>三页左右即可，只是一个概述</p></blockquote><p>区块链技术的发展，目前主要经历了1.0、2.0、3.0三次里程碑式的发展，</p><h3 id="技术发展" tabindex="-1"><a class="header-anchor" href="#技术发展"><span>技术发展</span></a></h3><h3 id="应用发展" tabindex="-1"><a class="header-anchor" href="#应用发展"><span>应用发展</span></a></h3><h2 id="认证数据结构发展" tabindex="-1"><a class="header-anchor" href="#认证数据结构发展"><span>认证数据结构发展</span></a></h2><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h3><blockquote><p>需要找几篇文献综述，主要参考如下：</p><ul><li><a href="https://dl.acm.org/doi/abs/10.1145/2578855.2535851" target="_blank" rel="noopener noreferrer">https://dl.acm.org/doi/abs/10.1145/2578855.2535851</a></li></ul></blockquote><p>高效验证的学术问题源于验证数据结构（ADS,authenticated data structure），即利用特定数据结构快速验证数据的完整性，实际上 MKT 也是其中的一种。为了适应<a href="http://www.infocomm-journal.com/txxb/article/2020/1000-436x/1000-436x-41-1-00134.shtml#" target="_blank" rel="noopener noreferrer">区块链</a>数据的动态性（dynamical）并保持良好性能，学术界展开了研究。Reyzin 等[[20](javascript:😉]基于 AVL 树形结构提出 AVL+，并通过平衡验证路径、缺省堆栈交易集等机制，简化轻量级节点的区块头验证过程。Zhang 等[[21](javascript:😉]提出 GEM2-tree 结构，并对其进行优化提出 GEM2כ-tree 结构，通过分解单树结构、动态调整节点计算速度、扩展数据索引等机制降低以太坊节点计算开销。</p><p>Authenticated data structures can be traced back to Merkle ²; the well-known Merkle hash tree can be viewed as providing an authenticated version of a bounded-length array. More recently, authenticated versions of data structures as diverse as sets ²¹, dictionaries ¹, range trees ¹, graphs ¹, skip lists ¹ have been developed.</p><h3 id="树形结构" tabindex="-1"><a class="header-anchor" href="#树形结构"><span>树形结构</span></a></h3><ul><li>Merkle Tree 等</li></ul><blockquote><p>列举几种已经他们的特点，一到两页 PPT</p></blockquote><h3 id="非树形结构" tabindex="-1"><a class="header-anchor" href="#非树形结构"><span>非树形结构</span></a></h3><ul><li><p>Skip List 等</p><blockquote><p><a href="https://ieeexplore.ieee.org/abstract/document/5280100" target="_blank" rel="noopener noreferrer">Skip List Based Authenticated Data Structure in DAS Paradigm | IEEE Conference Publication | IEEE Xplore</a></p></blockquote></li><li><p>RSA Accumulator</p></li></ul><blockquote><p>列举几种已经他们的特点，一到两页 PPT</p></blockquote><h2 id="efficient-set-accumulators" tabindex="-1"><a class="header-anchor" href="#efficient-set-accumulators"><span>Efficient Set Accumulators</span></a></h2><blockquote><p><a href="https://www.usenix.org/conference/usenixsecurity20/presentation/ozdemir" target="_blank" rel="noopener noreferrer">使用高效的集合累加器扩展可验证计算 |尤尼克斯 (usenix.org)</a></p><p>这个是本次分享的核心</p></blockquote><h3 id="原理概述" tabindex="-1"><a class="header-anchor" href="#原理概述"><span>原理概述</span></a></h3><h3 id="性能对比" tabindex="-1"><a class="header-anchor" href="#性能对比"><span>性能对比</span></a></h3><h3 id="代码实验" tabindex="-1"><a class="header-anchor" href="#代码实验"><span>代码实验</span></a></h3><p>RSA accumulators are authenticated sets built from cryptographic assumptions in hidden-order groups such as mathbb {Z}_N^*. They enable a prover, who stores the full set, to convince any verifier, who only stores a succinct digest of the set, of various set relations such as (non)membership, subset or disjointness¹.</p><p>In other words, RSA accumulators allow you to prove that a value is part of a set without revealing the entire set. They are similar to Merkle trees but can be more efficient for certain use cases⁵.</p><h2 id="分解" tabindex="-1"><a class="header-anchor" href="#分解"><span>分解</span></a></h2><p>数论中最先讨论的问题就是分解.给一个合数 𝑁N,分解问题就是找出正整数 𝑝p,𝑞q 使得 𝑁=𝑝𝑞N=pq.尽管这面临的似乎是一个简单的问题,但事实上它是很难的,值得深入研究的问题.我们可以在指数时间检查所有的 𝑝=2,...,𝑁‾‾√p=2,...,N.然而解决问题在指数时间不是足够快的.尽管有多年的研究,还没有多项式算法可以解决分解大数的问题.很显然对 𝑁N 的某个特定的值很容易解决.例如 𝑁N 是偶数.但是,我们讨论的密码学构造中,𝑁N 是一个非常大的数,同时被连个大素数构造 𝑝,𝑞p,q.</p><h2 id="rsa-accumulator" tabindex="-1"><a class="header-anchor" href="#rsa-accumulator"><span>RSA Accumulator</span></a></h2><h3 id="accumulator-是什么" tabindex="-1"><a class="header-anchor" href="#accumulator-是什么"><span>accumulator 是什么</span></a></h3><blockquote><p>A cryptographic accumulator is a one-way membership function. It answers a query as to whether a potential candidate is a member of a set without revealing the individual members of the set.</p></blockquote><p>在密码学中，Accumulator 指的是一个能够在不暴露所有集合元素的情况下，配合证明(proof)确保某个元素在一个群集之中的单向函数。</p><h3 id="merkle-tree-属于-accumulator-吗" tabindex="-1"><a class="header-anchor" href="#merkle-tree-属于-accumulator-吗"><span>Merkle tree 属于 Accumulator 吗？</span></a></h3><p>是，也不是。</p><p>因为在已知 merkle root 情况下，配合 merkle branch 的关键路径作为 proof，我们就能证明一个元素的存在。</p><p>在严谨的密码学定义中，会要求 proof 是固定大小，而 Merkle tree 不符合此一定义。</p><h3 id="那么如何保证-one-way-membership-function-呢" tabindex="-1"><a class="header-anchor" href="#那么如何保证-one-way-membership-function-呢"><span>那么如何保证 one-way membership function 呢？</span></a></h3><p>密码学严重依赖于这样的假设，某些数学问题难以在有限的时间内解决。让我们看公钥(非对称)密码学，刚刚我们使用的一个假设-单向函数(One-Way function)存在。例如，一个函数在一种情况下很容易计算，而在另一种情况下不容易计算。我们使用数论算法来产生这样的函数，最典型的就是我们下面将要说的这个 RSA 算法的思路。</p><h3 id="rsa-算法" tabindex="-1"><a class="header-anchor" href="#rsa-算法"><span>RSA 算法</span></a></h3><p>密钥生成：</p><p>（1）任意选取两个不同的大素数 p 和 q 计算乘积</p><p><img src="https://bkimg.cdn.bcebos.com/formula/f0dac18152076624d87832b62709895c.svg" alt="img" loading="lazy"></p><p>（2）任意选取一个大整数 e，满足</p><p><img src="https://bkimg.cdn.bcebos.com/formula/c33d8c66364a636b051d82f0ee202a36.svg" alt="img" loading="lazy"></p><p>，整数 e 用做加密钥（注意：e 的选取是很容易的，例如，所有大于 p 和 q 的素数都可用） [5] ；</p><p>（3）确定的解密钥 d，满足</p><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/da8649c0078a0a842779394d64011776.svg" alt="img" loading="lazy"></p><p>，即</p><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/4dee3f4df52a81983db0e3c619f96058.svg" alt="img" loading="lazy"></p><p>是一个任意的整数；所以，若知道 e 和</p><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/679e809a0d964785d0aa4cfcb4218742.svg" alt="img" loading="lazy"></p><p>，则很容易计算出 d [5] ；</p><p>（4）公开整数 n 和 e，秘密保存 d [5] ；</p><p>加解密算法：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>m</mi><mi>e</mi></msup><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">c=E(m)=m^e\\mod n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mi>D</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>c</mi><mi>d</mi></msup><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">m=D(c)=c^d\\mod n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span></li></ul><p>然而只根据 n 和 e（注意：不是 p 和 q）要计算出 d 是不可能的。因此，任何人都可对明文进行加密，但只有授权用户（知道 d）才可对密文解密。</p><p>RSA 公开密钥密码体制的原理是：根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p><h3 id="rsa-问题" tabindex="-1"><a class="header-anchor" href="#rsa-问题"><span>RSA 问题</span></a></h3><p>在 RSA 公钥加密中，Alice 使用 Bob 的公钥(n,e)加密明文 M 生成 C，计算方法为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><msup><mi>M</mi><mi>e</mi></msup><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">C=M^e \\mod n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span>,其中 n 是由两个大素数产生的,e≥3 并且是一个奇数且和 Zn∗ 互质,Zn。Bob 知道私钥(n,e)，其中</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mo>=</mo><mn>1</mn><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>ϕ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">de=1\\mod\\phi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(p−1)(q−1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>意味着 M=Cd(mod n)。攻击者能够窃听 C 同时知道公钥(n,e)。然而为了计算 M，攻击者必须找到 n 的分解。因此，这意味着 RSA 问题并不比整数因子分解困难，但是如果选择合适的 n，这仍然是一个很难解决的问题。</p><p>RSA 问题是在给定 RSA 公钥(n,e)和密文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>≡</mo><msup><mi>P</mi><mi>e</mi></msup><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">C≡P^e\\mod N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>的情况下有效地计算<em>P</em>。</p><p>RSA 公钥的结构要求 N 是一个大的半素数（即两个大素数的乘积），2 &lt; e &lt; N，<em>e</em> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\phi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>（欧拉函数，在数论，对正整数 n，欧拉函数是小于 n 的正整数中与 n 互质的数的数目）的互质数，0 ≤ <em>C</em> &lt; <em>N</em>。 <em>C</em> 在该范围内随机选择；要完全精确地指定问题，还必须指定<em>如何生成 N</em> 和 <em>e</em>，这将取决于所使用的 RSA 随机密钥对生成的精确方法。</p><p>The RSA Problem: Given an RSA public key (n,e) and a ciphertext C=Me (mod n),to compute M. 即攻击者不知道 RSA 私钥但是仍要反求 RSA 函数来得到明文。</p><h3 id="rsa-假设" tabindex="-1"><a class="header-anchor" href="#rsa-假设"><span>RSA 假设</span></a></h3><p>当 n 充分大且随机取的时候，认为 RSA 问题难以解决。</p><p>即认为 RSA 函数是一个单向陷门函数。</p><h3 id="为什么要充分大呢" tabindex="-1"><a class="header-anchor" href="#为什么要充分大呢"><span>为什么要充分大呢？</span></a></h3><p>明文取值空间要足够大且随机，否则攻击者可以通过遍历来进行攻击</p><p>一般来说，为提高保密强度，RSA 密钥至少为 500 位长。</p><p>RSA-2048具有617个十进制数字，共2048bits。是目前最大的RSA数字。</p><h3 id="强-rsa-假设" tabindex="-1"><a class="header-anchor" href="#强-rsa-假设"><span>强 RSA 假设</span></a></h3><p>在密码学中，<strong>强 RSA 假设</strong>指出，即使允许 solver 选择公共指数 e（对于 <em>e</em> ≥ 3），RSA 问题也是棘手的。也就是说，给定未知因式分解的模 N 和密文 C，找到任何使 <em>C</em> ≡ M <em>e</em> mod <em>N</em> 的对 (m, e)是不可行的。</p><p>该假设与 RSA 假设的不同之处在于对手可以选择公开指数 e。攻击者目标为在给出密文 C，模数 n 后计算任意一个满足 C=Me(modn) 的公开参数 e（奇数且 e&gt;3 ）和明文 M。这可能比解决 RSA 问题更容易，所以这个假设是比 RSA 假设更强的假设。强 RSA 假设是各种加密构造的基础。</p><p><a href="https://zhuanlan.zhihu.com/p/618253489" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/618253489</a></p><h3 id="rsa-accumulator-1" tabindex="-1"><a class="header-anchor" href="#rsa-accumulator-1"><span>RSA Accumulator</span></a></h3><p>它的基本数学非常简单，我们透过一个质数 g 作为基底，再配合一个选择好的 N = p * q ，其中 p,q 皆为秘密的大质数。</p><ol><li>利用上述 RSA 选择 N 的策略，生成两个大质数 p, q 得到 N</li><li>选择一个基地 g</li></ol><h3 id="n-value-setup" tabindex="-1"><a class="header-anchor" href="#n-value-setup"><span>N Value Setup</span></a></h3><p>首先必需介绍一下 N 的选择。 N 是由两个秘密质数相乘而来，若有人知道其组成，将可以破解 RSA Accumulator 的验证。因次对于 N 的选择，可以选择相信公开宣布已经销毁 p, q 的 N 值，或是 RSA2048 这种目前技术进行分解的大数。另一个可行的方法是透过所谓的 Class Group 来进行 N 的创造，但这方面牵扯很多复杂的数学，有兴趣的人可以自己参考这篇论文。</p><h3 id="initiation" tabindex="-1"><a class="header-anchor" href="#initiation"><span>Initiation</span></a></h3><p>当我们选好了基底 g 想要创建一个 Accumulator，</p><p>放入数字 a 的时候，就进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>a</mi></msup></mrow><annotation encoding="application/x-tex">g^a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span></span></span></span></span></span></span> 次方运算，得到 Accumulator A。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>=</mo><msup><mi>g</mi><mi>a</mi></msup><mspace></mspace><mspace width="1em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex"> A = g^a \\mod N </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9088em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span></p><p>若是要加入新的成员到 Accumulator 中，就继续执行次方运算。例如我们接着想要加入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">a_2, a_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么我们的 Accumulator 就会变为：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>=</mo><msup><mi>A</mi><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>2</mn></msub><mo>×</mo><msub><mi>a</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow></msup><mspace></mspace><mspace width="1em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>N</mi><mo>=</mo><msup><mi>g</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>×</mo><msub><mi>a</mi><mn>2</mn></msub><mo>×</mo><msub><mi>a</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow></msup><mspace></mspace><mspace width="1em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex"> A = A^{(a_2 \\times a_3 )} \\mod N= g^{(a\\times a_2\\times a_3)} \\mod N </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.938em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1324em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">a</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span></p><h3 id="membership-witness" tabindex="-1"><a class="header-anchor" href="#membership-witness"><span>Membership Witness</span></a></h3><p>若我们想要证明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 确实在这个 Accumulator 之中，我们需要提供的 witness w 就是 Accumulator 扣除了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的部分，验证则是试算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>w</mi><msub><mi>a</mi><mn>1</mn></msub></msup></mrow><annotation encoding="application/x-tex">w^ {a_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 是否等于 Accumulator 的值。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><msup><mi>g</mi><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>2</mn></msub><mo>×</mo><msub><mi>a</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow></msup><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">w = g^{(a_2 \\times a_3)} \\mod N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><br> verify<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>:</mo><mi>A</mi><mo>=</mo><msup><mi>w</mi><msub><mi>a</mi><mn>1</mn></msub></msup><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">: A = w^{a_1} \\mod N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>举一个直观的数字例子（先忽略 mod N）：</p><p>我们可以发现，不论现在 Accumulator 已经存放的多少东西，都可以透过在只知道 Accumulator 目前 root value 的情况下，以 O(1)的复杂度加入元素。这样的 Accumulator 称为 Dynamic Accumulator，广泛一点来说就是能够随意 Update 这个 Accumulator。</p><h3 id="aggregating-proofs" tabindex="-1"><a class="header-anchor" href="#aggregating-proofs"><span>Aggregating Proofs</span></a></h3><p>若我们想要证明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\\{a_1,a_2,a_3\\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>都在Accumulator中，我们可以把证据合并在一起提供一个witness w，就是去除了待证明的集合中的元素。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><msup><mi>g</mi><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>4</mn></msub><mo>×</mo><msub><mi>a</mi><mn>5</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">)</mo></mrow></msup><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">w = g^{(a_4 \\times a_5...)} \\mod N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight">...</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><br> verify<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>:</mo><mi>A</mi><mo>=</mo><msup><mi>w</mi><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>×</mo><msub><mi>a</mi><mn>2</mn></msub><mo>×</mo><msub><mi>a</mi><mn>3</mn></msub></mrow></msup><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">: A = w^{a_1\\times a_2\\times a_3} \\mod N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>除此之外，我们还可以把多个想要验证的值，合并在一起产生一个 witness。例如下图例子中，我们可以一次验证 5, 13 都在 Accumulator 中。</p><blockquote><p>这种能整合多个 witness 为一的特性称为累加性 (Aggregating)。而有效率的一次产生或验证多个 witness 则称为批次性 (Batching)。这两者都是 merkle tree 不具备的。</p></blockquote><h3 id="优化" tabindex="-1"><a class="header-anchor" href="#优化"><span>优化</span></a></h3><p>朴素地计算所有n个成员身份见证人需要O（n2）的幂𝔾，这不能很好地在大规模场景下计算。Sander等人给出了一种计算所有见证人的分治方法。</p><p>关键的观察结果是，一半的见证人需要计算gπi∈[1，n/2]ei，而另一半则需要计算g∏i∈[n/2+1，n]ei。如果做得很天真，这些计算会重复很多次，这是不必要的。但是可以以如下树状方式递归地计算见证人（在本例中n＝8）：</p><p>直觉：你可以把每个节点想象成（1）一组元素，（2）它的批成员身份见证器w.r.t.累加器a。然后，这个算法简单地把集合分成两半，并把见证分解成两半的见证器。这种情况一直重复，直到在底部获得单个元素的见证。</p><h3 id="non-membership-witness" tabindex="-1"><a class="header-anchor" href="#non-membership-witness"><span>Non-Membership Witness</span></a></h3><p>验证方法会需要用到裴蜀定理(Bézout&#39;s identity)：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">ax + by = m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span><br> (x, y)有整数解时若且唯若m是(a,b)的最大公因数d的倍数。</p><p>也就是说：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ax + by = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span><br> (x, y)有整数解时若且唯若(a,b)互质。</p><p>RSA Accumulator 除了能够的验证一个 element 在一个 Accumulator 中外，也能够进一步给出非成员证明(non-membership witness)，及证明一个数字不存在此 Accumulator 中。</p><p>用上面的例子来看，假如果要证明数字 7 不是 1105 因数，根据贝祖定理，我们只要找到一组满足 7a + 1105b = 1 的整数解即可（可以用 exgcd 算法去求解）。完整的过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/1*m6o0ArQob4h1zDMI2pcjKA.png" alt="img" loading="lazy"></p><p>例如，试证明7不存在于(3,5,11)中</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><msup><mi>g</mi><mn>165</mn></msup></mrow><annotation encoding="application/x-tex">A=g^{165}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">165</span></span></span></span></span></span></span></span></span></span></span></span></li><li>计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mi>a</mi><mo>+</mo><mn>165</mn><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">7a+165b=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">7</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">165</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的整数解（如利用拓展欧几里得算法），得到(-47, 2)</li><li>证据就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>g</mi><mi>a</mi></msup><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>g</mi><mrow><mo>−</mo><mn>47</mn></mrow></msup><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(g^a,b)=(g^{-47},2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">47</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></li><li>验证者只需要检查：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mrow><mi>a</mi><mi>x</mi></mrow></msup><msup><mi>A</mi><mi>b</mi></msup><mo>→</mo><msup><mi>g</mi><mrow><mo>−</mo><mn>47</mn><mo>×</mo><mn>7</mn></mrow></msup><mo>×</mo><msup><mi>g</mi><mrow><mn>165</mn><mo>×</mo><mn>2</mn></mrow></msup><mo>=</mo><msup><mi>g</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">g^{ax}A^b\\rightarrow g^{-47\\times7}\\times g^{165\\times 2}=g^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0435em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">47</span><span class="mbin mtight">×</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">165</span><span class="mbin mtight">×</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></li></ol><h3 id="batching-non-membership-witnesses" tabindex="-1"><a class="header-anchor" href="#batching-non-membership-witnesses"><span>Batching non-membership witnesses</span></a></h3><p>证明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\\{x_1,x_2,...,x_m\\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>不在集合中。</p><p>令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mo>∗</mo></msup><mo>=</mo><msub><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><msup><mn>1</mn><mi>m</mi></msup><msub><mi>x</mi><mi>i</mi></msub></mrow></msub></mrow><annotation encoding="application/x-tex">x^*=\\prod_{i=1^mx_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1498em;vertical-align:-0.3998em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight"><span class="mord mtight">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3998em;"><span></span></span></span></span></span></span></span></span></span>，证明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><msup><mi>s</mi><mo>∗</mo></msup><mo separator="true">,</mo><msup><mi>x</mi><mo>∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(s^*,x^*)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，并给出一组整数解作为证据</p><h3 id="proof-of-knowledge-schemes" tabindex="-1"><a class="header-anchor" href="#proof-of-knowledge-schemes"><span>Proof of Knowledge Schemes</span></a></h3><p>现在我们已经知道 RSA 如何进行验证，基本上就是次方的运算。但这在实践上有个困难点，因为若是结合了许多要验证的值的话，x 的大小会线性成长，因此我们不会直接提供 x ，而是需要再透过其他 proof of knowledge scheme 来间接完成。</p><p>我们可以把问题简化成：已知 u ^ x = w ，如何在不实际运算 u^x 的情况下验证这件事情。以下我们举一个简单例子：Proof of Exponentiation。</p><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/1-191216134432H0.jpg" alt="img" loading="lazy"></p><p>Proof of Exponentiation</p><p>透过这个 Scheme，最后 proof 大小上会因为 x/B 的步骤而限缩。而验证时，虽然需要 Verifier 自己算出 r = x mod B ，不过在 RSA 的使用情境中会比算次方快上许多。</p><p>在 Georgios Konstantopoulos 的 A Deep Dive on RSA Accumulator 这篇文章中更仔细的介绍了不同 Proof of Knowledge Scheme 如何配合 RSA Accumulator 进行 membership 以及 non-membership 的验证，就留给对数学更有兴趣的人自己看啦。</p><p>相比于Merkle Tree好处</p><ul><li>批量证明</li><li>Proof大小不随验证成员数增加。</li><li>不需知道所有State也能进行更新。</li></ul><h3 id="benchmark" tabindex="-1"><a class="header-anchor" href="#benchmark"><span>BenchMark</span></a></h3><p>与Merkle Tree性能对比：</p><h3 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献"><span>参考文献</span></a></h3><ul><li><strong>Batching Techniques for Accumulators with Applications to IOPs and Stateless Blockchains</strong>, by Dan Boneh and Benedikt Bünz and Ben Fisch, <em>in Cryptology ePrint Archive, Report 2018/1188</em>, 2018</li><li><strong>A Deep Dive on RSA Accumulator</strong></li><li><strong>Scaling Verifiable Computation Using Efficient Set Accumulators</strong></li><li>Authenticated Data Structures, Generically</li></ul><table><thead><tr><th>姓名</th><th>工作</th><th>贡献</th></tr></thead><tbody><tr><td>刘大维</td><td>文献收集、拟定大纲、RSA Accumulator、代码复现、性能对比、讲稿与展示</td><td></td></tr><tr><td>郑晨枫</td><td>认证数据结构概述、树形结构</td><td></td></tr><tr><td>张国庆</td><td>非树形结构</td><td></td></tr><tr><td>郭子恒</td><td>区块链技术发展与应用场景概述</td><td></td></tr></tbody></table>',126)]))}const c=a(m,[["render",e],["__file","大纲.html.vue"]]),h=JSON.parse(`{"path":"/education/bs/block-chain/final/%E5%A4%A7%E7%BA%B2.html","title":"区块链技术发展进展-以认证数据结构为例","lang":"en-US","frontmatter":{"description":"区块链技术发展进展-以认证数据结构为例 https://www.wwsww.cn/jishu/2081.html 区块链技术发展概览 这部分主要参考这篇文章： 清华区块链报告：深度剖析国内外区块链最新进展 | 附报告全文 - 碳链价值 (ccvalue.cn) 三页左右即可，只是一个概述 区块链技术的发展，目前主要经历了1.0、2.0、3.0三次里程碑...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/education/bs/block-chain/final/%E5%A4%A7%E7%BA%B2.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"区块链技术发展进展-以认证数据结构为例"}],["meta",{"property":"og:description","content":"区块链技术发展进展-以认证数据结构为例 https://www.wwsww.cn/jishu/2081.html 区块链技术发展概览 这部分主要参考这篇文章： 清华区块链报告：深度剖析国内外区块链最新进展 | 附报告全文 - 碳链价值 (ccvalue.cn) 三页左右即可，只是一个概述 区块链技术的发展，目前主要经历了1.0、2.0、3.0三次里程碑..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://bkimg.cdn.bcebos.com/formula/f0dac18152076624d87832b62709895c.svg"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-22T02:28:03.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-22T02:28:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"区块链技术发展进展-以认证数据结构为例\\",\\"image\\":[\\"https://bkimg.cdn.bcebos.com/formula/f0dac18152076624d87832b62709895c.svg\\",\\"https://bkimg.cdn.bcebos.com/formula/c33d8c66364a636b051d82f0ee202a36.svg\\",\\"https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/da8649c0078a0a842779394d64011776.svg\\",\\"https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/4dee3f4df52a81983db0e3c619f96058.svg\\",\\"https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/679e809a0d964785d0aa4cfcb4218742.svg\\",\\"https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/1*m6o0ArQob4h1zDMI2pcjKA.png\\",\\"https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/1-191216134432H0.jpg\\"],\\"dateModified\\":\\"2024-11-22T02:28:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"区块链技术发展概览","slug":"区块链技术发展概览","link":"#区块链技术发展概览","children":[{"level":3,"title":"技术发展","slug":"技术发展","link":"#技术发展","children":[]},{"level":3,"title":"应用发展","slug":"应用发展","link":"#应用发展","children":[]}]},{"level":2,"title":"认证数据结构发展","slug":"认证数据结构发展","link":"#认证数据结构发展","children":[{"level":3,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":3,"title":"树形结构","slug":"树形结构","link":"#树形结构","children":[]},{"level":3,"title":"非树形结构","slug":"非树形结构","link":"#非树形结构","children":[]}]},{"level":2,"title":"Efficient Set Accumulators","slug":"efficient-set-accumulators","link":"#efficient-set-accumulators","children":[{"level":3,"title":"原理概述","slug":"原理概述","link":"#原理概述","children":[]},{"level":3,"title":"性能对比","slug":"性能对比","link":"#性能对比","children":[]},{"level":3,"title":"代码实验","slug":"代码实验","link":"#代码实验","children":[]}]},{"level":2,"title":"分解","slug":"分解","link":"#分解","children":[]},{"level":2,"title":"RSA Accumulator","slug":"rsa-accumulator","link":"#rsa-accumulator","children":[{"level":3,"title":"accumulator 是什么","slug":"accumulator-是什么","link":"#accumulator-是什么","children":[]},{"level":3,"title":"Merkle tree 属于 Accumulator 吗？","slug":"merkle-tree-属于-accumulator-吗","link":"#merkle-tree-属于-accumulator-吗","children":[]},{"level":3,"title":"那么如何保证 one-way membership function 呢？","slug":"那么如何保证-one-way-membership-function-呢","link":"#那么如何保证-one-way-membership-function-呢","children":[]},{"level":3,"title":"RSA 算法","slug":"rsa-算法","link":"#rsa-算法","children":[]},{"level":3,"title":"RSA 问题","slug":"rsa-问题","link":"#rsa-问题","children":[]},{"level":3,"title":"RSA 假设","slug":"rsa-假设","link":"#rsa-假设","children":[]},{"level":3,"title":"为什么要充分大呢？","slug":"为什么要充分大呢","link":"#为什么要充分大呢","children":[]},{"level":3,"title":"强 RSA 假设","slug":"强-rsa-假设","link":"#强-rsa-假设","children":[]},{"level":3,"title":"RSA Accumulator","slug":"rsa-accumulator-1","link":"#rsa-accumulator-1","children":[]},{"level":3,"title":"N Value Setup","slug":"n-value-setup","link":"#n-value-setup","children":[]},{"level":3,"title":"Initiation","slug":"initiation","link":"#initiation","children":[]},{"level":3,"title":"Membership Witness","slug":"membership-witness","link":"#membership-witness","children":[]},{"level":3,"title":"Aggregating Proofs","slug":"aggregating-proofs","link":"#aggregating-proofs","children":[]},{"level":3,"title":"优化","slug":"优化","link":"#优化","children":[]},{"level":3,"title":"Non-Membership Witness","slug":"non-membership-witness","link":"#non-membership-witness","children":[]},{"level":3,"title":"Batching non-membership witnesses","slug":"batching-non-membership-witnesses","link":"#batching-non-membership-witnesses","children":[]},{"level":3,"title":"Proof of Knowledge Schemes","slug":"proof-of-knowledge-schemes","link":"#proof-of-knowledge-schemes","children":[]},{"level":3,"title":"BenchMark","slug":"benchmark","link":"#benchmark","children":[]},{"level":3,"title":"参考文献","slug":"参考文献","link":"#参考文献","children":[]}]}],"git":{"createdTime":1681208623000,"updatedTime":1732242483000,"contributors":[{"name":"David Liu","email":"liudawei@seas.upenn.edu","commits":1}]},"readingTime":{"minutes":12.18,"words":3654},"filePathRelative":"education/bs/block-chain/final/大纲.md","localizedDate":"April 11, 2023","excerpt":"\\n<p><a href=\\"https://www.wwsww.cn/jishu/2081.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://www.wwsww.cn/jishu/2081.html</a></p>\\n<h2>区块链技术发展概览</h2>\\n<blockquote>\\n<p>这部分主要参考这篇文章：</p>\\n<p><a href=\\"https://www.ccvalue.cn/article/414856.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">清华区块链报告：深度剖析国内外区块链最新进展 | 附报告全文 - 碳链价值 (ccvalue.cn)</a></p>\\n<p>三页左右即可，只是一个概述</p>\\n</blockquote>","autoDesc":true}`);export{c as comp,h as data};
