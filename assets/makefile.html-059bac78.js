import{_ as e,V as a,W as i,Z as l}from"./framework-e5d7a6b2.js";const r={},s=l(`<h1 id="makefile" tabindex="-1"><a class="header-anchor" href="#makefile" aria-hidden="true">#</a> Makefile</h1><h2 id="makefile的规则" tabindex="-1"><a class="header-anchor" href="#makefile的规则" aria-hidden="true">#</a> makefile的规则</h2><p>在讲述这个makefile之前，还是让我们先来粗略地看一看makefile的规则。</p><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code><span class="token target symbol">target ...</span> <span class="token punctuation">:</span> prerequisites ...
    recipe
    ...
    ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>target：可以是一个object file（目标文件），也可以是一个可执行文件，还可以是一个标签（label）/伪目标。</p><p>prerequisites：生成该target所依赖的文件和/或target。</p><p>recipe：该target要执行的命令（任意的shell命令）。</p><p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说:</p><p>prerequisites中如果有一个以上的文件比target文件要新的话，recipe所定义的命令就会被执行。 这就是makefile的规则，也就是makefile中最核心的内容。</p><p>说到底，makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是makefile 的主线和核心，但要写好一个makefile还不够，我会在后面一点一点地结合我的工作经验给你慢慢道来。内容还多着呢。</p><h2 id="makefile的命令" tabindex="-1"><a class="header-anchor" href="#makefile的命令" aria-hidden="true">#</a> makefile的命令</h2><p>makefile中的命令，也就是我们前面讲过的“recipe”部分，其实就是一些Shell命令，makefile会一行一行地执行这些命令。因为命令过多，所以make提供了一个续行符（\\）,来让我们的命令可以分行书写，make会将其连接起来，当作一个完整的命令。例如：</p><h2 id="makefile条件判断" tabindex="-1"><a class="header-anchor" href="#makefile条件判断" aria-hidden="true">#</a> makefile条件判断</h2><p>makefile中的条件判断主要有三种方式，分别是：</p><ol><li>条件表达式</li><li>makefile中的函数</li><li>makefile中的运算符</li></ol>`,15),t=[s];function n(d,m){return a(),i("div",null,t)}const f=e(r,[["render",n],["__file","makefile.html.vue"]]);export{f as default};
