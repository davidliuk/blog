const e=JSON.parse(`{"key":"v-4a7c9956","path":"/employment/resume/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE%E6%8F%90%E9%97%AE%E5%87%86%E5%A4%87.html","title":"","lang":"en-US","frontmatter":{"description":"雁过留痕 小组如何分工合作的？ Redis Zset 结构/原理？ skiplist 跳表结构（一段八股） 跳表（Skip List）是一种有序数据结构，它通过在链表中添加多级索引来提高查找效率。跳表的原理如下： 基本结构：跳表由多个层级组成，每个层级都是一个有序的链表。最底层是原始链表，每个节点包含一个元素和指向下一个节点的指针。每个层级的链表都是原始链表的子集。 索引层级：除了原始链表外，跳表还包含多个索引层级。每个索引层级都是原始链表的一个子集，其中的节点包含指向下一个层级的指针。每个节点的指针可以跳过多个节点，从而实现快速的查找。 查找操作：跳表的查找操作从最顶层的索引层级开始，逐层向下查找。在每个层级中，从当前节点开始，比较目标元素与当前节点的值。如果目标元素小于当前节点的值，则向下一层级继续查找；如果目标元素大于等于当前节点的值，则继续在当前层级中向右查找。直到找到目标元素或者无法继续向下查找为止。 插入操作：插入操作首先进行查找，找到插入位置后，将新节点插入到对应的层级中，并更新相应的指针。为了保持跳表的平衡性，插入操作时会随机决定是否在更高层级添加索引节点。 删除操作：删除操作首先进行查找，找到目标节点后，将其从每个层级的链表中移除，并更新相应的指针。","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/employment/resume/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE%E6%8F%90%E9%97%AE%E5%87%86%E5%A4%87.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:description","content":"雁过留痕 小组如何分工合作的？ Redis Zset 结构/原理？ skiplist 跳表结构（一段八股） 跳表（Skip List）是一种有序数据结构，它通过在链表中添加多级索引来提高查找效率。跳表的原理如下： 基本结构：跳表由多个层级组成，每个层级都是一个有序的链表。最底层是原始链表，每个节点包含一个元素和指向下一个节点的指针。每个层级的链表都是原始链表的子集。 索引层级：除了原始链表外，跳表还包含多个索引层级。每个索引层级都是原始链表的一个子集，其中的节点包含指向下一个层级的指针。每个节点的指针可以跳过多个节点，从而实现快速的查找。 查找操作：跳表的查找操作从最顶层的索引层级开始，逐层向下查找。在每个层级中，从当前节点开始，比较目标元素与当前节点的值。如果目标元素小于当前节点的值，则向下一层级继续查找；如果目标元素大于等于当前节点的值，则继续在当前层级中向右查找。直到找到目标元素或者无法继续向下查找为止。 插入操作：插入操作首先进行查找，找到插入位置后，将新节点插入到对应的层级中，并更新相应的指针。为了保持跳表的平衡性，插入操作时会随机决定是否在更高层级添加索引节点。 删除操作：删除操作首先进行查找，找到目标节点后，将其从每个层级的链表中移除，并更新相应的指针。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-08-10T06:29:52.000Z"}],["meta",{"property":"article:author","content":"David Liu"}],["meta",{"property":"article:modified_time","content":"2023-08-10T06:29:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-08-10T06:29:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"雁过留痕","slug":"雁过留痕","link":"#雁过留痕","children":[{"level":3,"title":"小组如何分工合作的？","slug":"小组如何分工合作的","link":"#小组如何分工合作的","children":[]},{"level":3,"title":"Redis Zset 结构/原理？","slug":"redis-zset-结构-原理","link":"#redis-zset-结构-原理","children":[]},{"level":3,"title":"为什么用 Zset","slug":"为什么用-zset","link":"#为什么用-zset","children":[]},{"level":3,"title":"Zset 怎么用的","slug":"zset-怎么用的","link":"#zset-怎么用的","children":[]},{"level":3,"title":"BitMap 原理","slug":"bitmap-原理","link":"#bitmap-原理","children":[]},{"level":3,"title":"为什么用 BitMap","slug":"为什么用-bitmap","link":"#为什么用-bitmap","children":[]},{"level":3,"title":"BitMap 怎么用的","slug":"bitmap-怎么用的","link":"#bitmap-怎么用的","children":[]},{"level":3,"title":"如何预生成订单ID的","slug":"如何预生成订单id的","link":"#如何预生成订单id的","children":[]},{"level":3,"title":"为什么用 RabbitMQ","slug":"为什么用-rabbitmq","link":"#为什么用-rabbitmq","children":[]},{"level":3,"title":"RabbitMQ 组件有哪些","slug":"rabbitmq-组件有哪些","link":"#rabbitmq-组件有哪些","children":[]},{"level":3,"title":"RabbitMQ 怎么用的","slug":"rabbitmq-怎么用的","link":"#rabbitmq-怎么用的","children":[]}]},{"level":2,"title":"仿掘金官网","slug":"仿掘金官网","link":"#仿掘金官网","children":[{"level":3,"title":"常用推荐算法有哪些","slug":"常用推荐算法有哪些","link":"#常用推荐算法有哪些","children":[]},{"level":3,"title":"TrustSVD 原理和优点","slug":"trustsvd-原理和优点","link":"#trustsvd-原理和优点","children":[]},{"level":3,"title":"常用加密算法有哪些","slug":"常用加密算法有哪些","link":"#常用加密算法有哪些","children":[]},{"level":3,"title":"为什么要用MD5+随机盐","slug":"为什么要用md5-随机盐","link":"#为什么要用md5-随机盐","children":[]}]}],"git":{"createdTime":1691648992000,"updatedTime":1691648992000,"contributors":[{"name":"davidliu","email":"liudawei47@jd.com","commits":1}]},"readingTime":{"minutes":11.32,"words":3396},"filePathRelative":"employment/resume/项目/项目提问准备.md","localizedDate":"August 10, 2023","excerpt":"<h2> 雁过留痕</h2>\\n<h3> 小组如何分工合作的？</h3>\\n<h3> Redis Zset 结构/原理？</h3>\\n<p>skiplist 跳表结构（一段八股）</p>\\n<p>跳表（Skip List）是一种有序数据结构，它通过在链表中添加多级索引来提高查找效率。跳表的原理如下：</p>\\n<ol>\\n<li>\\n<p>基本结构：跳表由多个层级组成，每个层级都是一个有序的链表。最底层是原始链表，每个节点包含一个元素和指向下一个节点的指针。每个层级的链表都是原始链表的子集。</p>\\n</li>\\n<li>\\n<p>索引层级：除了原始链表外，跳表还包含多个索引层级。每个索引层级都是原始链表的一个子集，其中的节点包含指向下一个层级的指针。每个节点的指针可以跳过多个节点，从而实现快速的查找。</p>\\n</li>\\n<li>\\n<p>查找操作：跳表的查找操作从最顶层的索引层级开始，逐层向下查找。在每个层级中，从当前节点开始，比较目标元素与当前节点的值。如果目标元素小于当前节点的值，则向下一层级继续查找；如果目标元素大于等于当前节点的值，则继续在当前层级中向右查找。直到找到目标元素或者无法继续向下查找为止。</p>\\n</li>\\n<li>\\n<p>插入操作：插入操作首先进行查找，找到插入位置后，将新节点插入到对应的层级中，并更新相应的指针。为了保持跳表的平衡性，插入操作时会随机决定是否在更高层级添加索引节点。</p>\\n</li>\\n<li>\\n<p>删除操作：删除操作首先进行查找，找到目标节点后，将其从每个层级的链表中移除，并更新相应的指针。</p>\\n</li>\\n</ol>","autoDesc":true}`);export{e as data};
