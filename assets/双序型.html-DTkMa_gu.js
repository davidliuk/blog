import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,d as o,o as t}from"./app-ChU1gMRF.js";const c={};function d(a,e){return t(),p("div",null,e[0]||(e[0]=[o('<h1 id="双序型" tabindex="-1"><a class="header-anchor" href="#双序型"><span>双序型</span></a></h1><p>有两个序列/字符串，需要进行一些操作<br> 每个序列本身是一维的，可以转化为二维动态规划</p><p>常见是匹配型，也有双区间的</p><p>两个字符串的匹配值依赖于两个字符串前缀的匹配值<br> 字符串长度为 n,m 则需要开(n+1)x(m+1)的状态数组<br> 要初始化<code>dp[i][0]</code>与<code>dp[0][i]</code><br> 通常都可以用滚动数组进行空间优化</p><p>也可以用滚动数组优化</p><hr><p>两个一维序列/字符串</p><p>突破口</p><ul><li>串A和串B的最后一个字符是否匹配</li><li>是否需要串A/串B的最后一个字符</li><li>缩减问题规模</li></ul><p>状态：<code>f[i][j]</code>数组下标表示序列A前i个，序列B前j个</p><p>初始条件和边界情况</p><ul><li>空串如何处理</li><li>计数型（情况1+情况2+.…）以及最值型(min/max情况1，情况2，.…}》</li></ul><p>匹配的情况下勿忘+1（操作数多1次，匹配长度多1）</p><hr><p>Longest Common Subsequence LCS</p><p>状态：<code>f[i][j]</code>表示A前i个字符A[0,i-1]和B前j个字符[0,j-1]的最长公共子串的长度</p><p>转移：<code>f[i][j]=max{f[i-1][j], f[i][j-1], f[i-1][j-1]+1|A[i-1]==B[j-1]}</code></p><p>边界：<code>f[0][j]=0, f[i][0]=0</code></p><p>优化：可以滚动数组优化到On</p><hr><p>Interleaving String 交错字符串</p><blockquote><p>给定三个字符串A, B, X</p><p>判断X是否是由A, B交错在一起形成</p><p>即A是X的子序列，去掉A后，剩下的字符组成B</p></blockquote><p>状态：<code>f[i][j]</code>表示为X的前i+j个字符是否由A前i个字符和B前j个字符交错形成</p><p>转移：<code>f[i][j]=(f[i-1][j]&amp;&amp;x[i+j-1]==A[i-1])||(f[i][j-1]&amp;&amp;x[i+j-1]==B[j-1])</code></p><p>边界：<code>f[0][0]=true</code></p><p>优化：可以滚动数组优化到On</p><hr><p>Edit Distance</p><p>状态：<code>f[i][j]</code>表示A前i个字符A[0,i-1]和B前j个字符[0,j-1]的Edit Distance</p><p>转移：<code>f[i][j]=min{f[i-1][j]+1, f[i][j-1]+1, f[i-1][j-1]+1, f[i-1][j-1]|A[i-1]==B[j-1]}</code></p><p>边界：<code>f[0][j]=0, f[i][0]=0</code></p><hr><p>Distinct Subsequences 不同子序列</p><p>状态：<code>f[i][j]</code>表示A前i个字符A[0,i-1]含有B前j个字符[0,j-1]的不同子序列</p><p>转移：<code>f[i][j]=f[i-1][j]+f[i-1][j-1]|a[i-1]==b[j-1]</code></p><p>边界：<code>f[i][0]=1</code></p><p>答案：<code>f[0][j]=0, f[i][0]=1</code></p><hr><p>Regular Expression Matching 正则表达式匹配</p><p>状态：<code>f[i][j]</code>表示A前i个字符A[0..i-1]和B前j个字符B[0..j-1]能否匹配</p><p>转移：<code>f[i][j]=f[i-1][j-1]&amp;&amp;match(a[i-1],b[j-1]), f[i][j-2]||f[i-1][j]&amp;&amp;match(a[i-1],b[j-2])</code></p><hr><p>Wildcard Matching 通配符匹配</p><p>状态：<code>f[i][j]</code>表示A前i个字符A[0..i-1]和B前j个字符B[0..j-1]能否匹配</p><p>转移：<code>f[i][j]=f[i-1][j-1]&amp;&amp;match(a[i-1],b[j-1]), f[i][j-2]||f[i-1][j]&amp;&amp;match(a[i-1],b[j-2])</code></p><hr><p>最小的窗口子序列(字节)</p><blockquote><p>给定字符串S和T，在字符串S中找到最短子串W，使得T是W的子序列。如果 S 没有包含 T 中的某个字符，则返回空字符串。如果有多个这样的最小长度子串，则 返回一个起点编号最小的。</p></blockquote><p>状态：<code>f[i][j]</code>表示匹配 T串的前j个字符到S中前i个字符的子序列时的匹配起点</p><p>转移：<code>f[i][j]=f[i-1][j-1]|s[i]==t[j],f[i-1][j]|s[i]!=t[j]</code></p><p>边界：<code>f[i][1]=i|s[i]==t[1],f[i][0]=-1</code></p><p>答案：<code>min_i{i-dp[i][m]+1|dp[i][m]!=-1]}</code></p><p>窗口长度为<code>i-f[i][m]+1</code></p><p>dp结束后遍历 dp[][T.length()]，若 <code>dp[i][T.length()] != 0</code>， 则此处存在窗口起点 dp[i][T.length()]，窗口长度为 i – dp[i][T.length()] + 1 此时维护最小窗口长度 len 和窗口起点 start ， 答案为:<code>S.substring(start, start + len)</code></p><hr>',55)]))}const m=i(c,[["render",d],["__file","双序型.html.vue"]]),l=JSON.parse(`{"path":"/algo/summary/optimise/dynamic-programming/%E5%BA%8F%E5%88%97/%E5%8F%8C%E5%BA%8F%E5%9E%8B.html","title":"双序型","lang":"en-US","frontmatter":{"description":"双序型 有两个序列/字符串，需要进行一些操作 每个序列本身是一维的，可以转化为二维动态规划 常见是匹配型，也有双区间的 两个字符串的匹配值依赖于两个字符串前缀的匹配值 字符串长度为 n,m 则需要开(n+1)x(m+1)的状态数组 要初始化dp[i][0]与dp[0][i] 通常都可以用滚动数组进行空间优化 也可以用滚动数组优化 两个一维序列/字符串 ...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/summary/optimise/dynamic-programming/%E5%BA%8F%E5%88%97/%E5%8F%8C%E5%BA%8F%E5%9E%8B.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"双序型"}],["meta",{"property":"og:description","content":"双序型 有两个序列/字符串，需要进行一些操作 每个序列本身是一维的，可以转化为二维动态规划 常见是匹配型，也有双区间的 两个字符串的匹配值依赖于两个字符串前缀的匹配值 字符串长度为 n,m 则需要开(n+1)x(m+1)的状态数组 要初始化dp[i][0]与dp[0][i] 通常都可以用滚动数组进行空间优化 也可以用滚动数组优化 两个一维序列/字符串 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-01-01T21:36:31.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-01T21:36:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"双序型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-01T21:36:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[],"git":{"createdTime":1732244737000,"updatedTime":1735767391000,"contributors":[{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro-3.local","commits":2}]},"readingTime":{"minutes":3.41,"words":1022},"filePathRelative":"algo/summary/optimise/dynamic-programming/序列/双序型.md","localizedDate":"November 22, 2024","excerpt":"\\n<p>有两个序列/字符串，需要进行一些操作<br>\\n每个序列本身是一维的，可以转化为二维动态规划</p>\\n<p>常见是匹配型，也有双区间的</p>\\n<p>两个字符串的匹配值依赖于两个字符串前缀的匹配值<br>\\n字符串长度为 n,m 则需要开(n+1)x(m+1)的状态数组<br>\\n要初始化<code>dp[i][0]</code>与<code>dp[0][i]</code><br>\\n通常都可以用滚动数组进行空间优化</p>\\n<p>也可以用滚动数组优化</p>\\n<hr>\\n<p>两个一维序列/字符串</p>\\n<p>突破口</p>\\n<ul>\\n<li>串A和串B的最后一个字符是否匹配</li>\\n<li>是否需要串A/串B的最后一个字符</li>\\n<li>缩减问题规模</li>\\n</ul>","autoDesc":true}`);export{m as comp,l as data};
