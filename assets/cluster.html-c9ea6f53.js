import{_ as e,V as a,W as i,Z as r}from"./framework-e5d7a6b2.js";const h={},s=r('<h1 id="cluster-数据分片" tabindex="-1"><a class="header-anchor" href="#cluster-数据分片" aria-hidden="true">#</a> Cluster：数据分片</h1><p>节点建议最多1000个节点</p><p>16384</p><ul><li>Redis集群支持多个Master,每个Master.又可以挂载多个Slave</li><li>由于Cluster自带Sentinel的故障转移机制，内置了高可用的支持，无需再去使用哨兵功能</li><li>客户端与Redis的节点连接，♪不再需要连接集群中所有的节点，只需要任意连接集群中的一个可用节点即可</li><li>槽位sot负责分配到各个物理服务节点，由对应的集群来负责维护节点、插槽和数据之间的关系</li></ul><h2 id="集群算法" tabindex="-1"><a class="header-anchor" href="#集群算法" aria-hidden="true">#</a> 集群算法</h2><ul><li>官网出处，翻译说明</li><li>redis集群的槽位slot</li><li>redis集群的分片</li><li>他两的优势</li><li>slot槽位映射，一般业界有3种解决方案</li><li>经典面试题</li><li>为什么redis集群的最大槽数是16384个？</li><li>Redis:集群不保证强一致性，这意味着在特定的条件下，Redis集群</li><li>可能会丢掉一些被系统收到的写入请求命令</li><li>集群的密钥空间被分成16384个槽，有效地设置了16384个主节点</li><li>的集群大小上限（但是，建议的最大节点大小约为1000个节点）。</li></ul><p>哈希槽，CRC16校验对16384取模</p><p>这种结构很容易添加或者删除节点.比如如果我想新添加个节点D,我需要从节点A,B,C中得部分槽到D上.如果我想移除节点A,需要将A中的槽移到B和C节点上，然后将没有任何槽的A节点从集群中移除即可.由于从一个节点将哈希槽移动到另一个节点并不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态</p><h2 id="哈希分区" tabindex="-1"><a class="header-anchor" href="#哈希分区" aria-hidden="true">#</a> 哈希分区</h2><h3 id="哈希取余分区" tabindex="-1"><a class="header-anchor" href="#哈希取余分区" aria-hidden="true">#</a> 哈希取余分区</h3><p>如果数量变动，就会故障不可用</p><h3 id="一致性哈希算法分区" tabindex="-1"><a class="header-anchor" href="#一致性哈希算法分区" aria-hidden="true">#</a> 一致性哈希算法分区</h3><h4 id="步骤" tabindex="-1"><a class="header-anchor" href="#步骤" aria-hidden="true">#</a> 步骤</h4><p>构建一致性哈希环：0-2^32-1</p><p>节点映射：redis服务器ip节点映射</p><p>落键规则：当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key),将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。</p><h4 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h4><p>容错性：只影响宕机的这一台的数据，且这些数据将来也会转移到下一台去存储</p><p>扩展性：增加节点不需要哈希重新计算</p><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h4><p>Hash环的数据倾斜问题：一致性Hsh算法在服务节点太少时，容易因为节点分布不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题</p><h3 id="哈希槽分区" tabindex="-1"><a class="header-anchor" href="#哈希槽分区" aria-hidden="true">#</a> 哈希槽分区</h3><p>哈希槽实质就是一个数组，数组[0,2^14-1]形成hash slot空间。</p><p>2能干什么</p><p>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽(slot),用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。</p><h3 id="为什么16384" tabindex="-1"><a class="header-anchor" href="#为什么16384" aria-hidden="true">#</a> 为什么16384</h3><p>(1)如果槽位为65536，发送心跳信息的消息头达8k,发送的心跳包过于庞大。</p><p>在消息头中最占空间的是myslots[CLUSTER SLOTS/8]。当槽位为65536时，这块的大小是：65536÷8÷1024=8kb 在消息头中最占空间的是myslots[CLUSTER SLOTS/8]。当槽位为16384时，这块的大小是：16384÷8÷1024=2kb 因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。</p><p>(2)redis的集群主节点数量基本不可能超过1000个。</p><p>集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者不建议redis cluster节点数量超过1000个。那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。</p><p>(3)槽位越小，节点少的情况下，压缩比高，容易传输</p><p>Redis主节点的配置信息中它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中会对bitmap进行压缩，但是如果bitmap的填充率 slots/N很高的话(N表示节点数)，bitmap的压缩率就很低。如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。</p><h3 id="不保证强一致性" tabindex="-1"><a class="header-anchor" href="#不保证强一致性" aria-hidden="true">#</a> 不保证强一致性</h3><p>节点挂了会写丢失</p>',34),d=[s];function l(t,p){return a(),i("div",null,d)}const c=e(h,[["render",l],["__file","cluster.html.vue"]]);export{c as default};
