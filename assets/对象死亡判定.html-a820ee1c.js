import{_ as a,V as e,W as i,Z as l}from"./framework-e5d7a6b2.js";const o={},d=l('<h1 id="对象死亡判定" tabindex="-1"><a class="header-anchor" href="#对象死亡判定" aria-hidden="true">#</a> 对象死亡判定</h1><h2 id="引用计数" tabindex="-1"><a class="header-anchor" href="#引用计数" aria-hidden="true">#</a> 引用计数</h2><p>优点：</p><ul><li>原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。</li></ul><p>缺点：</p><ul><li>占用了一些额外的内存空间来进行计数</li><li>难以解决循环引用的问题；它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也 就无法回收它们。</li></ul><h2 id="可达性分析" tabindex="-1"><a class="header-anchor" href="#可达性分析" aria-hidden="true">#</a> 可达性分析</h2><p>这个算法的基本思路就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到 GC Roots 间没有任何引用链相连， 或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。</p><h3 id="gc-roots-的选择" tabindex="-1"><a class="header-anchor" href="#gc-roots-的选择" aria-hidden="true">#</a> GC Roots 的选择</h3><ul><li>在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。</li><li>在方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量。</li><li>在方法区中常量引用的对象，譬如字符串常量池(String Table)里的引用。</li><li>在本地方法栈中 JNI(即通常所说的 Native 方法)引用的对象。</li><li>Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象(比如 NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器。</li><li>所有被同步锁(synchronized 关键字)持有的对象。</li><li>反映 Java 虚拟机内部情况的 JM XBean、JVM TI 中注册的回调、本地代码缓存等。</li></ul><p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不 同，还可以有其他对象“临时性”地加入，共同构成完整 GC Roots 集合。譬如后文将会提到的分代收集 和局部回收(Partial GC)，如果只针对 Java 堆中某一块区域发起垃圾收集时(如最典型的只针对新生 代的垃圾收集)，必须考虑到内存区域是虚拟机自己的实现细节(在用户视角里任何内存区域都是不 可见的)，更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引 用，这时候就需要将这些关联区域的对象也一并加入 GC Roots 集合中去，才能保证可达性分析的正确 性。</p><p>方法区的垃圾收集主要回收两部分内容:废弃的常量和不再使用的类型。回收废弃常量与回收 Java 堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“ java”曾经进入常量池 中，但是当前系统又没有任何一个字符串对象的值是“ java”，换句话说，已经没有任何字符串对象引用 常量池中的“ java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且 垃圾收集器判断确有必要的话，这个“ java”常量就将会被系统清理出常量池。常量池中其他类(接口)、方法、字段的符号引用也与此类似。</p><h3 id="生存还是死亡" tabindex="-1"><a class="header-anchor" href="#生存还是死亡" aria-hidden="true">#</a> 生存还是死亡</h3><p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓 刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程:如果对象在进行可达性分析后发现没 有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是 否有必要执行 <code>finalize()</code>方法。假如对象没有覆盖 <code>finalize()</code>方法，或者 <code>finalize()</code>方法已经被虚拟机调用 过，那么虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为确有必要执行 <code>finalize()</code>方法，那么该对象将会被放置在一个名为 F-Queue 的 队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的 finalizer 线程去执行它们的 <code>finalize()</code> 方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。 这样做的原因是，如果某个对象的 <code>finalize()</code>方法执行缓慢，或者更极端地发生了死循环，将很可能导 致 F-Queue 队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。<code>finalize()</code>方法是对 象逃脱死亡命运的最后一次机会，稍后收集器将对 F-Queue 中的对象进行第二次小规模的标记，如果对 象要在 <code>finalize()</code>中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 (this 关键字)赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集 合;如果对象这时候还没有逃脱，那基本上它就真的要被回收了。从代码清单 3-2 中我们可以看到一个 对象的 <code>finalize()</code>被执行，但是它仍然可以存活。</p><h2 id="回收方法区" tabindex="-1"><a class="header-anchor" href="#回收方法区" aria-hidden="true">#</a> 回收方法区</h2><p>方法区的垃圾收集主要回收两部分内容：</p><ol><li>废弃的常量</li><li>不再使用的类型</li></ol><h3 id="废弃常量" tabindex="-1"><a class="header-anchor" href="#废弃常量" aria-hidden="true">#</a> 废弃常量</h3><p>回收废弃常量与回收 Java 堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“ java”曾经进入常量池 中，但是当前系统又没有任何一个字符串对象的值是“ java”，换句话说，已经没有任何字符串对象引用 常量池中的“ java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且 垃圾收集器判断确有必要的话，这个“ java”常量就将会被系统清理出常量池。常量池中其他类(接口)、方法、字段的符号引用也与此类似。</p><h3 id="不再使用的类型" tabindex="-1"><a class="header-anchor" href="#不再使用的类型" aria-hidden="true">#</a> 不再使用的类型</h3><p>判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件:</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul>',23),r=[d];function h(n,c){return e(),i("div",null,r)}const s=a(o,[["render",h],["__file","对象死亡判定.html.vue"]]);export{s as default};
