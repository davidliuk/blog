import{_ as i,V as e,W as l,Z as a}from"./framework-e5d7a6b2.js";const d={},p=a('<h1 id="trace-note" tabindex="-1"><a class="header-anchor" href="#trace-note" aria-hidden="true">#</a> Trace Note</h1><h2 id="项目背景" tabindex="-1"><a class="header-anchor" href="#项目背景" aria-hidden="true">#</a> 项目背景</h2><h3 id="项目介绍" tabindex="-1"><a class="header-anchor" href="#项目介绍" aria-hidden="true">#</a> 项目介绍</h3><p>雁过留痕 Trace Note 是一款基于地点的社交 app。用户可以在一个地点开启一个 Trace AR 场景，并在场景中放置 Note 虚拟留言板，不同用户见可以在同一个 Trace 中相互交互评论。Note 留言板提供字体、材质等个性化装饰选项。用户可以通过每日签到打卡获取代币，用来抢购个性化装扮，以提高个性化程度，并作为激励机制提高用户每日的活跃度。</p><h3 id="人员分工" tabindex="-1"><a class="header-anchor" href="#人员分工" aria-hidden="true">#</a> 人员分工</h3><ul><li>3个同学，1人全职文案和海报，2位开发同学客户端和后端共同负责</li><li>2人客户端、SwiftUI主要界面、ARKit场景交互页面</li><li>2人后端、</li></ul><h2 id="项目开发" tabindex="-1"><a class="header-anchor" href="#项目开发" aria-hidden="true">#</a> 项目开发</h2><h3 id="技术选型" tabindex="-1"><a class="header-anchor" href="#技术选型" aria-hidden="true">#</a> 技术选型</h3><p>后端：</p><ul><li>Spring Boot 2.8, Spring AOP</li><li>MySQL, Redis, Redisson</li><li>hutool</li><li>RabbitMQ, Spring AMQP</li><li>文档：knife4j</li></ul><p>客户端：</p><ul><li>SwiftUI做的界面</li><li>ARKit做的AR交互</li></ul><h3 id="系统业务" tabindex="-1"><a class="header-anchor" href="#系统业务" aria-hidden="true">#</a> 系统业务</h3><p>2022年中国高校计算机大赛-移动应用创新赛全国二等奖</p><p>字节跳动第四届青训营万码奔腾奖(一等奖)</p><h3 id="项目亮点" tabindex="-1"><a class="header-anchor" href="#项目亮点" aria-hidden="true">#</a> 项目亮点</h3><ol><li>利用 AOP 实现注解校验用户登陆状态及用户权限。使用 Redis 实现分布式 Session，解决集群间登录态同步问题；</li><li>使用 MD5 + 随机加盐 算法保证用户密码不被泄漏，提高系统的安全性。</li><li>使用 Redis 对高频访问 Trace 进行缓存，降低 DB 压力同时提升 90% 的数据查询性能。</li><li>使用模版模式实现了通用缓存访问静态方法，并解决了缓存雪崩、缓存穿透和缓存击穿的问题。</li><li>使用 Redis 的 Geo 数据结构存储附近 Trace，并使用 Geo Search 命令实现高性能 Trace 查询及按距离排序。</li><li>使用 Redis ZSet 数据结构存储用户点赞信息，保证用户只能点赞一次，并可以展示记录点赞的先后排序。</li><li>使用 Redis Set 数据结构实现用户关注、共同关注功能，并使用 Redis AOF 持久化防止关注数据丢失。</li><li>使用 Redis BitMap 实现用户连续签到统计功能，提高存储的效率并减少内存的占用。</li><li>基于推模式实现关注 Feed 流，保证了新 Note 消息的及时可达，并减少用户访问的等待时间。</li><li>使用 Lua 脚本实现库存预检解决了超卖问题、实现一人一单。通过 RabbitMQ 实现异步订单创建、超时取消订单。</li></ol><p>密码存储：加盐 MD5</p><p>由于传统的MD5加密，黑客可以通过查散列值字典（例如彩虹表），得到某用户的密码。因此目前可以用MD5加密配合上随机盐值，可极大的防止密码被破解。</p><p>用户系统</p><ul><li><p>密码存储：使用 MD5 + 随机加盐 算法保证用户密码不被泄漏，提高系统的安全性。</p><p>和 MD5 摘要值一样</p><p>为什么加盐，随机生成一个 20 位字符串，防止非法用户用字典攻击的方式暴力破解。</p></li><li><p>AOF鉴权：</p><ul><li>哪些权限 <ul><li>用户</li><li>管理员</li><li>超级管理员</li><li>封号 ban</li></ul></li><li>什么模型，什么表：RBAC，五张表</li><li>AOF实现与Filter的区别 <ul><li>Filter基于servlet</li><li>AOF实现更加灵活可以加注解和参数</li></ul></li></ul></li><li><p>用户关注</p><ul><li>使用 Redis Set 数据结构实现用户关注、共同关注功能，只需要集合求交集即可很快的得到两个用户的共同关注。</li><li>并使用 Redis AOF 持久化防止关注数据丢失。</li></ul></li><li><p>用户签到</p><p>使用Redis BitMap结构进行存储，每个月</p></li></ul><hr><p>列举一些该项目可以扩展的点，有能力的同学可以自己尝试实现（注意，没有自己实现过千万别写到简历上！！！做没做过一问便知）：</p><ol><li><p>使用 Redis + Token 机制实现单点登录（补充到上述第 1 点中）</p></li><li><p>对 Redis 的所有 key 设置 N + n 的过期时间，从而合理使用内存并防止缓存雪崩；针对热点店铺缓存，使用逻辑过期（或自动续期）机制解决缓存击穿问题，防止数据库宕机。</p></li><li><p>使用 Redis 的 Geo + Hash 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及按距离排序，实测相对于传统 DB 查询 + 业务层计算的方式，性能提升 xx%。</p></li><li><p>使用 Redis Set 数据结构实现用户关注、共同关注功能（交集），实测相对于 DB 查询性能提升 xx%，并使用 Redis AOF + 业务层日志防止关注数据丢失。（理解 AOF 和 RDB 持久化机制后再写这点）</p></li><li><p>基于 Spring Scheduler 实现对热点数据的定期检测和缓存预加载，提升用户的访问体验，并通过 Redisson 分布式锁保证集群中同一时刻的定时任务只执行一次。</p></li><li><p>关注 Feed 流可以改为推拉结合模式（活跃用户用推、普通用户用拉）</p></li><li><p>使用哨兵集群来提升 Redis 的读并发量、可用性和稳定性；或者使用 Redis 分片集群来提升 Redis 读写并发量、总存储容量，保障可用性和稳定性。</p></li><li><p>随着系统用户增多，使用 Redis HyperLogLog 代替 DB 来实现店铺和点评的 UV 统计，提高 xx% 的查询分析性能并解决 xx% 的内存空间。</p></li><li><p>利用AOP实现注解校验用户登陆状态及用户权限。使用 Redis 实现分布式 Session，解决集群间登录态同步问题；</p></li><li><p>使用 Redis 对高频访问 Trace 进行缓存，降低 DB 压力同时提升 90% 的数据查询性能。</p></li><li><p>使用模版模式实现了通用缓存访问静态方法，并解决了缓存雪崩、缓存穿透和缓存击穿的问题。</p></li><li><p>使用 Redis 的 Geo + Hash 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及按距离排序。</p></li><li><p>使用 Redis ZSet 数据结构存储用户点赞信息，保证用户只能点赞一次，并基于 ZSet 记录点赞的时间。</p></li><li><p>使用 Redis Set 数据结构实现用户关注、共同关注功能（交集），实测相对于 DB 查询性能提升 xx%，并使用 Redis AOF + 业务层日志防止关注数据丢失。</p></li><li><p>使用 Redis BitMap 实现用户连续签到统计功能。</p></li><li><p>基于推模式实现关注 Feed 流，保证了新点评消息的及时可达，并减少用户访问的等待时间。</p></li><li><p>个性饰品抢购：使用 Lua 脚本实现库存预检解决了超卖问题、实现一人一单。通过 RabbitMQ 实现异步订单创建，流量削峰。</p><p>使用 Redis + Lua 脚本实现库存预检，并通过 RabbitMQ 实现订单的异步创建，解决了超卖问题、实现一人一单。实现相比传统数据库，秒杀性能提高了 xx%。</p></li></ol><p>再列举一些该项目可以扩展的点，有能力的同学可以自己尝试实现（注意，没有自己实现过千万别写到简历上！！！做没做过一问便知）：</p><ol><li>使用 Redis + Token 机制实现单点登录（补充到上述第 1 点中）</li><li>对 Redis 的所有 key 设置 N + n 的过期时间，从而合理使用内存并防止缓存雪崩；针对热点店铺缓存，使用逻辑过期（或自动续期）机制解决缓存击穿问题，防止数据库宕机。</li><li>使用 Redis 的 Geo + Hash 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及按距离排序，实测相对于传统 DB 查询 + 业务层计算的方式，性能提升 xx%。</li><li>使用 Redis Set 数据结构实现用户关注、共同关注功能（交集），实测相对于 DB 查询性能提升 xx%，并使用 Redis AOF + 业务层日志防止关注数据丢失。（理解 AOF 和 RDB 持久化机制后再写这点）</li><li>基于 Spring Scheduler 实现对热点数据的定期检测和缓存预加载，提升用户的访问体验，并通过 Redisson 分布式锁保证集群中同一时刻的定时任务只执行一次。</li><li>关注 Feed 流可以改为推拉结合模式（活跃用户用推、普通用户用拉）</li><li>使用哨兵集群来提升 Redis 的读并发量、可用性和稳定性；或者使用 Redis 分片集群来提升 Redis 读写并发量、总存储容量，保障可用性和稳定性。</li><li>随着系统用户增多，使用 Redis HyperLogLog 代替 DB 来实现店铺和点评的 UV 统计，提高 xx% 的查询分析性能并解决 xx% 的内存空间。</li></ol>',26),s=[p];function r(t,h){return e(),l("div",null,s)}const n=i(d,[["render",r],["__file","雁过留痕.html.vue"]]);export{n as default};
