import{_ as i,V as e,W as a,Z as l}from"./framework-e5d7a6b2.js";const t={},r=l('<h1 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h1><p>MTU: Maxitum Transmission Unit 最大传输单元 MSS: Maxitum Segment Size 最大分段大小 由于以太网EthernetII最大的数据帧是1518Bytes</p><p>标志位：</p><ul><li><p>SYN：建立链接</p></li><li><p>FIN：中止链接</p></li><li><p>ACK：确认32位确认序号有效。</p><p>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p></li><li><p>RST：“复位”报文</p><ol><li>目的端口无监听。当连接请求到达时,目的端口没有进程正在监听，TCP会产生一个复位报文。（在UDP中，则产生一个ICMP端口不可达的信息）</li><li>异常终止链接。可以通过发送个复位报文段而不是FIN来中途释放一个连接，这种行为称为异常释放( abortive release)。 <ul><li>如窗口探测3次都发现接受窗口为0</li><li>连接中，收到错误的标志信号，如SYN等</li><li>客户端的连接被关闭，客户的内核就会回 RST 报文，服务端收到后就会释放连接。</li></ul></li></ol></li><li><p>URG：</p></li><li><p>PSH：</p><p>有点过时</p></li></ul><h2 id="连接管理" tabindex="-1"><a class="header-anchor" href="#连接管理" aria-hidden="true">#</a> 连接管理</h2><h3 id="建立连接-三次握手" tabindex="-1"><a class="header-anchor" href="#建立连接-三次握手" aria-hidden="true">#</a> 建立连接 - 三次握手</h3><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/TCP三次握手.drawio.png" alt="TCP 三次握手"></p><h3 id="为什么每次建立-tcp-连接时-初始化的序列号都要求不一样呢" tabindex="-1"><a class="header-anchor" href="#为什么每次建立-tcp-连接时-初始化的序列号都要求不一样呢" aria-hidden="true">#</a> 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h3><p>主要原因有两个方面：</p><ul><li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li><li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li></ul><h4 id="tcp-半连接和全连接队列" tabindex="-1"><a class="header-anchor" href="#tcp-半连接和全连接队列" aria-hidden="true">#</a> TCP 半连接和全连接队列</h4><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accept 队列；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/format,png-20230309230622886.png" alt="正常流程"></p><p>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。</p><h4 id="syn-攻击" tabindex="-1"><a class="header-anchor" href="#syn-攻击" aria-hidden="true">#</a> SYN 攻击</h4><p>SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样<strong>当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃</strong>，导致客户端无法和服务端建立连接。</p><p>避免 SYN 攻击方式，可以有以下四种方法：</p><ul><li>调大 netdev_max_backlog；</li><li>增大 TCP 半连接队列；</li><li>开启 tcp_syncookies；</li><li>减少 SYN+ACK 重传次数</li></ul><p>tcp_syncookies</p><p>具体过程：</p><ul><li>当 「 SYN 队列」满之后，后续服务端收到 SYN 包，不会丢弃，而是根据算法，计算出一个 <code>cookie</code> 值；</li><li>将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端；</li><li>服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「 Accept 队列」。</li><li>最后应用程序通过调用 <code>accpet()</code> 接口，从「 Accept 队列」取出的连接。</li></ul><p>可以看到，当开启了 tcp_syncookies 了，即使受到 SYN 攻击而导致 SYN 队列满时，也能保证正常的连接成功建立。</p><p>net.ipv4.tcp_syncookies 参数主要有以下三个值：</p><ul><li>0 值，表示关闭该功能；</li><li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；</li><li>2 值，表示无条件开启功能；</li></ul><p>那么在应对 SYN 攻击时，只需要设置为 1 即可。</p><h3 id="断开连接-四次挥手" tabindex="-1"><a class="header-anchor" href="#断开连接-四次挥手" aria-hidden="true">#</a> 断开连接 - 四次挥手</h3><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p><h2 id="重传机制" tabindex="-1"><a class="header-anchor" href="#重传机制" aria-hidden="true">#</a> 重传机制</h2><ul><li>超时重传</li><li>快速重传</li><li>SACK方法</li><li>D-SACK方法</li></ul><h2 id="滑动窗口" tabindex="-1"><a class="header-anchor" href="#滑动窗口" aria-hidden="true">#</a> 滑动窗口</h2><p>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p><p>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p><p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p><h2 id="流量控制" tabindex="-1"><a class="header-anchor" href="#流量控制" aria-hidden="true">#</a> 流量控制</h2><p><code>RcvWindow=RcvBuffer-[LastByteRcvd-LastByteRead]</code></p><h2 id="拥塞控制" tabindex="-1"><a class="header-anchor" href="#拥塞控制" aria-hidden="true">#</a> 拥塞控制</h2><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul>',39),d=[r];function n(p,s){return e(),a("div",null,d)}const h=i(t,[["render",n],["__file","TCP.html.vue"]]);export{h as default};
