import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as i,o as s}from"./app-B_TQ4tbw.js";const n={};function l(r,e){return s(),t("div",null,e[0]||(e[0]=[i('<h1 id="基本类型" tabindex="-1"><a class="header-anchor" href="#基本类型"><span>基本类型</span></a></h1><p>基本类型与底层数据结构对应关系如下图所示：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/9fa26a74965efbf0f56b707a03bb9b7f.png" alt="img" loading="lazy"></p><h2 id="string" tabindex="-1"><a class="header-anchor" href="#string"><span>String</span></a></h2><p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value 其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 <code>512M</code>。</p><h3 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h3><p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</p><p>SDS 和我们认识的 C 字符串不太一样，SDS 相比于 C 的原生字符串：</p><ul><li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 <code>SDS</code> 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li><li><strong>SDS 获取字符串长度的时间复杂度是 O(1)</strong>。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>。</li><li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li></ul><p>字符串对象的内部编码（encoding）有 3 种 ：<strong>int、raw 和 embstr</strong>。</p><h3 id="场景" tabindex="-1"><a class="header-anchor" href="#场景"><span>场景</span></a></h3><h4 id="缓存对象" tabindex="-1"><a class="header-anchor" href="#缓存对象"><span>缓存对象</span></a></h4><p>使用 String 来缓存对象有两种方式：</p><ul><li>直接缓存整个对象的 JSON，命令例子： <code>SET user:1 &#39;{&quot;name&quot;:&quot;xiaolin&quot;, &quot;age&quot;:18}&#39;</code>。</li><li>采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： <code>MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20</code>。</li></ul><h4 id="常规计数" tabindex="-1"><a class="header-anchor" href="#常规计数"><span>常规计数</span></a></h4><p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</p><h4 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁"><span>分布式锁</span></a></h4><p>setnx是不可重入</p><p>也可以做可重入，但是需要多种机制保证</p><h2 id="list" tabindex="-1"><a class="header-anchor" href="#list"><span>List</span></a></h2><h3 id="原理-1" tabindex="-1"><a class="header-anchor" href="#原理-1"><span>原理</span></a></h3><p>List 对象的底层数据结构：</p><ul><li><p>Redis 3.0，list + ziplist</p><p>小规模时 ziplist，大规模时 list</p><ul><li><p>ziplist</p><p>优点是内存紧凑，访问效率高</p><p>缺点是更新效率低，并且数据量较大时，可能导致大量的内存复制</p></li><li><p>list</p><p>优点是节点修改的效率高</p><p>缺点需要额外内存开销，并且节点较多时，会产生大量的内存碎片</p></li></ul></li><li><p>Redis 3.2，quicklist (+ ziplist)</p></li><li><p>Redis 7.0，quicklist (+ listpack)</p></li></ul><h3 id="场景-1" tabindex="-1"><a class="header-anchor" href="#场景-1"><span>场景</span></a></h3><h4 id="消息队列" tabindex="-1"><a class="header-anchor" href="#消息队列"><span>消息队列</span></a></h4><p>消息队列在存取消息时，必须要满足三个需求，分别是<strong>消息保序、处理重复的消息和保证消息可靠性</strong>。</p><h2 id="hash" tabindex="-1"><a class="header-anchor" href="#hash"><span>Hash</span></a></h2><h3 id="原理-2" tabindex="-1"><a class="header-anchor" href="#原理-2"><span>原理</span></a></h3><p>Hash 类型的底层数据结构是由<strong>listpack 或哈希表</strong>实现的：</p><ul><li>元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，使用<strong>ListPack</strong>作为 Hash 类型的底层数据结构；</li><li>不满足上面条件，使用<strong>哈希表</strong>作为 Hash 类型底层数据结构。</li></ul><h3 id="场景-2" tabindex="-1"><a class="header-anchor" href="#场景-2"><span>场景</span></a></h3><p>一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。</p><h4 id="购物车" tabindex="-1"><a class="header-anchor" href="#购物车"><span>购物车</span></a></h4><p>经常修改其中部分内容</p><h4 id="分布式锁-1" tabindex="-1"><a class="header-anchor" href="#分布式锁-1"><span>分布式锁</span></a></h4><p>Redisson 的实现就是 hash，一个记录线程 id，一个记录重入次数</p><h2 id="set" tabindex="-1"><a class="header-anchor" href="#set"><span>Set</span></a></h2><h3 id="原理-3" tabindex="-1"><a class="header-anchor" href="#原理-3"><span>原理</span></a></h3><p>Set 类型的底层数据结构是由<strong>整数集合或哈希表</strong>实现的：</p><ul><li>元素都是<strong>整数</strong>且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li><li>不满足上面条件，则使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li></ul><h3 id="场景-3" tabindex="-1"><a class="header-anchor" href="#场景-3"><span>场景</span></a></h3><p>点赞</p><p>共同关注</p><p><code>SINTER</code>, <code>SDIFF</code></p><p>抽奖活动</p><p><code>SRANDMEMBER</code>, <code>SPOP</code></p><h2 id="zset-sorted-set" tabindex="-1"><a class="header-anchor" href="#zset-sorted-set"><span>Zset / Sorted Set</span></a></h2><h3 id="原理-4" tabindex="-1"><a class="header-anchor" href="#原理-4"><span>原理</span></a></h3><p>Zset 类型的底层数据结构是由<strong>listpack 或跳表</strong>实现的：</p><ul><li>元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>listpack</strong>作为 Zset 类型的底层数据结构；</li><li>不满足上面的条件，Redis 会使用<strong>skiplist</strong>作为 Zset 类型的底层数据结构；</li></ul><h3 id="场景-4" tabindex="-1"><a class="header-anchor" href="#场景-4"><span>场景</span></a></h3><h4 id="排行榜" tabindex="-1"><a class="header-anchor" href="#排行榜"><span>排行榜</span></a></h4><h4 id="电话、姓名排序" tabindex="-1"><a class="header-anchor" href="#电话、姓名排序"><span>电话、姓名排序</span></a></h4>',53)]))}const p=a(n,[["render",l],["__file","基本类型.html.vue"]]),h=JSON.parse(`{"path":"/cs/database/redis/principal/data-structure/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.html","title":"基本类型","lang":"en-US","frontmatter":{"description":"基本类型 基本类型与底层数据结构对应关系如下图所示： img String String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value 其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 512M。 原理 String 类型的底层的数据结构实现主要是 int 和 SDS...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/cs/database/redis/principal/data-structure/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"基本类型"}],["meta",{"property":"og:description","content":"基本类型 基本类型与底层数据结构对应关系如下图所示： img String String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value 其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 512M。 原理 String 类型的底层的数据结构实现主要是 int 和 SDS..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaolincoding.com//mysql/other/9fa26a74965efbf0f56b707a03bb9b7f.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-27T01:21:47.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-27T01:21:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"基本类型\\",\\"image\\":[\\"https://cdn.xiaolincoding.com//mysql/other/9fa26a74965efbf0f56b707a03bb9b7f.png\\"],\\"dateModified\\":\\"2024-06-27T01:21:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"String","slug":"string","link":"#string","children":[{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":3,"title":"场景","slug":"场景","link":"#场景","children":[]}]},{"level":2,"title":"List","slug":"list","link":"#list","children":[{"level":3,"title":"原理","slug":"原理-1","link":"#原理-1","children":[]},{"level":3,"title":"场景","slug":"场景-1","link":"#场景-1","children":[]}]},{"level":2,"title":"Hash","slug":"hash","link":"#hash","children":[{"level":3,"title":"原理","slug":"原理-2","link":"#原理-2","children":[]},{"level":3,"title":"场景","slug":"场景-2","link":"#场景-2","children":[]}]},{"level":2,"title":"Set","slug":"set","link":"#set","children":[{"level":3,"title":"原理","slug":"原理-3","link":"#原理-3","children":[]},{"level":3,"title":"场景","slug":"场景-3","link":"#场景-3","children":[]}]},{"level":2,"title":"Zset / Sorted Set","slug":"zset-sorted-set","link":"#zset-sorted-set","children":[{"level":3,"title":"原理","slug":"原理-4","link":"#原理-4","children":[]},{"level":3,"title":"场景","slug":"场景-4","link":"#场景-4","children":[]}]}],"git":{"createdTime":1677504602000,"updatedTime":1719451307000,"contributors":[{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":4},{"name":"davidliuk","email":"l729641074@163.com","commits":3}]},"readingTime":{"minutes":3.77,"words":1132},"filePathRelative":"cs/database/redis/principal/data-structure/基本类型.md","localizedDate":"February 27, 2023","excerpt":"\\n<p>基本类型与底层数据结构对应关系如下图所示：</p>\\n<p><img src=\\"https://cdn.xiaolincoding.com//mysql/other/9fa26a74965efbf0f56b707a03bb9b7f.png\\" alt=\\"img\\" loading=\\"lazy\\"></p>\\n<h2>String</h2>\\n<p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value 其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 <code>512M</code>。</p>\\n<h3>原理</h3>","autoDesc":true}`);export{p as comp,h as data};
