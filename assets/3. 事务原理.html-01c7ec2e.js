import{_ as e,V as d,W as o,Z as a}from"./framework-e5d7a6b2.js";const i={},l=a('<h1 id="事务原理" tabindex="-1"><a class="header-anchor" href="#事务原理" aria-hidden="true">#</a> 事务原理</h1><p>事务性质</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-24 23.15.51.png" alt="截屏2023-02-24 23.15.51" loading="lazy"></p><h2 id="redo-log" tabindex="-1"><a class="header-anchor" href="#redo-log" aria-hidden="true">#</a> redo log</h2><p>保证：<strong>持久性</strong></p><p>物理日志：存操作的指令</p><p>该日志文件由两部分组成：</p><ul><li>重做日志缓冲(redo log buffer)</li><li>重做日志文件(redo log file)</li></ul><p>前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p><p><strong>WAL</strong>，先写日志，再往磁盘写，这样可以先记录下来</p><p>保证刷新脏页发生错误时，可以恢复数据</p><p>既然 redo log 也需要在事务提交时将日志写入磁盘，为什么它比直接将 Buffer Pool 中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：</p><ol><li>刷脏是随机 IO，因为每次修改的数据位置随机，但写 redo log 是追加操作，属于顺序 IO。</li><li>刷脏是以数据页（Page）为单位的，MySQL 默认页大小是 16KB，一个 Page 上一个小修改都要整页写入；而 redo log 中只包含真正需要写入的部分，无效 IO 大大减少。</li></ol><h2 id="undo-log" tabindex="-1"><a class="header-anchor" href="#undo-log" aria-hidden="true">#</a> undo log</h2><p>保证：<strong>原子性</strong></p><p>作用：</p><ul><li>提供回滚</li><li>MVCC</li></ul><p>逻辑日志：存操作的指令的反向操作（操作以前会把历史版本记入）</p><ul><li>Undo log 销毁：undo log 在事务执行时产生，事务提交时，并不会立即别除 undo log,因为这些日志可能还用于 MVCC。</li><li>Undo log 存储：undo log 采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含 1024 个 undo log segment。</li></ul><h2 id="mvcc" tabindex="-1"><a class="header-anchor" href="#mvcc" aria-hidden="true">#</a> MVCC</h2><p>保证：<strong>隔离性</strong> Isolation</p><p>实现：隔离级别</p><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><h4 id="mvcc-1" tabindex="-1"><a class="header-anchor" href="#mvcc-1" aria-hidden="true">#</a> MVCC</h4><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为 MySQL 实现。</p><p>MVCC 提供了一个非阻塞读功能。MVCC 的具体实现，还需要依赖于：</p><ul><li>数据库聚簇索引记录中的三个隐式字段</li><li>undo log 日志</li><li>read view</li></ul><h4 id="当前读-锁定读" tabindex="-1"><a class="header-anchor" href="#当前读-锁定读" aria-hidden="true">#</a> 当前读/锁定读</h4><p>特点：读取的记录是最新版本，加锁防止别人修改。（可以完全解决插入或删除导致的幻读）</p><ul><li><code>select xxx lock in share mode</code></li><li><code>select ... for update</code></li><li><code>insert</code>、<code>update</code>、<code>delete</code> 操作</li></ul><h4 id="快照读-一致性非锁定读" tabindex="-1"><a class="header-anchor" href="#快照读-一致性非锁定读" aria-hidden="true">#</a> 快照读/一致性非锁定读</h4><p>简单的 select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li>Read Committed: 每次 select,都生成一个快照读。</li><li>Repeatable Read: 开启事务后第一个 select 语句才是快照读的地方。</li><li>Serializable: 快照读会退化为当前读。</li></ul><p>在一致性非锁定读下，即使读取的记录已被其它事务加上 <code>X</code> 锁，这时记录也是可以被读取的，即读取的快照数据。</p><p>上面说了，在 <code>Repeatable Read</code> 下 <code>MVCC</code> 防止了部分幻读，这边的 “部分” 是指在 <code>一致性非锁定读</code> 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是！如果是 <code>当前读</code> ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， <strong><code>InnoDB</code> 在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据</strong>。</p><h3 id="隐藏字段" tabindex="-1"><a class="header-anchor" href="#隐藏字段" aria-hidden="true">#</a> 隐藏字段</h3><ul><li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除</li><li><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</li><li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</li></ul><p><code>ibd2sdi xxx.ibd</code>可以查看这张表的定义格式，可以看到所有的字段包括隐藏字段</p><h3 id="undo-log-1" tabindex="-1"><a class="header-anchor" href="#undo-log-1" aria-hidden="true">#</a> undo log</h3><p>undo log 中是一个版本链（链表）</p><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的 undolog 生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><h4 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h4><p><code>undo log</code> 主要有两个作用：</p><ul><li>当事务回滚时用于将数据恢复到修改前的样子</li><li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读（快照读）</li></ul><h4 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h4><p><code>undo log</code> 分为两种： <code>insert undo log</code> 和 <code>update undo log</code>：</p><ol><li><strong><code>insert undo log</code></strong> ：指在 <code>insert</code> 操作中产生的 <code>undo log</code>。因为 <code>insert</code> 操作的记录只对事务本身可见，对其他事务不可见，故该 <code>undo log</code> 可以在事务提交后直接删除。不需要进行 <code>purge</code> 操作</li><li><strong><code>update undo log</code></strong> ：<code>update</code> 或 <code>delete</code> 操作中产生的 <code>undo log</code>。该 <code>undo log</code>可能需要提供 <code>MVCC</code> 机制（快照读），因此不能在事务提交时就进行删除。提交时放入 <code>undo log</code> 链表，等待 <code>purge线程</code> 进行最后的删除</li></ol><h3 id="read-view" tabindex="-1"><a class="header-anchor" href="#read-view" aria-hidden="true">#</a> Read View</h3><p>读视图，是快照读 SQL 执行时 MVCC 提取数据的依据，记录并维护系统当前活动的事务（未提交的）id。确定当前快照读应该读哪个版本。 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”。</p><h4 id="核心字段" tabindex="-1"><a class="header-anchor" href="#核心字段" aria-hidden="true">#</a> 核心字段</h4><p>ReadView 中包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务 ID 集合，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</td></tr><tr><td>min_trx_id</td><td>最小活跃事务 ID，即m_ids 的最小值</td></tr><tr><td>max_trx_id</td><td>预分配事务 ID，当前最大事务 ID+1(因为事务 ID 是自增的)</td></tr><tr><td>creator_trx_id</td><td>该 ReadView 创建者的事务 ID</td></tr><tr><td>m_low_limit_no</td><td>事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge</td></tr></tbody></table><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-25 13.01.59.png" alt="截屏2023-02-25 13.01.59" loading="lazy"></p><h4 id="数据可见性算法" tabindex="-1"><a class="header-anchor" href="#数据可见性算法" aria-hidden="true">#</a> 数据可见性算法</h4><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ul><li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code>值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id 值在 Read View 的<code>min_trx_id</code>和<code>max_trx_id</code>之间，需要判断 trx_id 是否在 m_ids 列表中： <ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul><p>遇到不可见的记录就会利用 DB_ROLL_PTR 沿着undo log版本链往下找，直到找到满足的快照版本或返回空。</p><h4 id="生成时机" tabindex="-1"><a class="header-anchor" href="#生成时机" aria-hidden="true">#</a> 生成时机</h4><p>不同的隔离级别，生成 Readview 的时机不同：</p><ul><li>READ COMMITTED：会在事务中每一次执行快照读时生成 Read View。</li><li>REPEATABLE READ：仅在事务中第一次执行快照读时生成 Read View，后续复用该 Read View,（小林中说是事务启动的时候生成）</li></ul><h2 id="一致性保证" tabindex="-1"><a class="header-anchor" href="#一致性保证" aria-hidden="true">#</a> 一致性保证</h2><p>一致性是事务追求的最终目标，实现一致性的措施包括：</p><ul><li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证.</li><li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等</li><li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致.</li></ul><h3 id="cap-和-acid-中的一致性" tabindex="-1"><a class="header-anchor" href="#cap-和-acid-中的一致性" aria-hidden="true">#</a> CAP 和 ACID 中的一致性</h3><ul><li>CAP 定理中的数据一致性，其实是说分布式系统中的各个节点中对于同一数据的拷贝有着相同的值</li><li>ACID 中的一致性是指数据库的规则，如果 schema 中规定了一个值必须是唯一的，那么一致的系统必须确保在所有的操作中，该值都是唯一的。</li></ul><p>由此来看 CAP 和 ACID 对于一致性的定义有着根本性的区别。</p><p>总结事务的 ACID 四大基本特性是保证数据库能够运行的基石，但是完全保证数据库的 ACID，尤其是隔离性会对性能有比较大影响，在实际的使用中我们也会根据业务的需求对隔离性进行调整，除了隔离性，数据库的原子性和持久性相信都是比较好理解的特性，前者保证数据库的事务要么全部执行、要么全部不执行，后者保证了对数据库的写入都是持久存储的、非易失的，而一致性不仅是数据库对本身数据的完整性的要求，同时也对开发者提出了要求-写出逻辑正确并且合理的事务。最后，也是最重要的，当别人在讲一致性的时候，一定要搞清楚他的上下文。</p>',67),r=[l];function c(t,n){return d(),o("div",null,r)}const s=e(i,[["render",c],["__file","3. 事务原理.html.vue"]]);export{s as default};
