const e=JSON.parse(`{"key":"v-1621c0cc","path":"/se/lang/java/JUC/thread-pool/%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0.html","title":"核心参数","lang":"en-US","frontmatter":{"description":"核心参数 线程 核心线程：运行完任务以后依然保留在线程池当中 救急线程：运行完任务以后抛弃不保留 参数 corePoolSize 核心线程树木 最多保留的线程数，可以为0 maximumPoolSize最大线程数目 核心线程 + 救急线程 keepAliveTime 生存时间 针对救急线程，执行完成以后存留的时间的数字，如20，30等 unit 针对救急线程，执行完成以后存留的时间的单位，如秒、毫秒等 workQueue 任务队列上限 阻塞队列 threadFactory 线程工厂 handler 拒绝策略 四种，线程池、等待队列、救急线程都满的时候，如何处理 AbortPolicy，爆异常 CallerRunsPolicy，调用者自己去运行这个任务 DiscardPolicy，新加入的丢弃掉 DiscardOldestPolicy，把任务队列中等待最久的（最先加入队列的）丢弃掉，然后新任务加入进来","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/se/lang/java/JUC/thread-pool/%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"核心参数"}],["meta",{"property":"og:description","content":"核心参数 线程 核心线程：运行完任务以后依然保留在线程池当中 救急线程：运行完任务以后抛弃不保留 参数 corePoolSize 核心线程树木 最多保留的线程数，可以为0 maximumPoolSize最大线程数目 核心线程 + 救急线程 keepAliveTime 生存时间 针对救急线程，执行完成以后存留的时间的数字，如20，30等 unit 针对救急线程，执行完成以后存留的时间的单位，如秒、毫秒等 workQueue 任务队列上限 阻塞队列 threadFactory 线程工厂 handler 拒绝策略 四种，线程池、等待队列、救急线程都满的时候，如何处理 AbortPolicy，爆异常 CallerRunsPolicy，调用者自己去运行这个任务 DiscardPolicy，新加入的丢弃掉 DiscardOldestPolicy，把任务队列中等待最久的（最先加入队列的）丢弃掉，然后新任务加入进来"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-02-03T07:46:32.000Z"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2023-02-03T07:46:32.000Z"}],["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://davidliuk.github.io/blog/blog/zh/se/lang/java/JUC/thread-pool/%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0.html"}]]},"headers":[],"git":{"createdTime":1675410392000,"updatedTime":1675410392000,"contributors":[{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":1}]},"readingTime":{"minutes":0.97,"words":292},"localizedDate":"February 3, 2023","filePathRelative":"se/lang/java/JUC/thread-pool/核心参数.md","excerpt":"<h1> 核心参数</h1>\\n<p><img src=\\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-02 11.10.58.png\\" alt=\\"截屏2023-02-02 11.10.58\\" loading=\\"lazy\\"></p>\\n<p>线程</p>\\n<ul>\\n<li>核心线程：运行完任务以后依然保留在线程池当中</li>\\n<li>救急线程：运行完任务以后抛弃不保留</li>\\n</ul>\\n<p>参数</p>\\n<ol>\\n<li>\\n<p>corePoolSize 核心线程树木</p>\\n<ul>\\n<li>最多<strong>保留</strong>的线程数，可以为0</li>\\n</ul>\\n</li>\\n<li>\\n<p>maximumPoolSize最大线程数目</p>\\n<ul>\\n<li>核心线程 + 救急线程</li>\\n</ul>\\n</li>\\n<li>\\n<p>keepAliveTime 生存时间</p>\\n<p>针对救急线程，执行完成以后存留的时间的数字，如20，30等</p>\\n</li>\\n<li>\\n<p>unit</p>\\n<p>针对救急线程，执行完成以后存留的时间的单位，如秒、毫秒等</p>\\n</li>\\n<li>\\n<p>workQueue 任务队列上限</p>\\n<p>阻塞队列</p>\\n</li>\\n<li>\\n<p>threadFactory 线程工厂</p>\\n</li>\\n<li>\\n<p>handler 拒绝策略</p>\\n<p>四种，线程池、等待队列、救急线程都满的时候，如何处理</p>\\n<ul>\\n<li>AbortPolicy，爆异常</li>\\n<li>CallerRunsPolicy，调用者自己去运行这个任务</li>\\n<li>DiscardPolicy，新加入的丢弃掉</li>\\n<li>DiscardOldestPolicy，把任务队列中等待最久的（最先加入队列的）丢弃掉，然后新任务加入进来</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}`);export{e as data};
