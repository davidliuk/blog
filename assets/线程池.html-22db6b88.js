const e=JSON.parse(`{"key":"v-e189f522","path":"/se/lang/java/JUC/thread/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html","title":"线程池","lang":"en-US","frontmatter":{"description":"线程池 Java线程池进阶_服务重启线程池如何保证不丢失任务_一头狒狒的博客-CSDN博客 好处 池化技术：线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。 线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/se/lang/java/JUC/thread/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"线程池"}],["meta",{"property":"og:description","content":"线程池 Java线程池进阶_服务重启线程池如何保证不丢失任务_一头狒狒的博客-CSDN博客 好处 池化技术：线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。 线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-05-17T10:10:52.000Z"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2023-05-17T10:10:52.000Z"}],["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://davidliuk.github.io/blog/blog/zh/se/lang/java/JUC/thread/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html"}]]},"headers":[{"level":2,"title":"好处","slug":"好处","link":"#好处","children":[]},{"level":2,"title":"核心参数","slug":"核心参数","link":"#核心参数","children":[{"level":3,"title":"核心概念","slug":"核心概念","link":"#核心概念","children":[]},{"level":3,"title":"初始参数","slug":"初始参数","link":"#初始参数","children":[]}]},{"level":2,"title":"执行流程","slug":"执行流程","link":"#执行流程","children":[]},{"level":2,"title":"内置线程池","slug":"内置线程池","link":"#内置线程池","children":[{"level":3,"title":"FixedThreadPool","slug":"fixedthreadpool","link":"#fixedthreadpool","children":[]},{"level":3,"title":"SingleThreadExecutor","slug":"singlethreadexecutor","link":"#singlethreadexecutor","children":[]},{"level":3,"title":"CachedThreadPool","slug":"cachedthreadpool","link":"#cachedthreadpool","children":[]},{"level":3,"title":"ScheduledThreadPool","slug":"scheduledthreadpool","link":"#scheduledthreadpool","children":[]}]},{"level":2,"title":"阻塞队列","slug":"阻塞队列","link":"#阻塞队列","children":[{"level":3,"title":"什么是阻塞队列","slug":"什么是阻塞队列","link":"#什么是阻塞队列","children":[]},{"level":3,"title":"线程池常用的阻塞队列总结","slug":"线程池常用的阻塞队列总结","link":"#线程池常用的阻塞队列总结","children":[]},{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":3,"title":"常见阻塞队列","slug":"常见阻塞队列","link":"#常见阻塞队列","children":[]}]},{"level":2,"title":"问题","slug":"问题","link":"#问题","children":[{"level":3,"title":"重启","slug":"重启","link":"#重启","children":[]}]},{"level":2,"title":"使用进阶","slug":"使用进阶","link":"#使用进阶","children":[{"level":3,"title":"线程池的创建","slug":"线程池的创建","link":"#线程池的创建","children":[]},{"level":3,"title":"阻塞队列在线程池中的使用","slug":"阻塞队列在线程池中的使用","link":"#阻塞队列在线程池中的使用","children":[]},{"level":3,"title":"保证提交阶段任务不丢失","slug":"保证提交阶段任务不丢失","link":"#保证提交阶段任务不丢失","children":[]},{"level":3,"title":"4、保证队列、未执行完成的任务不丢失","slug":"_4、保证队列、未执行完成的任务不丢失","link":"#_4、保证队列、未执行完成的任务不丢失","children":[]},{"level":3,"title":"5、ThreadLocal 变量传递","slug":"_5、threadlocal-变量传递","link":"#_5、threadlocal-变量传递","children":[]},{"level":3,"title":"6、异常处理","slug":"_6、异常处理","link":"#_6、异常处理","children":[]}]}],"git":{"createdTime":1679578424000,"updatedTime":1684318252000,"contributors":[{"name":"davidliuk","email":"l729641074@163.com","commits":3},{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":2}]},"readingTime":{"minutes":18.2,"words":5460},"localizedDate":"March 23, 2023","filePathRelative":"se/lang/java/JUC/thread/线程池.md","excerpt":"<h1> 线程池</h1>\\n<p><a href=\\"https://blog.csdn.net/ch98000/article/details/126727000\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Java线程池进阶_服务重启线程池如何保证不丢失任务_一头狒狒的博客-CSDN博客</a></p>\\n<h2> 好处</h2>\\n<p>池化技术：线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>\\n<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>","autoDesc":true}`);export{e as data};
