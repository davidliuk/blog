import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as r,c as a,d as o}from"./app-9107e99b.js";const i={},n=o('<h1 id="面向对象-object-oriented-programming" tabindex="-1"><a class="header-anchor" href="#面向对象-object-oriented-programming" aria-hidden="true">#</a> 面向对象 Object-Oriented Programming</h1><h3 id="三大特征" tabindex="-1"><a class="header-anchor" href="#三大特征" aria-hidden="true">#</a> 三大特征</h3><h4 id="封装-encapsulation" tabindex="-1"><a class="header-anchor" href="#封装-encapsulation" aria-hidden="true">#</a> 封装 Encapsulation</h4><h4 id="继承-inheritance" tabindex="-1"><a class="header-anchor" href="#继承-inheritance" aria-hidden="true">#</a> 继承 Inheritance</h4><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><h4 id="多态-polymorphism" tabindex="-1"><a class="header-anchor" href="#多态-polymorphism" aria-hidden="true">#</a> 多态 Polymorphism</h4><p>多态，表示一个对象具有多种的状态，具体表现为<strong>父类的引用指向子类的实例</strong>。</p><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><h3 id="深拷贝和浅拷贝区别了解吗-什么是引用拷贝" tabindex="-1"><a class="header-anchor" href="#深拷贝和浅拷贝区别了解吗-什么是引用拷贝" aria-hidden="true">#</a> 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li></ul><p>上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！</p><p><strong>浅拷贝</strong></p><p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p><p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p>',17),t=[n];function c(d,l){return r(),a("div",null,t)}const p=e(i,[["render",c],["__file","面向对象.html.vue"]]);export{p as default};
