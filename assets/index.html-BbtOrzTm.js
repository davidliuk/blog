import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as n,o as l}from"./app-CrF8c6p-.js";const t={};function e(p,s){return l(),i("div",null,s[0]||(s[0]=[n(`<h1 id="bfs" tabindex="-1"><a class="header-anchor" href="#bfs"><span>BFS</span></a></h1><p>分类</p><ul><li><p>狭义 BFS：Breadth-first search (BFS)</p><p>结点只能入队一次</p></li><li><p>扩展 BFS：Best-first search (BeFS)</p><p>结点可以入队多次（根据规则）</p></li></ul><p>如果可以预先计算出每个节点到终点的距离，则可以利用这个信息更快的到达终点。</p><p>其原理与 Dijkstra 算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法。</p><h2 id="高频考法" tabindex="-1"><a class="header-anchor" href="#高频考法"><span>高频考法</span></a></h2><ol><li>连通块问题</li><li>分层遍历</li><li>拓扑排序</li></ol><h3 id="连通块问题" tabindex="-1"><a class="header-anchor" href="#连通块问题"><span>连通块问题</span></a></h3><ul><li><p>通过图中一个点找到其他所有连通的点</p></li><li><p>找到所有方案问题的一种非递归实现方式</p><p>DFS vs BFS 在连通块问题上的优劣</p></li></ul><h3 id="分层遍历" tabindex="-1"><a class="header-anchor" href="#分层遍历"><span>分层遍历</span></a></h3><ul><li><p>图的层级遍历</p><p>一层一层的遍历一个图、树、矩阵</p></li><li><p>简单图最短路径问题</p><ul><li><p>简单图：只有权值都一样，或者说是无权图</p><p>简单图中，层级=最短路</p><p>简单图中：第几层访问到该节点=到达该节点的最短路径</p></li><li><p>复杂度最短路径有什么算法</p><p>SPFA、Dijkstra</p><p>复杂图中：我可能通过三层访问到比通过两层访问到的路径更短</p></li><li><p>最长路径用什么算法</p></li><li><p>什么是隐式图</p></li><li><p>通用的 BFS 模板</p></li><li><p>80%的人都会写错的 BFS 写法</p></li></ul></li></ul><h3 id="拓扑排序" tabindex="-1"><a class="header-anchor" href="#拓扑排序"><span>拓扑排序</span></a></h3><ul><li><p>DFS vs BFS 在拓扑排序上的优劣</p><p>实现容易度远超过 DFS</p></li><li><p>拓扑排序的五个考点</p><ul><li>问有没有拓扑排序</li><li>求任意一个拓扑排序</li><li>求最小的拓扑排序</li><li>求拓扑排序是否唯一</li></ul></li></ul><hr><p>原则：能 BFS 的别 DFS(除非面试官特别要求)</p><p>（其实连通块问题用 dfs 写起来又短又快，且效率往往更高）</p><ul><li>Recursion 版本的 DFS 有 StackOverflow 的风险</li><li>Non-Recursion 版本的 DFS 容易错+面试官未必看得懂</li></ul><h2 id="bfs-模版" tabindex="-1"><a class="header-anchor" href="#bfs-模版"><span>BFS 模版</span></a></h2><p>屡试不爽的 BFS 代码模板，刷题效率直接翻倍</p><p>应该在哪里做访问标记？入队之前标记 visited/distance 防止重复入队</p><p>矩阵坐标变换数组（如果是矩阵坐标 visited 可以不必 hashmap，二维数组即可）</p><ul><li>deltaX, deltaY</li><li>inBound / isValid</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ReturnType</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> bfs</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Node</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> startNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> [</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Node</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> endNode]) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // BFS 必须要用 queue，別用 stack！</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Queue</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Node</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> queue </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayDeque</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // hashmap 两个作用，一个是记录一个点是否被丢进过队列了，避免重复访问</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 另外一个是记录 startNode 到其他所有节点的最短距离</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 如果只求连通性的话，可以换成 HashSet 就行</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // node 做 key 的时候比较的是内存地址</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 如果是二维坐标可以用二维数组来记录</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Node</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> distance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 把起点放进队列和哈希表里，如果有多个起点，都放进去</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">offer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(startNode);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    distance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(startNode, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // or 1  if necessary</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // while 队列不空，不停的从队列里拿出一个点，拓展邻居节点放到队列中</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> isEmpty</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> node </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">poll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 遍历点的时候，出队后更新</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 如果有明确的终点可以在这里加终点的判断</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (node 是終点) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        	break</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> or </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> something</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> neighbor </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getNeighbors</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">distance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">containsKey</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(neighbor)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            	continue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 若不满足条件，跳过</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 这里可以判断边和点的条件</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isValid</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(neighbor)) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	            continue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            }</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">orter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(neighbor);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 遍历边的时候，入队前更新</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 遍历点的时候也可以，但是建议上面</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 防止重复入队/访问，同时记录层次信息</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            distance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(neighbor, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">distance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (node) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 如果带要返回所有息离起息的跑离，就 return hashmap</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> distance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 如果需要返回所有连通的节点，就 return HashMap 里的所有点</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> distance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">keySet</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 如果需要返回离终点的最短距离</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> distance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(endNode);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="a-算法" tabindex="-1"><a class="header-anchor" href="#a-算法"><span>A * 算法</span></a></h2><p>A * search algorithm，简称 A* 算法，是一种在图形平面上，对于有多个节点的路径求出最低通过成本的算法。它属于图遍历（Graph traversal）和最佳优先搜索算法（Best-first search），亦是 BFS 的改进。</p><p>A*算法是综合上面这些算法的特点于一身的。A*算法通过下面这个函数来计算每个节点的优先级。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> f(n)=g(n)+h(n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p><ul><li>f(n) 是起点 s 到终点 t 的预估长度，是节点 n 的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。</li><li>g(n) 是节点 n 距离起点 s 的代价。</li><li>h*(n) 是节点 n 距离终点 t 的代价。搜索过程中很难准确的知道这个代价。</li><li>h(n) 是节点 n 距离终点 t 的预估代价。采用预计代价，是 A*算法的启发函数。</li></ul><p>A*算法在运算过程中，每次从优先队列中选取 f(n)值最小（优先级最高）的节点作为下一个待遍历的节点。</p><p>另外，A*算法使用两个集合来表示：</p><ul><li><code>open_set</code>：待遍历的节点</li><li><code>close_set</code>：已经遍历过的节点</li></ul><p>我们知道，A*的时间复杂度是和节点数量以及起始点难度呈幂函数正相关的。</p><p><a href="http://qiao.github.io/PathFinding.js/visual/" target="_blank" rel="noopener noreferrer">网址</a>很好的演示了双向 A*的效果，我们来看一看。</p><p>绿色表示起点，红色表示终点，灰色是墙面。稍浅的两种绿色分别代表 open 节点和 close 节点：</p><p>针对 A*算法的节点多导致搜索时间太长作了一定的改进</p><ol><li><p>估价函数采用两点之间的欧式距离</p></li><li><p>交替进行前向和后向搜寻</p></li><li><p>设置搜寻阈值，当超过这一阈值时，设定方向点的为阈值临界点，只有目标点在阈值范围内时再进行搜寻</p></li></ol><h3 id="对-h-的估计" tabindex="-1"><a class="header-anchor" href="#对-h-的估计"><span>对 h 的估计</span></a></h3><p>它是 A*算法中的最特别之处，是“启发式”体现的核心，也是与 Dijkstra 算法相比，差别最大的部分。</p><p>令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>h</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\hat h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2079em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">h</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的一个估计。估计<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>h</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\hat h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2079em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">h</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的过程通常被称为<strong>试探法</strong>，因为估计过程是从当前节点向终点（尚未探测到的节点）的一种估计。估计的准确度依赖于问题域中可用的信息数。</p><p>迪杰斯特拉算法在寻找下个点时，选择标准为：</p><p>open 列表中，距离起点最近的点。即：起点到该点的距离最短</p><p>最佳优先搜索算法在寻找下个点时，选择标准为：</p><p>open 列表中，距离终点最近的点。即：起点到该点的距离最短</p><p>A*算法在寻找下个点时，选择标准为：</p><p>open 列表中，起点到该点的距离 + 该点到终点的直线距离 之和 最短。</p><p>从下表可知，选择一个好的启发函数是重要的。</p><table><thead><tr><th>情况</th><th>函数</th><th>结果</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>h</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\\hat h(n)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2079em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">h</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></td><td>A*算法退化为 Dijkstra 算法</td><td>保证能找到一条最短路径</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>h</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\hat h(n)&lt; h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2079em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">h</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>h</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\hat h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2079em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">h</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>越小，A*扩展的节点越多，运行的越慢</td><td>保证能找到一条最短路径，但运算更快了</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>h</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\hat h(n)= h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2079em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">h</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>仅寻找最佳路径，而不扩展任何别的节点。</td><td>保证能找到一条最短路径，并且运算非常快</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>h</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\hat h(n)&gt; h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2079em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">h</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>寻找最佳路径且扩展别的任何节点</td><td>不能保证找到一条最短路径，但运算更快了</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>h</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>≫</mo><mover accent="true"><mi>g</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\hat h(n)\\gg\\hat g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2079em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">h</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≫</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>A*算法退化为 BFS 算法</td><td>不能保证找到一条最短路径，但运算非常快</td></tr></tbody></table><p>所以得到一个很有趣的情况，那就是可以决定想要从 A*中获得什么。</p><p>理想情况下，我们想最快地得到最短路径；但如果目标太低，仍会得到最短路径，不过速度变慢了；如果目标太高，那就放弃了最短路径，但它运行得更快。</p><h3 id="启发函数" tabindex="-1"><a class="header-anchor" href="#启发函数"><span>启发函数</span></a></h3><p>常见估价函数（用距离）</p><ul><li><p>欧几里得距离：直线距离</p><p>一般不行</p></li><li><p>曼哈顿距离：xy 距离绝对值的和</p><p>不能斜着走</p></li><li><p>切比雪夫距离：xy 距离绝对值的最大值</p><p>可以斜着走的时候</p></li></ul><hr><p>openSet queue</p><p>closeSet visited</p><hr><p>可以很好的解决八数码问题</p><p>完整的 A*算法描述如下：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>* 初始化open_set和close_set；</span></span>
<span class="line"><span>* 将起点加入open_set中，并设置优先级为0（优先级最高）；</span></span>
<span class="line"><span>* 如果open_set不为空，则从open_set中选取优先级最高的节点n：</span></span>
<span class="line"><span>    * 如果节点n为终点，则：</span></span>
<span class="line"><span>        * 从终点开始逐步追踪parent节点，一直达到起点；</span></span>
<span class="line"><span>        * 返回找到的结果路径，算法结束；</span></span>
<span class="line"><span>    * 如果节点n不是终点，则：</span></span>
<span class="line"><span>        * 将节点n从open_set中删除，并加入close_set中；</span></span>
<span class="line"><span>        * 遍历节点n所有的邻近节点：</span></span>
<span class="line"><span>            * 如果邻近节点m在close_set中，则：</span></span>
<span class="line"><span>                * 跳过，选取下一个邻近节点</span></span>
<span class="line"><span>            * 如果邻近节点m在open_set中，则：</span></span>
<span class="line"><span>                * 判断节点n到节点m的 F(n) + cost[n,m] 值是否 &lt; 节点m的 F(m) 。来尝试更新该点，重新设置f值和父节点等数据</span></span>
<span class="line"><span>            * 如果邻近节点m也不在open_set中，则：</span></span>
<span class="line"><span>                * 设置节点m的parent为节点n</span></span>
<span class="line"><span>                * 计算节点m的优先级</span></span>
<span class="line"><span>                * 将节点m加入open_set中</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="bfs-实现" tabindex="-1"><a class="header-anchor" href="#bfs-实现"><span>BFS 实现</span></a></h3><p>常见有三种写法：</p><ul><li>dummy、</li><li>BiQueue 双队列</li><li>Queue 单队列</li></ul><h3 id="bfs-例题" tabindex="-1"><a class="header-anchor" href="#bfs-例题"><span>BFS 例题</span></a></h3><p>二叉树的层次遍历 - LintCode<br> 二叉树的层次遍历 II - LintCode<br> 二叉树的最大深度 - LintCode<br> 单词接龙 II - LintCode<br> 岛屿的个数 - LintCode</p><hr><p>实际面试围绕 BFS 所涉及算法和数据结构</p><p>二叉树<br> 拓扑排序算法<br> 堆<br> 宽度优先搜素<br> 深度优先搜索<br> 动态规划<br> 字符串处理</p><hr><p>二叉树的层次遍历<br> 二叉树的层次遍历川<br> 二叉树的最大深度<br> 单词接龙<br> 拓扑排序<br> 克隆图<br> 岛屿的个数<br> 墙和门<br> 二叉树的右视图<br> 外星人字典</p><hr><p>搞定 BFS 知识点，你可以刷这些高频题</p><ul><li>二叉树的层次遍历</li><li>克隆图</li><li>二叉树的最大深度</li><li>岛屿的个数</li><li>单词接龙</li><li>墙和门</li><li>拓扑排序</li><li>外星人字典</li></ul><p>样例，每个题做完相当于啃下 3 一 5 道类似题</p><h2 id="进阶" tabindex="-1"><a class="header-anchor" href="#进阶"><span>进阶</span></a></h2><ul><li><p>BFS 解决最短路径问题时可能产生的各类变化</p></li><li><p>宽度优先搜索代码模板</p></li><li><p>BFS 两种实现方式</p><ul><li>在不同情况下各自的优劣对比</li></ul></li><li><p>图的邻接表(Adjacency List)存储方法</p></li><li><p>使用 SPFA 算法解决复杂图最短路径问题</p></li><li><p>双向宽度优先搜索代码模板</p></li><li><p>双向宽度优先搜索到底带来多大的优化?</p></li><li><p>如何记录 BFS 求出的最短路径的具体方案</p></li></ul><p>例题</p>`,76)]))}const m=a(t,[["render",e],["__file","index.html.vue"]]),c=JSON.parse(`{"path":"/algo/summary/search/BFS/","title":"BFS","lang":"en-US","frontmatter":{"description":"BFS 分类 狭义 BFS：Breadth-first search (BFS) 结点只能入队一次 扩展 BFS：Best-first search (BeFS) 结点可以入队多次（根据规则） 如果可以预先计算出每个节点到终点的距离，则可以利用这个信息更快的到达终点。 其原理与 Dijkstra 算法类似，我们也使用一个优先队列，但此时以每个节点到达终...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/summary/search/BFS/"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"BFS"}],["meta",{"property":"og:description","content":"BFS 分类 狭义 BFS：Breadth-first search (BFS) 结点只能入队一次 扩展 BFS：Best-first search (BeFS) 结点可以入队多次（根据规则） 如果可以预先计算出每个节点到终点的距离，则可以利用这个信息更快的到达终点。 其原理与 Dijkstra 算法类似，我们也使用一个优先队列，但此时以每个节点到达终..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-22T03:05:37.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-22T03:05:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"BFS\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-22T03:05:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"高频考法","slug":"高频考法","link":"#高频考法","children":[{"level":3,"title":"连通块问题","slug":"连通块问题","link":"#连通块问题","children":[]},{"level":3,"title":"分层遍历","slug":"分层遍历","link":"#分层遍历","children":[]},{"level":3,"title":"拓扑排序","slug":"拓扑排序","link":"#拓扑排序","children":[]}]},{"level":2,"title":"BFS 模版","slug":"bfs-模版","link":"#bfs-模版","children":[]},{"level":2,"title":"A * 算法","slug":"a-算法","link":"#a-算法","children":[{"level":3,"title":"对 h 的估计","slug":"对-h-的估计","link":"#对-h-的估计","children":[]},{"level":3,"title":"启发函数","slug":"启发函数","link":"#启发函数","children":[]},{"level":3,"title":"BFS 实现","slug":"bfs-实现","link":"#bfs-实现","children":[]},{"level":3,"title":"BFS 例题","slug":"bfs-例题","link":"#bfs-例题","children":[]}]},{"level":2,"title":"进阶","slug":"进阶","link":"#进阶","children":[]}],"git":{"createdTime":1732244737000,"updatedTime":1732244737000,"contributors":[{"name":"David Liu","email":"liudawei@seas.upenn.edu","commits":1}]},"readingTime":{"minutes":9.09,"words":2726},"filePathRelative":"algo/summary/search/BFS/README.md","localizedDate":"November 22, 2024","excerpt":"\\n<p>分类</p>\\n<ul>\\n<li>\\n<p>狭义 BFS：Breadth-first search (BFS)</p>\\n<p>结点只能入队一次</p>\\n</li>\\n<li>\\n<p>扩展 BFS：Best-first search (BeFS)</p>\\n<p>结点可以入队多次（根据规则）</p>\\n</li>\\n</ul>\\n<p>如果可以预先计算出每个节点到终点的距离，则可以利用这个信息更快的到达终点。</p>\\n<p>其原理与 Dijkstra 算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法。</p>","autoDesc":true}`);export{m as comp,c as data};
