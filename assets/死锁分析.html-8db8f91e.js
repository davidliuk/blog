const e=JSON.parse(`{"key":"v-8195d204","path":"/cs/database/mysql/lock/%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90.html","title":"死锁分析","lang":"en-US","frontmatter":{"description":"死锁分析 为什么会产生死锁？ 可重复读隔离级别下，是存在幻读的问题。 Innodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁，它是记录锁和间隙锁的组合。 Record Lock，记录锁，锁的是记录本身； Gap Lock，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。 普通的 select 语句是不会对记录加锁的，因为它是通过 MVCC 的机制实现的快照读，如果要在查询时对记录加行锁，可以使用下面这两个方式：","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/cs/database/mysql/lock/%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"死锁分析"}],["meta",{"property":"og:description","content":"死锁分析 为什么会产生死锁？ 可重复读隔离级别下，是存在幻读的问题。 Innodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁，它是记录锁和间隙锁的组合。 Record Lock，记录锁，锁的是记录本身； Gap Lock，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。 普通的 select 语句是不会对记录加锁的，因为它是通过 MVCC 的机制实现的快照读，如果要在查询时对记录加行锁，可以使用下面这两个方式："}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-03-23T13:33:44.000Z"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2023-03-23T13:33:44.000Z"}],["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://davidliuk.github.io/blog/blog/zh/cs/database/mysql/lock/%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90.html"}]]},"headers":[{"level":2,"title":"为什么会产生死锁？","slug":"为什么会产生死锁","link":"#为什么会产生死锁","children":[]}],"git":{"createdTime":1679578424000,"updatedTime":1679578424000,"contributors":[{"name":"davidliuk","email":"l729641074@163.com","commits":1}]},"readingTime":{"minutes":0.6,"words":180},"localizedDate":"March 23, 2023","filePathRelative":"cs/database/mysql/lock/死锁分析.md","excerpt":"<h1> 死锁分析</h1>\\n<h2> 为什么会产生死锁？</h2>\\n<p>可重复读隔离级别下，是存在幻读的问题。</p>\\n<p><strong>Innodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁</strong>，它是记录锁和间隙锁的组合。</p>\\n<ul>\\n<li>Record Lock，记录锁，锁的是记录本身；</li>\\n<li>Gap Lock，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。</li>\\n</ul>\\n<p>普通的 select 语句是不会对记录加锁的，因为它是通过 MVCC 的机制实现的快照读，如果要在查询时对记录加行锁，可以使用下面这两个方式：</p>","autoDesc":true}`);export{e as data};
