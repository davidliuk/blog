import{_ as e,V as a,W as r,Z as n}from"./framework-e5d7a6b2.js";const t={},i=n('<h1 id="并发容器" tabindex="-1"><a class="header-anchor" href="#并发容器" aria-hidden="true">#</a> 并发容器</h1><ul><li><strong><code>ConcurrentHashMap</code></strong> : 线程安全的 <code>HashMap</code></li><li><strong><code>CopyOnWriteArrayList</code></strong> : 线程安全的 <code>List</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>。</li><li><strong><code>ConcurrentLinkedQueue</code></strong> : 高效的并发队列，使用链表实现。可以看做一个线程安全的 <code>LinkedList</code>，这是一个非阻塞队列。</li><li><strong><code>BlockingQueue</code></strong> : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li><li><strong><code>ConcurrentSkipListMap</code></strong> : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</li></ul><h2 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h2><h3 id="concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap" aria-hidden="true">#</a> ConcurrentHashMap</h3><h4 id="java-8" tabindex="-1"><a class="header-anchor" href="#java-8" aria-hidden="true">#</a> Java 8</h4><p>对Node加锁。</p><p>Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><h5 id="inittable" tabindex="-1"><a class="header-anchor" href="#inittable" aria-hidden="true">#</a> initTable</h5><p>从源码中可以发现 <code>ConcurrentHashMap</code> 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p><ol><li>-1 说明正在初始化</li><li>-N 说明有N-1个线程正在进行扩容</li><li>0 表示 table 初始化大小，如果 table 没有初始化</li><li>&gt;0 表示 table 扩容的阈值，如果 table 已经初始化。</li></ol><h4 id="java-7" tabindex="-1"><a class="header-anchor" href="#java-7" aria-hidden="true">#</a> Java 7</h4><p>Java7 中 <code>ConcurrentHashMap</code> 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 <code>Segment</code> 都是一个类似 <code>HashMap</code> 数组的结构，它可以扩容，它的冲突会转化为链表。但是 <code>Segment</code> 的个数一但初始化就不能改变。</p><h4 id="hashtable-vs-concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#hashtable-vs-concurrenthashmap" aria-hidden="true">#</a> HashTable vs ConcurrentHashMap</h4><p>共同点：HashTable 与 ConcurrentHashMap 都是线程安全的Map集合</p><p>不同点：</p><ul><li><p>HashTable 并发度低，整个 HashTable 对应一把锁，只能有一个线程操作它</p></li><li><p>1.8之前 ConcurrentHashMap 使用了 Segment + 数组 + 链表，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突</p></li><li><p>1.8开始 ConcurrentHashMap 将数组的每个头节点作为锁（这个时候结构也是数组加链表或红黑树），如果多个线程访问的头节点不同，则不会冲突。</p></li></ul><h3 id="concurrentskiplistmap" tabindex="-1"><a class="header-anchor" href="#concurrentskiplistmap" aria-hidden="true">#</a> ConcurrentSkipListMap</h3><h3 id="线程安全的使用" tabindex="-1"><a class="header-anchor" href="#线程安全的使用" aria-hidden="true">#</a> 线程安全的使用</h3><p>使用Colletcions这个工具类syn方法类创建个线程安全的set.</p><p><code>Set&lt;String&gt; synSet = Collections.synchronizedSet(new HashSet&lt;&gt;())</code></p><p>实现比较粗暴，就是在每个方法前加synchronized</p><h2 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h2><h3 id="copyonwritearraylist" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist" aria-hidden="true">#</a> CopyOnWriteArrayList</h3><h3 id="blockingqueue" tabindex="-1"><a class="header-anchor" href="#blockingqueue" aria-hidden="true">#</a> BlockingQueue</h3>',24),o=[i];function c(h,d){return a(),r("div",null,o)}const l=e(t,[["render",c],["__file","Concurrent.html.vue"]]);export{l as default};
