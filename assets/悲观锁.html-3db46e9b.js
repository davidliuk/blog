import{_ as o,V as h,W as c,X as a,Y as e,$ as d,Z as n,E as i}from"./framework-e5d7a6b2.js";const t={},p=n('<h1 id="悲观锁" tabindex="-1"><a class="header-anchor" href="#悲观锁" aria-hidden="true">#</a> 悲观锁</h1><p>代表：synchronized 和 Lock</p><ul><li>核心是：线程占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待</li><li>线程从运行到阻塞，再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能</li><li>实际上，线程在获取 synchronized 和 Lock 锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会</li></ul><h2 id="synchronized" tabindex="-1"><a class="header-anchor" href="#synchronized" aria-hidden="true">#</a> synchronized</h2><p>是可重入锁。</p><p><code>synchronized</code> 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>不过，在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。因此， <code>synchronized</code> 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 <code>synchronized</code> 。</p><h3 id="基本原理" tabindex="-1"><a class="header-anchor" href="#基本原理" aria-hidden="true">#</a> 基本原理</h3><p>对象头中包含两部分：MarkWord 和 类型指针。如果是数组对象的话，对象头还有一部分是存储数组的长度。</p><p>多线程下 synchronized 的加锁就是对同一个对象的对象头中的 MarkWord 中的变量进行 CAS 操作。</p><h3 id="锁升级" tabindex="-1"><a class="header-anchor" href="#锁升级" aria-hidden="true">#</a> 锁升级</h3><p>Java6 对 synchronized 进行了优化。</p><p>级别从低到高依次是：</p><ol><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ol><h4 id="偏向锁" tabindex="-1"><a class="header-anchor" href="#偏向锁" aria-hidden="true">#</a> 偏向锁</h4><p>适合：一个线程对一个锁的多次获取的情况</p><p>偏向锁是针对于一个线程而言的，线程获得锁之后就不会再有解锁等操作了，这样可以省略很多开销。假如有两个线程来竞争该锁话，那么偏向锁就失效了，进而升级成轻量级锁了。</p><h4 id="轻量级锁" tabindex="-1"><a class="header-anchor" href="#轻量级锁" aria-hidden="true">#</a> 轻量级锁</h4><p>适合：锁执行体比较简单(即减少锁粒度或时间), 自旋一会儿就可以成功获取锁的情况。</p><p>之所以是轻量级，是因为它仅仅使用 CAS 进行操作，实现获取锁。</p><p>如果线程发现对象头中 Mark Word 已经存在指向自己栈帧的指针，即线程已经获得轻量级锁，那么只需要将 0 存储在自己的栈帧中（此过程称为递归加锁）；在解锁的时候，如果发现锁记录的内容为 0， 那么只需要移除栈帧中的锁记录即可，而不需要更新 Mark Word。</p><p>线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录（<code>Lock Record</code>）的指针， 如上图所示。如果成功，当前线程获得轻量级锁，如果失败，虚拟机先检查当前对象头的 Mark Word 是否指向当前线程的栈帧，如果指向，则说明当前线程已经拥有这个对象的锁，则可以直接进入同步块 执行操作，否则表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。当竞争线程的自旋次数 达到界限值（<code>threshold</code>），轻量级锁将会膨胀为重量级锁。</p><h4 id="重量级锁" tabindex="-1"><a class="header-anchor" href="#重量级锁" aria-hidden="true">#</a> 重量级锁</h4><p>重量级锁（<code>heavy weight lock</code>），是使用操作系统互斥量（<code>mutex</code>）来实现的传统锁。 当所有对锁的优化都失效时，将退回到重量级锁。它与轻量级锁不同竞争的线程不再通过自旋来竞争线程， 而是直接进入堵塞状态，此时不消耗 CPU，然后等拥有锁的线程释放锁后，唤醒堵塞的线程， 然后线程再次竞争锁。但是注意，当锁膨胀（<code>inflate</code>）为重量锁时，就不能再退回到轻量级锁。</p><h2 id="reentrantreadwritelock" tabindex="-1"><a class="header-anchor" href="#reentrantreadwritelock" aria-hidden="true">#</a> ReentrantReadWriteLock</h2><h3 id="读锁、写锁" tabindex="-1"><a class="header-anchor" href="#读锁、写锁" aria-hidden="true">#</a> 读锁、写锁</h3><p>写锁：独占锁 WLock</p><p>读锁：共享锁 RLock</p><h3 id="死锁" tabindex="-1"><a class="header-anchor" href="#死锁" aria-hidden="true">#</a> 死锁</h3><p>读锁死锁的场景：</p>',31),s={href:"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/%E6%88%AA%E5%B1%8F2023-02-02",target:"_blank",rel:"noopener noreferrer"},l=a("p",null,"写锁死锁的场景：",-1),u={href:"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/%E6%88%AA%E5%B1%8F2023-02-02",target:"_blank",rel:"noopener noreferrer"},_=n('<p>读的时候不能些，写的时候可以读</p><h3 id="锁降级" tabindex="-1"><a class="header-anchor" href="#锁降级" aria-hidden="true">#</a> 锁降级</h3><p>获取写锁 -&gt; 获取读锁 -&gt; 释放写锁 -&gt; 释放读锁</p><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住(当前拥有的)写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程。</p><p>锁降级的必要性：</p><p>锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁， 假设此刻另一个线程(记作线程 T)获取了写锁并修改了数据，那么当前线程无法感知线程 T 的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程 T 将会被阻塞，直到当前线程使用数据并释放读锁之后，线程 T 才能获取写锁进行数据更新。</p><p>可能存在一个事务线程不希望自己的操作被别的线程中断，而这个事务操作可能分成多部分操作更新不同的数据(或表)甚至非常耗时。如果长时间用写锁独占，显然对于某些高响应的应用是不允许的，所以在完成部分写操作后，退而使用读锁降级，来允许响应其他进程的读操作。只有当全部事务完成后才真正释放锁。</p><p>按你的理解如果当中写锁被其他线程占用，那么这个事务线程将不得不中断等待别的写锁释放。</p><p>所以总结下锁降级的意义应该就是：在一边读一边写的情况下提高性能。</p><h3 id="读锁为什么不能升级为写锁" tabindex="-1"><a class="header-anchor" href="#读锁为什么不能升级为写锁" aria-hidden="true">#</a> 读锁为什么不能升级为写锁？</h3><p>写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。</p><p>另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。</p>',12);function f(x,g){const r=i("ExternalLinkIcon");return h(),c("div",null,[p,a("p",null,[e("![截屏2023-02-02 21.57.01]("),a("a",s,[e("https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-02"),d(r)]),e(" 21.57.01.png)")]),l,a("p",null,[e("![截屏2023-02-02 22.00.01]("),a("a",u,[e("https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-02"),d(r)]),e(" 22.00.01.png)")]),_])}const m=o(t,[["render",f],["__file","悲观锁.html.vue"]]);export{m as default};
