import{_ as a,V as e,W as r,Z as h}from"./framework-e5d7a6b2.js";const i={},d=h('<h1 id="如何实现一个扫描全能王" tabindex="-1"><a class="header-anchor" href="#如何实现一个扫描全能王" aria-hidden="true">#</a> 如何实现一个扫描全能王？</h1><p>三个需求</p><ul><li>找到图片中的纸张：边缘检测</li><li>将纸张修复展平并放在图像中间：透视变换</li><li>识别图中文字</li></ul><h2 id="文档扫描" tabindex="-1"><a class="header-anchor" href="#文档扫描" aria-hidden="true">#</a> 文档扫描</h2><ol><li>边缘检测</li><li>获取纸张轮廓</li><li>透视变换</li></ol><h2 id="ocr" tabindex="-1"><a class="header-anchor" href="#ocr" aria-hidden="true">#</a> OCR</h2><ul><li>CTPN 算法：检测文本位置</li><li>CRNN 算法：识别文本内容</li></ul><h3 id="ctpn-算法" tabindex="-1"><a class="header-anchor" href="#ctpn-算法" aria-hidden="true">#</a> CTPN 算法</h3><p>RPN(Region Proposal Network)方法（faster-rcnn）</p><p>文本通常都是从左往右写的（水平），并且字之间的宽度都大致相同固定宽度，来检测文本高度即可，但是如何应对变长序列呢？</p><p>本质上还是 RPN 方法（可参考 faster--rcnn),，可将检测到的框拼在一起！</p><h4 id="网络架构" tabindex="-1"><a class="header-anchor" href="#网络架构" aria-hidden="true">#</a> 网络架构</h4><p>VGG 提取特征，BLSTM 融入上下文信息，基于 RPN 完成检测</p><p>二分类：文字/背景</p><p>VGG 网络的 4 次池化，后面不进行了</p><p>没用 resnet（因为这个工作相对不新，用的传统方法）</p><h4 id="任务" tabindex="-1"><a class="header-anchor" href="#任务" aria-hidden="true">#</a> 任务</h4><p>输出结果包括了三部分：2K 得分，2K 回归，1K 边界调整（相比于以前工作多的一部分，提升 2%）</p><p>边界调整能使得文本检测框效果更好，下列是调整后的结果：</p><h4 id="合并小框" tabindex="-1"><a class="header-anchor" href="#合并小框" aria-hidden="true">#</a> 合并小框</h4><p>检测到每一个小块文本区域还需拼接成完整的文本区域： 规则，分前向和后向两部分：</p><p>先前向走，对于 Xi,基于重合度(0.7)与位置距离（50 像素）找到 score 值最大的的 X,接下来再返向走（规则不变），比较两次得分值大小来判断序列。</p><h3 id="crnn-算法" tabindex="-1"><a class="header-anchor" href="#crnn-算法" aria-hidden="true">#</a> CRNN 算法</h3><p>CNN + RNN</p><p>卷积和递归神经网络结合在一起：由图像得到文本</p><blockquote><p>每个词都需要上下文信息，所以只有 CNN 是不合适的</p></blockquote><p>首先 CNN 进行特征提取，接下来 RNN 进行序列特征提取，最后得出预测结果即可。</p><h4 id="ctc-模块" tabindex="-1"><a class="header-anchor" href="#ctc-模块" aria-hidden="true">#</a> CTC 模块</h4><p>对齐，对于不同长度、间隔，但是语意一样的问题，如何处理</p><p>以前的方法：都识别，然后去重，重复的只留一个</p><p>CTC：预测特殊字符，（空的或者延续长的音就变成特殊字符），然后识别的时候过滤掉。</p><p>卷积、池化（保持宽度不变长度减半）</p><h4 id="文本生成器" tabindex="-1"><a class="header-anchor" href="#文本生成器" aria-hidden="true">#</a> 文本生成器</h4><h3 id="训练" tabindex="-1"><a class="header-anchor" href="#训练" aria-hidden="true">#</a> 训练</h3><h4 id="数据集" tabindex="-1"><a class="header-anchor" href="#数据集" aria-hidden="true">#</a> 数据集</h4>',35),n=[d];function c(t,p){return e(),r("div",null,n)}const s=a(i,[["render",c],["__file","大作业.html.vue"]]);export{s as default};
