import{_ as e,V as i,W as l,Z as a}from"./framework-e5d7a6b2.js";const r={},s=a('<h1 id="面向对象设计" tabindex="-1"><a class="header-anchor" href="#面向对象设计" aria-hidden="true">#</a> 面向对象设计</h1><h3 id="类型划分" tabindex="-1"><a class="header-anchor" href="#类型划分" aria-hidden="true">#</a> 类型划分</h3><ul><li>管理类</li><li>预定类</li><li>实物类</li><li>游戏类</li></ul><h3 id="oop-三大特征" tabindex="-1"><a class="header-anchor" href="#oop-三大特征" aria-hidden="true">#</a> OOP 三大特征</h3><ul><li>封装</li><li>继承</li><li>多态</li></ul><h3 id="设计原则" tabindex="-1"><a class="header-anchor" href="#设计原则" aria-hidden="true">#</a> 设计原则</h3><p>SOLID：</p><ul><li><p>S – Single responsibility principle</p><p>一个类应该有且只有一个去改变他的理由，这意味着一个类应该只有一项工作。</p></li><li><p>O – Open close principle</p><p>对象或实体应该对扩展开放，对修改封闭 (Open to extension, close to modification)。</p></li><li><p>L – Liskov substitution principle</p><p>任何一个子类或派生类应该可以替换它们的基类或父类</p></li><li><p>I – Interface segregation principle</p><p>不应该强迫一个类实现它用不上的接口</p></li><li><p>D – Dependency inversion principle</p><p>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</p><p>High-level 的实体不应该依赖于 low-level 的实体</p></li></ul><h2 id="解题法" tabindex="-1"><a class="header-anchor" href="#解题法" aria-hidden="true">#</a> 解题法</h2><ul><li>Clarify</li><li>Core objects</li><li>Cases</li><li>Classes</li><li>Correctness</li></ul><p>Clarify</p><p>说人话:通过和面试官交流，去除题目中的歧义，确定答题范围</p><p>Core objects 说人话:确定题目所涉及的类，以及类之间的映射关系</p><p>Cases 说人话:确定题目中所需要实现的场景和功能</p><p>Classes 说人话:通过类图的方式，具体填充题目中涉及的类</p><p>Correctness 说人话:检查自己的设计，是否满足关键点</p><h3 id="correctness" tabindex="-1"><a class="header-anchor" href="#correctness" aria-hidden="true">#</a> Correctness</h3><ul><li>Validate use cases (检查是否支持所有的 use case)</li><li>Follow good practice (面试当中的加分项，展现一个程序员的经验)</li><li>S.O.L.I.D</li><li>Design pattern</li></ul><p>并行 VS 串行</p><p>单线程 VS 多线程</p>',20),p=[s];function n(t,c){return i(),l("div",null,p)}const d=e(r,[["render",n],["__file","index.html.vue"]]);export{d as default};
