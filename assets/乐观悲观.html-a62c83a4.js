import{_ as e,V as a,W as i,a0 as c}from"./framework-705b829b.js";const r={},l=c('<h1 id="乐观锁与悲观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁与悲观锁" aria-hidden="true">#</a> 乐观锁与悲观锁</h1><p>悲观锁：每次操作前都加锁</p><p>乐观锁：版本号机制</p><h3 id="悲观锁" tabindex="-1"><a class="header-anchor" href="#悲观锁" aria-hidden="true">#</a> 悲观锁</h3><p>代表：synchronized和Lock</p><ul><li>核心是：线程占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待</li><li>线程从运行到阻塞，再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能</li><li>实际上，线程在获取synchronized和Lock锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会</li></ul><h3 id="乐观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁" aria-hidden="true">#</a> 乐观锁</h3><p>代表：AtomicInteger，使用cas（Unsafe）来保证原子性</p><ul><li>核心是：无需加锁，每次只有一个线程能够成功修改共享变量，其他失败的线程不需要停止，不断重复直至成功</li><li>由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换</li><li>它需要多核cpu支持，且核心数不应超过cpu核数</li></ul>',9),n=[l];function t(h,d){return a(),i("div",null,n)}const o=e(r,[["render",t],["__file","乐观悲观.html.vue"]]);export{o as default};
