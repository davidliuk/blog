import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as i,d as r}from"./app-9107e99b.js";const n={},s=r(`<h1 id="aof" tabindex="-1"><a class="header-anchor" href="#aof" aria-hidden="true">#</a> AOF</h1><p>Append Only File (追加文件）。</p><h2 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h2><h3 id="写后日志" tabindex="-1"><a class="header-anchor" href="#写后日志" aria-hidden="true">#</a> 写后日志</h3><p>说到日志，我们比较熟悉的是数据库的redo log写前日志（Write Ahead Log, WAL），也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。</p><p>不过，AOF 日志正好相反，它是写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志，如下图所示：</p><p>那 AOF 为什么要先执行命令再记日志呢？要回答这个问题，我们要先知道 AOF 里记录了什么内容。</p><ul><li>可以避免出现记录错误命令的情况，避免额外的检查开销。</li><li>它是在命令执行后才记录日志，所以不会阻塞当前的写操作。</li></ul><p>当然，这样做也会带来风险：</p><ul><li><strong>数据可能会丢失：</strong> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</li><li><strong>可能阻塞其他操作：</strong> 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为always策略下 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/28afd536c57a46447ddab0a2062abe84.png" alt="img" loading="lazy"></p><h3 id="写回策略" tabindex="-1"><a class="header-anchor" href="#写回策略" aria-hidden="true">#</a> 写回策略</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-16 20.40.43.png" alt="截屏2023-02-16 20.40.43" loading="lazy"></p><ul><li><p><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</p><p><strong>当使用 Always 策略的时候，如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的</strong>。</p></li><li><p><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</p><p>当使用 Everysec 策略的时候，由于是异步执行 fsync() 函数，所以大 Key 持久化的过程（数据同步磁盘）不会影响主线程。</p></li><li><p><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</p></li></ul><h3 id="冗余记录" tabindex="-1"><a class="header-anchor" href="#冗余记录" aria-hidden="true">#</a> 冗余记录</h3><p>文件占用体积比RDB大得多。</p><p>解决方案：bgrewriteaof命令，可以让aof重写，只需要最少的内容即可达到一样的效果</p><p>重写触发时机设置：</p><div class="language-conf line-numbers-mode" data-ext="conf"><pre class="language-conf"><code>auto-aof-rewrite-percentage
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所以 AOF 重写过程，先重写到新的 AOF 文件，重写失败的话，就直接删除这个文件就好，不会对现有的 AOF 文件造成影响。</p><p>写入 AOF 日志的操作虽然是在主进程完成的，因为它写入的内容不多，所以一般不太影响命令的操作。</p><p>但是在触发 AOF 重写时，比如当 AOF 文件大于 64M 时，就会对 AOF 文件进行重写，这时是需要读取所有缓存的键值对数据，并为每个键值对生成一条命令，然后将其写入到新的 AOF 文件，重写完后，就把现在的 AOF 文件替换掉。</p><p>这个过程其实是很耗时的，所以重写的操作不能放在主进程里。</p><p>所以，Redis 的<strong>重写 AOF 过程是由后台子进程 *bgrewriteaof* 来完成的</strong>，这么做可以达到两个好处：</p>`,24),d=[s];function t(o,l){return a(),i("div",null,d)}const h=e(n,[["render",t],["__file","AOF.html.vue"]]);export{h as default};
