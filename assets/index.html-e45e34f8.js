const e=JSON.parse(`{"key":"v-0bff3a50","path":"/se/design/ood/","title":"面向对象设计","lang":"en-US","frontmatter":{"description":"面向对象设计 类型划分 管理类 预定类 实物类 游戏类 OOP 三大特征 封装 继承 多态 设计原则 SOLID： S – Single responsibility principle 一个类应该有且只有一个去改变他的理由，这意味着一个类应该只有一项工作。 O – Open close principle 对象或实体应该对扩展开放，对修改封闭 (Open to extension, close to modification)。 L – Liskov substitution principle 任何一个子类或派生类应该可以替换它们的基类或父类 I – Interface segregation principle 不应该强迫一个类实现它用不上的接口 D – Dependency inversion principle 抽象不应该依赖于具体实现，具体实现应该依赖于抽象 High-level 的实体不应该依赖于 low-level 的实体","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/se/design/ood/"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"面向对象设计"}],["meta",{"property":"og:description","content":"面向对象设计 类型划分 管理类 预定类 实物类 游戏类 OOP 三大特征 封装 继承 多态 设计原则 SOLID： S – Single responsibility principle 一个类应该有且只有一个去改变他的理由，这意味着一个类应该只有一项工作。 O – Open close principle 对象或实体应该对扩展开放，对修改封闭 (Open to extension, close to modification)。 L – Liskov substitution principle 任何一个子类或派生类应该可以替换它们的基类或父类 I – Interface segregation principle 不应该强迫一个类实现它用不上的接口 D – Dependency inversion principle 抽象不应该依赖于具体实现，具体实现应该依赖于抽象 High-level 的实体不应该依赖于 low-level 的实体"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-08-21T10:17:45.000Z"}],["meta",{"property":"article:author","content":"David Liu"}],["meta",{"property":"article:modified_time","content":"2023-08-21T10:17:45.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面向对象设计\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-08-21T10:17:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":3,"title":"类型划分","slug":"类型划分","link":"#类型划分","children":[]},{"level":3,"title":"OOP 三大特征","slug":"oop-三大特征","link":"#oop-三大特征","children":[]},{"level":3,"title":"设计原则","slug":"设计原则","link":"#设计原则","children":[]},{"level":2,"title":"解题法","slug":"解题法","link":"#解题法","children":[{"level":3,"title":"Correctness","slug":"correctness","link":"#correctness","children":[]}]}],"git":{"createdTime":1673495221000,"updatedTime":1692613065000,"contributors":[{"name":"liudawei47","email":"liudawei47@jd.com","commits":1},{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":1}]},"readingTime":{"minutes":1.21,"words":364},"filePathRelative":"se/design/ood/README.md","localizedDate":"January 12, 2023","excerpt":"<h1> 面向对象设计</h1>\\n<h3> 类型划分</h3>\\n<ul>\\n<li>管理类</li>\\n<li>预定类</li>\\n<li>实物类</li>\\n<li>游戏类</li>\\n</ul>\\n<h3> OOP 三大特征</h3>\\n<ul>\\n<li>封装</li>\\n<li>继承</li>\\n<li>多态</li>\\n</ul>\\n<h3> 设计原则</h3>\\n<p>SOLID：</p>\\n<ul>\\n<li>\\n<p>S – Single responsibility principle</p>\\n<p>一个类应该有且只有一个去改变他的理由，这意味着一个类应该只有一项工作。</p>\\n</li>\\n<li>\\n<p>O – Open close principle</p>\\n<p>对象或实体应该对扩展开放，对修改封闭 (Open to extension, close to modification)。</p>\\n</li>\\n<li>\\n<p>L – Liskov substitution principle</p>\\n<p>任何一个子类或派生类应该可以替换它们的基类或父类</p>\\n</li>\\n<li>\\n<p>I – Interface segregation principle</p>\\n<p>不应该强迫一个类实现它用不上的接口</p>\\n</li>\\n<li>\\n<p>D – Dependency inversion principle</p>\\n<p>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</p>\\n<p>High-level 的实体不应该依赖于 low-level 的实体</p>\\n</li>\\n</ul>","autoDesc":true}`);export{e as data};
