import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as e,d as i}from"./app-9107e99b.js";const d={},r=i('<h1 id="一致性问题-缓存更新策略" tabindex="-1"><a class="header-anchor" href="#一致性问题-缓存更新策略" aria-hidden="true">#</a> 一致性问题：缓存更新策略</h1><h2 id="概览" tabindex="-1"><a class="header-anchor" href="#概览" aria-hidden="true">#</a> 概览</h2><table><thead><tr><th></th><th>内存淘汰</th><th>超时剔除</th><th>主动更新</th></tr></thead><tbody><tr><td>说明</td><td>不用自己维护，利用 Redis 内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存。</td><td>给缓存数据添加 TTL 时间，到期后自动删除缓存。下次查询时更新缓存。</td><td>编写业务逻辑，再修改数据库的同时，更新缓存</td></tr><tr><td>一致性</td><td>差</td><td>一般</td><td>好</td></tr><tr><td>维护成本</td><td>无</td><td>低</td><td>高</td></tr></tbody></table><p>业务场景：</p><ul><li>低一致性需求：使用内存淘汰机制。例如店铺类型等查询。</li><li>高一致性需求：主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存。</li></ul><h2 id="主动更新策略" tabindex="-1"><a class="header-anchor" href="#主动更新策略" aria-hidden="true">#</a> 主动更新策略</h2><h3 id="cache-aside-pattern" tabindex="-1"><a class="header-anchor" href="#cache-aside-pattern" aria-hidden="true">#</a> Cache Aside Pattern</h3><p>由缓存的调用者，在更新数据库的同时更新缓存。</p><p>需要开发者自己编码，但是可控性很高</p><h4 id="需要考虑的问题" tabindex="-1"><a class="header-anchor" href="#需要考虑的问题" aria-hidden="true">#</a> 需要考虑的问题</h4><ol><li><p>删除缓存还是更新缓存？</p><ul><li><p>更新缓存：每次更新数据库都更新缓存，无效读写多 ，且会不一致❌</p><ul><li><p>先更新数据库、再更新缓存</p><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/8febac10b14bed16cb96d1d944cd08da.png" alt="图片" loading="lazy"></p></li><li><p>先更新缓存、再更新数据库</p><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/454a8228a6549176ad7e0484fba3c92b.png" alt="图片" loading="lazy"></p></li></ul></li><li><p>删除缓存：更新数据库时，让缓存失效，查询时再更新缓存🉑</p></li></ul></li><li><p>如何保证缓存与数据库操作的同时成功或失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用 TCC 等分布式事务方案</li></ul></li><li><p>先操作缓存还是先操作数据库？<strong><em>多线程并发访问</em></strong></p><ul><li><p>先删除缓存，再操作数据库 ❌</p><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/cc208c2931b4e889d1a58cb655537767.png" alt="图片" loading="lazy"></p></li><li><p>先操作数据库，再删除缓存🉑</p><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/1cc7401143e79383ead96582ac11b615.png" alt="图片" loading="lazy"></p></li></ul><p>一致性问题，操作数据库比操作 redis<strong>慢得多</strong>，所以先操作数据库出现一致性问题的概率更小</p><p>且即使删除操作失败了，也有过期时间可以作为保障兜底（即使删除操作失败了，超时以后也可以删除）</p><p>缓存删除失败的方案：<strong>异步操作缓存</strong></p><p><strong>重试机制</strong></p><p>我们可以引入<strong>消息队列</strong>，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。</p><ul><li>如果应用<strong>删除缓存失败</strong>，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是<strong>重试机制</strong>。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li><li>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li></ul><p>举个例子，来说明重试机制的过程。</p><p><strong>订阅 MySQL binlog 再操作缓存</strong></p><p>Canal</p><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/a4440f0d572612e0832b903e4a62bd2b.png" alt="图片" loading="lazy"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/IMG_B987FACCF2BA-1.jpeg" alt="IMG_B987FACCF2BA-1" loading="lazy"></p></li></ol><h3 id="read-write-through-pattern" tabindex="-1"><a class="header-anchor" href="#read-write-through-pattern" aria-hidden="true">#</a> Read/Write Through Pattern</h3><p>方案是由某种第三方服务提供，但是这样的服务很少</p><h3 id="write-behind-caching-pattern-写回" tabindex="-1"><a class="header-anchor" href="#write-behind-caching-pattern-写回" aria-hidden="true">#</a> Write Behind Caching Pattern 写回</h3><p>调用者只操作缓存，由其他线程异步的将缓存数据持久化道数据库，保证最终一致性</p><p>一致性和可靠性都存在一定的问题。</p><p>MESI 协议是一个基于失效的缓存一致性协议，是支持写回（write-back）缓存的最常用协议。也称作伊利诺伊协议 (Illinois protocol，因为是在伊利诺伊大学厄巴纳-香槟分校被发明的[1])。与写直达（write through）缓存相比，回写缓冲能节约大量带宽。总是有“脏”（dirty）状态表示缓存中的数据与主存中不同。MESI 协议要求在缓存不命中（miss）且数据块在另一个缓存时，允许缓存到缓存的数据复制。与 MSI 协议相比，MESI 协议减少了主存的事务数量。这极大改善了性能。[2]</p>',17),l=[r];function n(h,s){return a(),e("div",null,l)}const o=t(d,[["render",n],["__file","consistency-update-strategy.html.vue"]]);export{o as default};
