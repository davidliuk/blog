import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as l,c as i,e as u,w as n,a as e,b as t,d}from"./app-9107e99b.js";const r={},k=e("h1",{id:"singleton",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#singleton","aria-hidden":"true"},"#"),t(" singleton")],-1),v=e("p",null,"哈哈",-1),m=e("p",null,"哦哦哦",-1),h=e("p",null,null,-1),b=e("p",null,null,-1),w=e("p",null,null,-1),y=e("p",null,null,-1),f=d(`<p>原理<br> 是一种创建型模式，一个类只允许创建一个实例对象，那这个类就是个单例类。</p><h2 id="要点" tabindex="-1"><a class="header-anchor" href="#要点" aria-hidden="true">#</a> 要点</h2><ol><li>构造函数私有化，避免外部通过 new 创建实例；</li><li>考虑对象创建时的线程安全问题；</li><li>考虑是否支持延迟加载；</li><li>考虑 getInstance()性能是否高（是否加锁）</li><li>考虑序列化和反序列化是否会破坏单例</li><li>考虑反射攻击单例</li></ol><h2 id="实现" tabindex="-1"><a class="header-anchor" href="#实现" aria-hidden="true">#</a> 实现</h2><h3 id="饿汉式" tabindex="-1"><a class="header-anchor" href="#饿汉式" aria-hidden="true">#</a> 饿汉式</h3><p><code>线程安全</code>, \`\`</p><p>饿汉式的实现方式，在类加载期间，就已经将 instance 静态实例初始化好了，所以 instance 实例的创建是线程安全的。不过这样的实现不支持延迟加载实例。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IdGenerator</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">AtomicLong</span> id <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">IdGenerator</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IdGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">IdGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">IdGenerator</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> id<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="懒汉式" tabindex="-1"><a class="header-anchor" href="#懒汉式" aria-hidden="true">#</a> 懒汉式</h3><p><code>延迟加载</code></p><p>懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。</p><h3 id="dcl" tabindex="-1"><a class="header-anchor" href="#dcl" aria-hidden="true">#</a> DCL</h3><p><code>线程安全</code>, <code>延迟加载</code></p><p>双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以这种方式解决了懒汉式并发度低的问题。</p><ul><li>解决指令重排序，给 instance 成员变量加上 volatile 关键字</li><li><code>localRef</code>的作用是在已经初始化的情况下（即绝大多数情况下），减少读取 volatile 变量的次数为 1 词，这样大概可以提升 40%的性能。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IdGenerator</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">AtomicLong</span> id <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">IdGenerator</span> instance<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">IdGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">IdGenerator</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">IdGenerator</span> localRef <span class="token operator">=</span> instance<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>localRef <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">IdGenerator</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>localRef <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> localRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IdGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> localRef<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> id<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="静态内部类" tabindex="-1"><a class="header-anchor" href="#静态内部类" aria-hidden="true">#</a> 静态内部类</h3><p><code>线程安全</code>, <code>延迟加载</code></p><p>利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，instance 的唯一性，创建过程的线程安全性，都由 JVM 保证。实现起来比双重检测简单。</p><h3 id="枚举" tabindex="-1"><a class="header-anchor" href="#枚举" aria-hidden="true">#</a> 枚举</h3><p><code>线程安全</code>, <code>序列化安全</code></p><p>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。还可解决序列化和反序列化生成新的实例。</p><p>应用场景</p><p>从业务概念上，有些数据在系统中应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类，除此之外，还可以使用单例解决资源访问冲突的问题（分布式锁和并发队列亦可解决）。</p><p>存在问题</p><ul><li>单例对 OOP 特性支持不友好；</li><li>单例会隐藏类之间的依赖关系；</li><li>单例对代码扩展性不友好；</li><li>单例对代码的可测试性不友好；</li><li>单例不支持有参数的构造函数。</li></ul><p>替代方案</p><p>静态方法(不推荐)、工厂模式、Spring IOC 容器</p>`,28);function _(g,I){const p=o("Tabs");return l(),i("div",null,[k,u(p,{id:"3",data:[{id:"饿汉式"},{id:"懒汉式"},{id:"DCL 双重检测"},{id:"静态内部类"},{id:"枚举"}]},{title0:n(({value:s,isActive:a})=>[t("饿汉式")]),title1:n(({value:s,isActive:a})=>[t("懒汉式")]),title2:n(({value:s,isActive:a})=>[t("DCL 双重检测")]),title3:n(({value:s,isActive:a})=>[t("静态内部类")]),title4:n(({value:s,isActive:a})=>[t("枚举")]),tab0:n(({value:s,isActive:a})=>[v,m]),tab1:n(({value:s,isActive:a})=>[h]),tab2:n(({value:s,isActive:a})=>[b]),tab3:n(({value:s,isActive:a})=>[w]),tab4:n(({value:s,isActive:a})=>[y]),_:1}),f])}const G=c(r,[["render",_],["__file","singleton.html.vue"]]);export{G as default};
