import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as p,o as n}from"./app-isOblzBz.js";const t={};function a(o,l){return n(),i("div",null,l[0]||(l[0]=[p('<h1 id="复杂度理论" tabindex="-1"><a class="header-anchor" href="#复杂度理论"><span>复杂度理论</span></a></h1><p>四个复杂度</p><ol><li>时间复杂度 - 核心考察点</li><li>空间复杂度 - 次要考察点</li><li>编程复杂度 - 能看得懂</li><li>思维复杂度 - 能想得出</li></ol><p>双指针线性复杂度</p><p>但有的时候，很明显的小数据的情况下，可以略微损失一点时间复杂度来降低编程复杂度，提高可读性</p><h2 id="时间复杂度" tabindex="-1"><a class="header-anchor" href="#时间复杂度"><span>时间复杂度</span></a></h2><p>只考虑最高项，不考虑常数项和系数项</p><p>O(2<sup>N+N</sup>2) = O(2^N)</p><p>O(N<sup>3+1000N</sup>2) = O(N^3)</p><p>O(logN) = O(log(N^2)) = O(log4(N))</p><p>Omax(n, m) = O(n+m)</p><h3 id="p-问题-polynomial" tabindex="-1"><a class="header-anchor" href="#p-问题-polynomial"><span>P 问题 Polynomial</span></a></h3><p>（多项式问题）</p><ul><li>On，On2，On3</li><li>O1，On0.5, Om+n</li><li>Ologn，Onlogn</li></ul><h3 id="np-问题" tabindex="-1"><a class="header-anchor" href="#np-问题"><span>NP 问题</span></a></h3><ul><li>O2n，On^n, On!</li></ul><h2 id="分类" tabindex="-1"><a class="header-anchor" href="#分类"><span>分类</span></a></h2><ul><li><p>O(IogN)二分法比较多</p></li><li><p>O(N0.5)分解质因数（极少）</p></li><li><p>O(N)双指针，单调栈，枚举法</p></li><li><p>O(NlogN)排序，O(N*logN的数据结构上的操作)</p></li><li><p>O(N2),O(N3),动态规划等</p></li><li><p>O(2n)组合类(combination)的搜索问题</p></li><li><p>O(N!)排列类(permutation)的搜索问题</p></li></ul><p>根据时间复杂度来倒推算法</p><p>On 算法有</p><ol><li>双指针算法：最常见，频率远大于后面的所有算法的和</li><li>打擂台算法：找最大值（一开始赋值成负无穷，每次把最大的打下来）</li><li>单调栈算法：四五道题稍微多一些</li><li>单调队列算法</li></ol>',21)]))}const c=e(t,[["render",a],["__file","4. 复杂度理论.html.vue"]]),d=JSON.parse(`{"path":"/algo/course/jz/4.%20%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA.html","title":"复杂度理论","lang":"en-US","frontmatter":{"description":"复杂度理论 四个复杂度 时间复杂度 - 核心考察点 空间复杂度 - 次要考察点 编程复杂度 - 能看得懂 思维复杂度 - 能想得出 双指针线性复杂度 但有的时候，很明显的小数据的情况下，可以略微损失一点时间复杂度来降低编程复杂度，提高可读性 时间复杂度 只考虑最高项，不考虑常数项和系数项 O(2N+N2) = O(2^N) O(N3+1000N2) =...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/course/jz/4.%20%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"复杂度理论"}],["meta",{"property":"og:description","content":"复杂度理论 四个复杂度 时间复杂度 - 核心考察点 空间复杂度 - 次要考察点 编程复杂度 - 能看得懂 思维复杂度 - 能想得出 双指针线性复杂度 但有的时候，很明显的小数据的情况下，可以略微损失一点时间复杂度来降低编程复杂度，提高可读性 时间复杂度 只考虑最高项，不考虑常数项和系数项 O(2N+N2) = O(2^N) O(N3+1000N2) =..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-12-17T16:38:04.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-17T16:38:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"复杂度理论\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-17T16:38:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"时间复杂度","slug":"时间复杂度","link":"#时间复杂度","children":[{"level":3,"title":"P 问题 Polynomial","slug":"p-问题-polynomial","link":"#p-问题-polynomial","children":[]},{"level":3,"title":"NP 问题","slug":"np-问题","link":"#np-问题","children":[]}]},{"level":2,"title":"分类","slug":"分类","link":"#分类","children":[]}],"git":{"createdTime":1734453484000,"updatedTime":1734453484000,"contributors":[{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro-3.local","commits":1}]},"readingTime":{"minutes":1.15,"words":345},"filePathRelative":"algo/course/jz/4. 复杂度理论.md","localizedDate":"December 17, 2024","excerpt":"\\n<p>四个复杂度</p>\\n<ol>\\n<li>时间复杂度 - 核心考察点</li>\\n<li>空间复杂度 - 次要考察点</li>\\n<li>编程复杂度 - 能看得懂</li>\\n<li>思维复杂度 - 能想得出</li>\\n</ol>\\n<p>双指针线性复杂度</p>\\n<p>但有的时候，很明显的小数据的情况下，可以略微损失一点时间复杂度来降低编程复杂度，提高可读性</p>\\n<h2>时间复杂度</h2>\\n<p>只考虑最高项，不考虑常数项和系数项</p>\\n<p>O(2<sup>N+N</sup>2) = O(2^N)</p>\\n<p>O(N<sup>3+1000N</sup>2) = O(N^3)</p>\\n","autoDesc":true}`);export{c as comp,d as data};
