import{_ as i,V as l,W as a,a0 as e}from"./framework-705b829b.js";const r={},t=e('<h1 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h1><h2 id="好处" tabindex="-1"><a class="header-anchor" href="#好处" aria-hidden="true">#</a> 好处</h2><p>池化技术：线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h2 id="核心参数" tabindex="-1"><a class="header-anchor" href="#核心参数" aria-hidden="true">#</a> 核心参数</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-02 11.10.58.png" alt="截屏2023-02-02 11.10.58" loading="lazy"></p><h3 id="核心概念" tabindex="-1"><a class="header-anchor" href="#核心概念" aria-hidden="true">#</a> 核心概念</h3><p>线程</p><ul><li>核心线程：运行完任务以后依然保留在线程池当中</li><li>救急线程：运行完任务以后抛弃不保留</li></ul><h3 id="初始参数" tabindex="-1"><a class="header-anchor" href="#初始参数" aria-hidden="true">#</a> 初始参数</h3><ol><li><p>corePoolSize 核心线程树木</p><ul><li>最多<strong>保留</strong>的线程数，可以为0</li></ul></li><li><p>maximumPoolSize最大线程数目</p><ul><li>核心线程 + 救急线程</li></ul></li><li><p>keepAliveTime 生存时间</p><p>针对救急线程，执行完成以后存留的时间的数字，如20，30等</p></li><li><p>unit</p><p>针对救急线程，执行完成以后存留的时间的单位，如秒、毫秒等</p></li><li><p>workQueue 任务队列上限</p><p>阻塞队列</p></li><li><p>threadFactory 线程工厂</p></li><li><p>handler 拒绝策略</p><p>四种，线程池、等待队列、救急线程都满的时候，如何处理</p><ul><li>AbortPolicy，爆异常</li><li>CallerRunsPolicy，调用者自己去运行这个任务</li><li>DiscardPolicy，新加入的丢弃掉</li><li>DiscardOldestPolicy，把任务队列中等待最久的（最先加入队列的）丢弃掉，然后新任务加入进来</li></ul></li></ol><p>核心线程都在忙的时候，放入任务队列，任务队列也满的时候，进入救急线程</p>',14),o=[t];function n(s,p){return l(),a("div",null,o)}const c=i(r,[["render",n],["__file","线程池.html.vue"]]);export{c as default};
