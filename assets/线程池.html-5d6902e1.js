import{_ as t,V as o,W as l,X as n,Y as s,$ as e,Z as p,E as c}from"./framework-e5d7a6b2.js";const i={},u=p(`<h1 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h1><h2 id="好处" tabindex="-1"><a class="header-anchor" href="#好处" aria-hidden="true">#</a> 好处</h2><p>池化技术：线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h2 id="核心参数" tabindex="-1"><a class="header-anchor" href="#核心参数" aria-hidden="true">#</a> 核心参数</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-02 11.10.58.png" alt="截屏2023-02-02 11.10.58" loading="lazy"></p><h3 id="核心概念" tabindex="-1"><a class="header-anchor" href="#核心概念" aria-hidden="true">#</a> 核心概念</h3><p>线程</p><ul><li>核心线程：运行完任务以后依然保留在线程池当中</li><li>救急线程：运行完任务以后抛弃不保留</li></ul><h3 id="初始参数" tabindex="-1"><a class="header-anchor" href="#初始参数" aria-hidden="true">#</a> 初始参数</h3><ol><li><p>corePoolSize 核心线程树木</p><ul><li>最多<strong>保留</strong>的线程数，可以为0</li></ul></li><li><p>maximumPoolSize最大线程数目</p><ul><li>核心线程 + 救急线程</li></ul></li><li><p>keepAliveTime 生存时间</p><p>针对救急线程，执行完成以后存留的时间的数字，如20，30等</p></li><li><p>unit</p><p>针对救急线程，执行完成以后存留的时间的单位，如秒、毫秒等</p></li><li><p>workQueue 任务队列上限</p><p>阻塞队列</p></li><li><p>threadFactory 线程工厂</p></li><li><p>handler 拒绝策略</p><p>四种，线程池、等待队列、救急线程都满的时候，如何处理</p><ul><li>AbortPolicy，爆异常</li><li>CallerRunsPolicy，调用者自己去运行这个任务</li><li>DiscardPolicy，新加入的丢弃掉</li><li>DiscardOldestPolicy，把任务队列中等待最久的（最先加入队列的）丢弃掉，然后新任务加入进来</li></ul></li></ol><p>核心线程都在忙的时候，放入任务队列，任务队列也满的时候，进入救急线程</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CORE_POOL_SIZE</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_POOL_SIZE</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">QUEUE_CAPACITY</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Long</span> <span class="token constant">KEEP_ALIVE_TIME</span> <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span>

<span class="token comment">//使用阿里巴巴推荐的创建线程池的方式</span>
<span class="token comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span>
<span class="token class-name">ThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
        <span class="token constant">CORE_POOL_SIZE</span><span class="token punctuation">,</span>
        <span class="token constant">MAX_POOL_SIZE</span><span class="token punctuation">,</span>
        <span class="token constant">KEEP_ALIVE_TIME</span><span class="token punctuation">,</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token constant">QUEUE_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="执行流程" tabindex="-1"><a class="header-anchor" href="#执行流程" aria-hidden="true">#</a> 执行流程</h2><ol><li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li><li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li><li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li><li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/图解线程池实现原理.png" alt="图解线程池实现原理" loading="lazy"></p><h2 id="阻塞队列" tabindex="-1"><a class="header-anchor" href="#阻塞队列" aria-hidden="true">#</a> 阻塞队列</h2><h3 id="什么是阻塞队列" tabindex="-1"><a class="header-anchor" href="#什么是阻塞队列" aria-hidden="true">#</a> 什么是阻塞队列</h3><p>阻塞队列：从定义上来说是队列的一种，那么肯定是一个先进先出（FIFO）的数据结构。与普通队列不同的是，它支持两个附加操作，即阻塞添加和阻塞删除方法。</p><ul><li>阻塞添加<code>put</code>：当阻塞队列是满时，往队列里添加元素的操作将被阻塞。</li><li>阻塞移除<code>take</code>：当阻塞队列是空时，从队列中获取元素/删除元素的操作将被阻塞。</li></ul><table><thead><tr><th>方法</th><th>抛出异常</th><th>返回结果但不抛出异常</th><th>阻塞</th><th>阻塞特定时间</th></tr></thead><tbody><tr><td>入队</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>出队</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>获取队首元素</td><td>element()</td><td>peek()</td><td>不支持</td><td>不支持</td></tr></tbody></table><h3 id="线程池常用的阻塞队列总结" tabindex="-1"><a class="header-anchor" href="#线程池常用的阻塞队列总结" aria-hidden="true">#</a> 线程池常用的阻塞队列总结</h3><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><p>为什么用阻塞队列：简单的一个场景，消费者一端不一定是时时提交任务就能马上执行，可能有很多因素，比如计算或者IO等资源没办法马上就位，所以有等待，但是任务队列也不一定就无限大，所以才有了阻塞队列，在任务池已满且队列已经有很多任务时，需要阻塞等待。</p><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p><ul><li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</li><li><code>SynchronousQueue</code>（同步队列） ：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li><li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li></ul><h3 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是否有界</p><p>阻塞队列还有一个非常重要的属性，那就是容量的大小，分为有界和无界两种。无界队列意味着里面可以容纳非常多的元素，例如 LinkedBlockingQueue 的上限是 Integer.MAX_VALUE，是非常大的一个数，可以近似认为是无限容量，因为我们几乎无法把这个容量装满。但是有的阻塞队列是有界的，例如 ArrayBlockingQueue 如果容量满了，也不会扩容，所以一旦满了就无法再往里放数据了。</p><p>第 3 个需要考虑的是能否扩容。因为有时我们并不能在初始的时候很好的准确估计队列的大小，因为业务可能有高峰期、低谷期。如果一开始就固定一个容量，可能无法应对所有的情况，也是不合适的，有可能需要动态扩容。如果我们需要动态扩容的话，那么就不能选择 ArrayBlockingQueue ，因为它的容量在创建时就确定了，无法扩容。相反，PriorityBlockingQueue 即使在指定了初始容量之后，后续如果有需要，也可以自动扩容。所以我们可以根据是否需要扩容来选取合适的队列。</p><p>第 4 个需要考虑的点就是内存结构。我们分析过 ArrayBlockingQueue 的源码，看到了它的内部结构是“数组”的形式。和它不同的是，LinkedBlockingQueue 的内部是用链表实现的，所以这里就需要我们考虑到，ArrayBlockingQueue 没有链表所需要的“节点”，空间利用率更高。所以如果我们对性能有要求可以从内存的结构角度去考虑这个问题。</p><p>第 5 点就是从性能的角度去考虑。比如 LinkedBlockingQueue 由于拥有两把锁，它的操作粒度更细，在并发程度高的时候，相对于只有一把锁的 ArrayBlockingQueue 性能会更好。另外，SynchronousQueue 性能往往优于其他实现，因为它只需要“直接传递”，而不需要存储的过程。如果我们的场景需要直接传递的话，可以优先考虑 SynchronousQueue。</p><h3 id="常见阻塞队列" tabindex="-1"><a class="header-anchor" href="#常见阻塞队列" aria-hidden="true">#</a> 常见阻塞队列</h3><p>BlockingQueue 接口的实现类都被放在了 juc 包中，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于take与put操作的原理，却是类似的：</p>`,38),r=n("thead",null,[n("tr",null,[n("th",null,"队列"),n("th",null,"描述")])],-1),d={href:"https://www.cnblogs.com/interdrp/p/17029346.html",target:"_blank",rel:"noopener noreferrer"},k=n("td",null,"基于数组结构实现的一个有界阻塞队列",-1),h={href:"https://www.cnblogs.com/interdrp/p/17029343.html",target:"_blank",rel:"noopener noreferrer"},v=n("td",null,"基于链表结构实现的一个无界阻塞队列，指定容量为有界阻塞队列",-1),m={href:"https://www.cnblogs.com/interdrp/p/17029347.html",target:"_blank",rel:"noopener noreferrer"},b=n("td",null,"支持按优先级排序的无界阻塞队列",-1),g={href:"https://www.cnblogs.com/interdrp/p/17029348.html",target:"_blank",rel:"noopener noreferrer"},y=n("td",null,"基于优先级队列（PriorityBlockingQueue）实现的无界阻塞队列",-1),_={href:"https://www.cnblogs.com/interdrp/p/17029349.html",target:"_blank",rel:"noopener noreferrer"},w=n("td",null,"不存储元素的阻塞队列",-1),f=n("tr",null,[n("td",null,"LinkedTransferQueue"),n("td",null,"基于链表结构实现的一个无界阻塞队列")],-1),E={href:"https://www.cnblogs.com/interdrp/p/17029344.html",target:"_blank",rel:"noopener noreferrer"},x=n("td",null,"基于链表结构实现的一个无界双端阻塞队列，指定容量为有界阻塞队列",-1);function Q(P,A){const a=c("ExternalLinkIcon");return o(),l("div",null,[u,n("table",null,[r,n("tbody",null,[n("tr",null,[n("td",null,[n("a",d,[s("ArrayBlockingQueue"),e(a)])]),k]),n("tr",null,[n("td",null,[n("a",h,[s("LinkedBlockingQueue"),e(a)])]),v]),n("tr",null,[n("td",null,[n("a",m,[s("PriorityBlockingQueue"),e(a)])]),b]),n("tr",null,[n("td",null,[n("a",g,[s("DelayQueue"),e(a)])]),y]),n("tr",null,[n("td",null,[n("a",_,[s("SynchronousQueue"),e(a)])]),w]),f,n("tr",null,[n("td",null,[n("a",E,[s("LinkedBlockingDeque"),e(a)])]),x])])])])}const I=t(i,[["render",Q],["__file","线程池.html.vue"]]);export{I as default};
