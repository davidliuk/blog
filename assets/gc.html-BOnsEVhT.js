import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as n}from"./app-z8Dpj-As.js";const s={};function l(p,e){return n(),a("div",null,e[0]||(e[0]=[t(`<h1 id="garbage-collection" tabindex="-1"><a class="header-anchor" href="#garbage-collection"><span>Garbage Collection</span></a></h1><p>GC要做的有 2 件事，</p><ol><li>找到内存中无用的垃圾对象资源</li><li>清除找到的这些垃圾对象，释放内存给其他对象使用。</li></ol><p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p><h4 id="引用计数" tabindex="-1"><a class="header-anchor" href="#引用计数"><span>引用计数</span></a></h4><p>每一个对象在源码中的结构体表示如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> struct_object {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ob_refcnt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> struct_typeobject </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">ob_type;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} PyObject;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>PyObject 是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少。引用计数为0时，该对象立即被回收，对象占用的内存空间将被释放。</p><p>优点:</p><ul><li>简单</li><li>实时性，一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。</li></ul><p>缺点:</p><ul><li>需要额外的空间维护引用计数。</li><li>不能解决对象的循环引用。(主要缺点)</li></ul><h4 id="标记-清除" tabindex="-1"><a class="header-anchor" href="#标记-清除"><span>标记-清除</span></a></h4><p>标记清除主要是解决循环引用问题。</p><p>标记清除算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。</p><p>它分为两个阶段：</p><ol><li>标记阶段，GC 会把所有的 活动对象 打上标记</li><li>把那些没有标记的对象 非活动对象 进行回收。</li></ol><p>那么 GC 又是如何判断哪些是活动对象哪些是非活动对象的呢？</p><p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。</p><ol><li>根对象就是全局变量、调用栈、寄存器。</li><li>从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。</li></ol><h4 id="分代技术" tabindex="-1"><a class="header-anchor" href="#分代技术"><span>分代技术</span></a></h4><p>分代回收是一种以空间换时间的操作方式。同时，分代回收是建立在标记清除技术基础之上。</p><p>Python 将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python 将内存分为了 3“代”，分别为年轻代（第 0 代）、中年代（第 1 代）、老年代（第 2 代），他们对应的是 3 个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。</p><p>新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python 垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。</p>`,24)]))}const c=i(s,[["render",l],["__file","gc.html.vue"]]),h=JSON.parse(`{"path":"/se/lang/python/gc.html","title":"Garbage Collection","lang":"en-US","frontmatter":{"description":"Garbage Collection GC要做的有 2 件事， 找到内存中无用的垃圾对象资源 清除找到的这些垃圾对象，释放内存给其他对象使用。 Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/se/lang/python/gc.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"Garbage Collection"}],["meta",{"property":"og:description","content":"Garbage Collection GC要做的有 2 件事， 找到内存中无用的垃圾对象资源 清除找到的这些垃圾对象，释放内存给其他对象使用。 Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-22T02:01:32.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-22T02:01:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Garbage Collection\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-22T02:01:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[],"git":{"createdTime":1732240892000,"updatedTime":1732240892000,"contributors":[{"name":"David Liu","email":"liudawei@seas.upenn.edu","commits":1}]},"readingTime":{"minutes":2.6,"words":781},"filePathRelative":"se/lang/python/gc.md","localizedDate":"November 22, 2024","excerpt":"\\n<p>GC要做的有 2 件事，</p>\\n<ol>\\n<li>找到内存中无用的垃圾对象资源</li>\\n<li>清除找到的这些垃圾对象，释放内存给其他对象使用。</li>\\n</ol>\\n<p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p>\\n<h4>引用计数</h4>\\n<p>每一个对象在源码中的结构体表示如下：</p>\\n<div class=\\"language-c line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"c\\" data-title=\\"c\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">typedef</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> struct_object {</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> int</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> ob_refcnt;</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> struct_typeobject </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">*</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">ob_type;</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">} PyObject;</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}`);export{c as comp,h as data};
