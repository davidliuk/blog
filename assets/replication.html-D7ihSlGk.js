import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,a as i,o as s}from"./app-CGXHKXsa.js";const t={};function r(n,e){return s(),l("div",null,e[0]||(e[0]=[i('<h1 id="replication-主从复制" tabindex="-1"><a class="header-anchor" href="#replication-主从复制"><span>Replication 主从复制</span></a></h1><p>主从复制、读写分离</p><h2 id="是什么" tabindex="-1"><a class="header-anchor" href="#是什么"><span>是什么</span></a></h2><p>主负责写，从负责读</p><p>redis 读多写少，所以这样比较有效</p><p>就是主从复制，master以写为主，Slave以读为主</p><p>当master数据变化的时候，自动将新的数据异步同步到其它slave数据库</p><h2 id="能干嘛" tabindex="-1"><a class="header-anchor" href="#能干嘛"><span>能干嘛</span></a></h2><ul><li>读写分离</li><li>容灾恢复</li><li>数据备份</li><li>水平扩容支持高并发</li></ul><h2 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h2><p>配从库不配主库</p><p>权限细节，重要</p><p>基本操作命令</p><h3 id="命令" tabindex="-1"><a class="header-anchor" href="#命令"><span>命令</span></a></h3><ul><li><code>info replication</code> 可以查看复制节点的主从关系</li><li><code>replicaof 主库IP 主库端口</code> （主从复制</li><li><code>slaveof 主库IP 主库端口</code> （改换门庭</li><li><code>slaveof no one</code> 不做从库 （自立为王</li></ul><h2 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程"><span>工作流程</span></a></h2><ol><li>slave 启动，同步初请</li></ol><ul><li>slave 启动成功连接到master后会发送一个sync命令</li><li>slave 首次全新连接 master，一次完全同步（全量复制）将被自动执行，slave自身原有数据会被master数据覆盖清空</li></ul><ol start="2"><li>首次连接，全量复制</li></ol><ul><li>master节点收到<code>sync</code>命令后会开始在<code>BGSAVE</code>后台保存快照（即RDB持久化，主从复制时会触发RDB)，同时收集所有接收到的用于修改数据集命令缓存起来，master节点执行RDB持久化完后，master将rdb快照文件和所有缓存的命令发送到所有slave。以完成一次完全同步</li><li>slave服务在接收到数据库文件数据后，将其存盘并加载到内存中，从而完成复制初始化。</li></ul><ol start="3"><li>心跳持续，保持通信</li></ol><p><code>repl-ping-replica-period 10</code>每10s发一次心跳包</p><ol start="4"><li>进入平稳，增量复制</li></ol><p>Master继续将新的所有收集到的修改命令自动依次传给slave,完成同步</p><ol start="5"><li>从机下线，重连续传</li></ol><p>master会检查backlog里面的offset，master和slave都会保存一个复制的offset还有一个masterId，offset是保存在backlog中的。Master只会把已经复制的offset后面的数据复制给Slave，类似断点续传</p><h2 id="复制原理" tabindex="-1"><a class="header-anchor" href="#复制原理"><span>复制原理</span></a></h2><ul><li>Redis2.8 之前的 SYNC 方案</li><li>Redis2.8 PSYNC 方案</li><li>Redis4.0 PSYNC2.0 方案</li></ul><p>master 为每一个slave单独开辟一块 replication buffer（复制缓存区)来记录RDB文件生成后master收到的所有写命令。</p><p>replication buffer 可以通过下面这些参数来控制，超过指定的阈值后，master就会强制断开对应slave的连接。</p><h3 id="sync-方案" tabindex="-1"><a class="header-anchor" href="#sync-方案"><span>SYNC 方案</span></a></h3><p>通过BGSAVE操作属于重量级操作，会对机器的CPU资源和内存资源产生影响。在生产环境中，我们应该尽量避免在master实例上频繁执行BGSAVE命令。</p><p>除了上面这个问题之外，Redis在2.8版本之前主从复制还存在下面这些迫切需要解决的问题：</p><ul><li>slave加载RDB的过程中不能对外提供读服务。</li><li>slave和master断开连接之后，slave重新连上master需要重新进行全量同步。</li></ul><h3 id="psync" tabindex="-1"><a class="header-anchor" href="#psync"><span>PSYNC</span></a></h3><p>Redis2.8版本SYNC命令被PSYNC取代，PSYNC格式如下（相比较于SYNC命令，多了两个参数)</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" data-title="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">PSYNC</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> replicationid</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> offset</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>PSYNC解决了slave和master断开连接之后需要重新进行全量同步的问题。不过，部分情况（比如slave突然宕机或者被重启）重连之后依然需要进行全量同步。</p><p>具体是怎么解决的呢？原理其实也很简单，slave会记录master的运行id（也就是runid）和自己的复制进度/偏移量（slave_repl_offset)。</p><p>每个Redis节点启动时都有一个40字节随机字符串作为运行id,你可以通过info server命令查看runid的值。</p><p>master也会记录自己写入缓冲区的偏移量（(master_repl_offset),如果runid匹配的话，通过slave_repl_offset和master._repl_offset就可以确认slave缺少的数据是否在缓冲区中以及缺少的具体是哪一部分的数据。</p><p>master如何通过复制偏移量找到slave缺少的数据从而避免全量复制呢？</p><p>master通过一个环形的复制积压缓冲区(repl_backlog_buffer)来记录从生成RDB文件开始收到的所有写命令。一个master中只有一个复制积压缓冲区，master所有的slave共用。</p><h3 id="psync-2-0" tabindex="-1"><a class="header-anchor" href="#psync-2-0"><span>PSYNC 2.0</span></a></h3><h2 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h2><p>复制延迟，信号衰减</p><p>matser 挂了怎么办</p><ul><li>默认情况下，不会在slave节点中自动重选一个master</li><li>那每次都要人工干预？希望可以无人值守自动更换</li></ul><p>如果master宕机的话，从slave中选出一台作为master即可实现故障转移(Failover).。</p><p>类似于MySQL的读写分离，这其实就是一种典型的多副本/备份的思想，经常被用在高可用架构上。</p>',50)]))}const d=a(t,[["render",r],["__file","replication.html.vue"]]),c=JSON.parse(`{"path":"/cs/database/redis/availability/replication.html","title":"Replication 主从复制","lang":"en-US","frontmatter":{"description":"Replication 主从复制 主从复制、读写分离 是什么 主负责写，从负责读 redis 读多写少，所以这样比较有效 就是主从复制，master以写为主，Slave以读为主 当master数据变化的时候，自动将新的数据异步同步到其它slave数据库 能干嘛 读写分离 容灾恢复 数据备份 水平扩容支持高并发 使用 配从库不配主库 权限细节，重要 基本...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/cs/database/redis/availability/replication.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"Replication 主从复制"}],["meta",{"property":"og:description","content":"Replication 主从复制 主从复制、读写分离 是什么 主负责写，从负责读 redis 读多写少，所以这样比较有效 就是主从复制，master以写为主，Slave以读为主 当master数据变化的时候，自动将新的数据异步同步到其它slave数据库 能干嘛 读写分离 容灾恢复 数据备份 水平扩容支持高并发 使用 配从库不配主库 权限细节，重要 基本..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-06-27T01:21:47.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-27T01:21:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Replication 主从复制\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-27T01:21:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"是什么","slug":"是什么","link":"#是什么","children":[]},{"level":2,"title":"能干嘛","slug":"能干嘛","link":"#能干嘛","children":[]},{"level":2,"title":"使用","slug":"使用","link":"#使用","children":[{"level":3,"title":"命令","slug":"命令","link":"#命令","children":[]}]},{"level":2,"title":"工作流程","slug":"工作流程","link":"#工作流程","children":[]},{"level":2,"title":"复制原理","slug":"复制原理","link":"#复制原理","children":[{"level":3,"title":"SYNC 方案","slug":"sync-方案","link":"#sync-方案","children":[]},{"level":3,"title":"PSYNC","slug":"psync","link":"#psync","children":[]},{"level":3,"title":"PSYNC 2.0","slug":"psync-2-0","link":"#psync-2-0","children":[]}]},{"level":2,"title":"缺点","slug":"缺点","link":"#缺点","children":[]}],"git":{"createdTime":1684318252000,"updatedTime":1719451307000,"contributors":[{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":3},{"name":"davidliu","email":"liudawei47@jd.com","commits":1}]},"readingTime":{"minutes":3.96,"words":1188},"filePathRelative":"cs/database/redis/availability/replication.md","localizedDate":"May 17, 2023","excerpt":"\\n<p>主从复制、读写分离</p>\\n<h2>是什么</h2>\\n<p>主负责写，从负责读</p>\\n<p>redis 读多写少，所以这样比较有效</p>\\n<p>就是主从复制，master以写为主，Slave以读为主</p>\\n<p>当master数据变化的时候，自动将新的数据异步同步到其它slave数据库</p>\\n<h2>能干嘛</h2>\\n<ul>\\n<li>读写分离</li>\\n<li>容灾恢复</li>\\n<li>数据备份</li>\\n<li>水平扩容支持高并发</li>\\n</ul>\\n<h2>使用</h2>\\n<p>配从库不配主库</p>\\n<p>权限细节，重要</p>\\n<p>基本操作命令</p>\\n<h3>命令</h3>","autoDesc":true}`);export{d as comp,c as data};
