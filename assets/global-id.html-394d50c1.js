import{_ as i,V as l,W as a,a0 as e}from"./framework-705b829b.js";const d={},p=e('<h1 id="全局id生成器" tabindex="-1"><a class="header-anchor" href="#全局id生成器" aria-hidden="true">#</a> 全局ID生成器</h1><h3 id="数据库自增主键的问题" tabindex="-1"><a class="header-anchor" href="#数据库自增主键的问题" aria-hidden="true">#</a> 数据库自增主键的问题</h3><ul><li>会泄露一些信息，如每天有多少单</li><li>可能会分库分表（分布式存储），如果是数据库的自增主键，那就无法保证iid的唯一性了</li></ul><h3 id="全局id生成器-1" tabindex="-1"><a class="header-anchor" href="#全局id生成器-1" aria-hidden="true">#</a> 全局ID生成器</h3><p>分布式系统下用来生成全局唯一的ID的工具，要满足如下特性：</p><ul><li>唯一性</li><li>高可用：什么时候要id都能给</li><li>高性能</li><li>递增性：</li><li>安全性：为增加安全性，我们加入一些其他信息</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-07 09.48.57.png" alt="截屏2023-02-07 09.48.57" loading="lazy"></p><p>同时还可以有一个统计的效果</p><p>全局唯一ID生存策略：</p><ul><li><p>UUID的缺点：</p><ul><li><p>16进制，字符串结构</p></li><li><p>没有自增性质</p></li></ul></li><li><p>Redis自增</p><p>构造：时间戳+自增id</p><p>每天一个key，方便统计订单量，且防止超</p></li><li><p>snowflake算法</p><p>与我们Redis的实现方案思路类似，但是id自增是机器内部的id的自增，需要维护机器内部的id，分布式系统下比较麻烦，一般还是采用redis的方案</p><p>不依赖于redis，单体的性能会更好</p><p>对于时钟依赖比较高，如果时间不准确会出现问题</p></li><li><p>数据库自增，单独一张表，专门负责做自增，分库分表的地方都从他这里取id</p><p>原理上和redis自增一样，只是性能更差，一般不采用这个，如果使用的话，一般是批量获取id，然后放入内存缓存起来，来提高性能</p></li></ul>',10),r=[p];function s(t,n){return l(),a("div",null,r)}const h=i(d,[["render",s],["__file","global-id.html.vue"]]);export{h as default};
