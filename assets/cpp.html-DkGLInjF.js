import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as t,o as s}from"./app-B3ooTv29.js";const l={};function n(r,e){return s(),a("div",null,e[0]||(e[0]=[t(`<h1 id="c" tabindex="-1"><a class="header-anchor" href="#c"><span>C++</span></a></h1><p>pros</p><ul><li>Runs very fast <ul><li>One of the more scalable modern programming languages</li></ul></li><li>Programmer has fine control over memory usage</li></ul><p>cons</p><ul><li>memory management</li><li>older legacy features</li><li>Compiler errors can sometimes be cryptic</li><li>Difficult for a beginner programmer to learn</li></ul><p><strong>Basic data types</strong></p><p>function</p><ul><li>A function has four main components <ul><li>Return type</li><li>Name</li><li>Inputs</li><li>Body</li></ul></li></ul><p>Compilers</p><ul><li>MSVC compiler for Microsoft Visual Studio (one of the more common C++ IDEs, Windows only)</li><li>GNU Compiler Collection (GCC) works on all UNIX-based systems, including Mac OS</li><li>MinGW is the Windows port of GCC</li><li>The clang compiler for UNIX and Windows</li><li>And more!</li><li>They all have their own idiosyncrasies; we’ll be using the ones provided with Qt installations.</li></ul><p>Compling</p><ul><li>Compiler reads all .cpp files</li><li>All functions are implemented in .cpp files</li><li>Top-down compilation</li></ul><p>Forward declaration</p><ul><li>This code “promises” the<br> compiler that an<br> implementation of <em>twice()</em><br> will be provided later</li><li>Lets the compiler know the<br> function’s inputs and return type</li><li>This <em>will</em> compile, but only<br> because <em>twice()</em> has an<br> implementation.</li><li>What about many forward declarations?</li></ul><p><strong>Header Files</strong></p><ul><li>Collections of forward declarations</li><li>Use #include “name.h” to refer to them</li><li>Declarations for classes, functions, constants, etc.</li><li>Imagine pasting their entire contents in your .cpp file wherever you #include them</li></ul><p><strong>Include Guards</strong></p><ul><li>Avoid compiling the same header more than once <ul><li>#pragma once is the simpler way</li></ul></li><li>Should ALWAYS use include guards</li><li>C++ compiler will throw an error if it finds two functions/classes/structs/etc. with the same name (happens without include guards)</li></ul><p><strong>The C++ Build Model</strong></p><ol><li>Read cpp files <ol><li>Read any included headers before moving to next cpp file</li></ol></li><li>Build OBJ files via compilation</li><li>Link the OBJs into an executable</li></ol><p><strong>C++ Standard Library</strong></p><h3 id="pass" tabindex="-1"><a class="header-anchor" href="#pass"><span>Pass</span></a></h3><p><strong>Pass by copy</strong></p><ul><li>By default, all data passed into a scope is copied in</li><li>In foo(), a is a distinct entity from x; it just happens to also have a value of 10.f</li><li>What are the results of the first and second print statements?</li></ul><p><strong>Pass by reference</strong></p><ul><li>If you want a function to modify memory outside of its scope, you need to pass an object by reference</li><li>Use the &amp; symbol to denote a reference rather than a copy</li><li>Now foo() modifies x since a is a reference to x, not a copy of it</li></ul><p>Ref</p><ul><li>A reference is just a memory address that refers to the location of another variable</li><li>It also knows the type of the variable it refers to, e.g. int &amp;x versus char &amp;y</li><li>The amount of memory a reference takes up is constant, regardless of the variable it refers to (always 64 bits on a 64-bit system, 32 bits on a 32-bit system)</li><li>From our human coder standpoint, it’s an alias for the variable it refers to</li></ul><p><strong>memory usage</strong></p><ul><li>If you pass large variables into functions as references, you save memory stack space</li></ul><p><strong>Reference variables</strong></p><ul><li>References can also be declared outside of a function header</li><li>They behave as aliases of other variables; think of xRef as another name for x in main’s scope</li><li>Depending on where the reference is created, the compiler may in fact optimize it to be an actual alias of a variable (i.e. replace xRef with x when compiled into assembly)</li></ul><p><strong>Const syntax</strong></p><ul><li>Const can be generally used in three categories</li><li>Variable declaration <ul><li>const int x = 10;</li></ul></li><li>Return value <ul><li>const int&amp; operator[](int i);</li></ul></li><li>Functions <ul><li>string getName() const;</li></ul></li></ul><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Node </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">n;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Node </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">n;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Node n;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Node </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="class" tabindex="-1"><a class="header-anchor" href="#class"><span>Class</span></a></h2><p><strong>member</strong></p><ul><li>Class members (variables and functions) can be declared as private, protected, or public</li><li>Private members can only be accessed by instances of the class</li><li>damageEnemy can access the other Monster’s private member variable “health” because damageEnemy is a member function of Monster</li><li>Member privacy exists solely to enforce the scope from which objects can be accessed</li></ul><p><strong>Inheritance</strong></p><ul><li>In object-oriented programming, we can have classes that extend or modify the functionality of some other class</li><li>Square inherits from the Geometry class and has a different implementation of PrintName()</li></ul><p>Virtual functions</p><p><strong>Friend classes</strong></p><ul><li>Sometimes you want some class to be able to access the private and protected members of a separate class, but don’t want to make those members public</li><li>Public would mean all other classes could access them, not this specific one</li><li>Solution: declare it as a friend class!</li></ul><p>Friend function</p><h2 id="memory-model" tabindex="-1"><a class="header-anchor" href="#memory-model"><span>Memory Model</span></a></h2><h3 id="stack" tabindex="-1"><a class="header-anchor" href="#stack"><span><strong>Stack</strong></span></a></h3><ul><li>Stack stores temporary variables <ul><li>Managed efficiently by CPU</li><li>Fast read/write</li></ul></li><li>When a function creates a variable, it gets pushed onto the stack</li><li>When a function exits, all variables created by that function get popped from the stack</li></ul><h3 id="heap" tabindex="-1"><a class="header-anchor" href="#heap"><span>Heap</span></a></h3><ul><li>C++ programs have access to another memory space: The Heap</li><li>Much larger than the stack</li><li>Heap-allocated memory must be freed by its owner <ul><li>Won’t be automatically deleted upon scope exit</li></ul></li><li>How do we store memory on the heap?</li></ul><p><strong>Heap Allocation: Smart Pointers</strong></p><ul><li>C++ provides two standard library classes to help us access heap memory <ul><li>std::unique_ptr</li><li>std::shared_ptr</li></ul></li><li>Store the address of the heap memory they manage</li></ul><h2 id="pointers" tabindex="-1"><a class="header-anchor" href="#pointers"><span>Pointers</span></a></h2><p><strong>Smart Pointers</strong></p><ul><li>Smart pointers “own” the memory to which they point</li><li>A single instance of a unique_ptr can be the only smart pointer that points to its heap memory</li><li>Multiple shared_ptrs can point to the same heap memory, but have more runtime overhead cost</li><li>When heap memory owned by a smart pointer is orphaned, that heap memory is freed automatically</li><li>When a smart pointer points nowhere, its value is nullptr, the modern C++ null value.</li></ul><p><strong>RAII</strong></p><ul><li>std::move is shorthand for “Move the ownership of this heap memory to a new object”</li><li>The new smart pointer <strong>acquires</strong> the heap <strong>resource</strong> and thus becomes the object that should free that memory</li></ul><h3 id="std-unique-ptr" tabindex="-1"><a class="header-anchor" href="#std-unique-ptr"><span><strong>std::unique_ptr</strong></span></a></h3><h3 id="std-shared-ptr" tabindex="-1"><a class="header-anchor" href="#std-shared-ptr"><span><strong>std::shared_ptr</strong></span></a></h3><p><strong>Function Pointers</strong></p><ul><li>Like variables, functions are stored at addresses in your computer’s memory</li><li>If they have locations, we can make pointers to them!</li><li>Why use them? <ul><li>Say you’re trying to make a GUI editor and need to write a Button class</li><li>Rather than making a subclass for every possible button functionality, give the Button a function pointer as a member variable, and invoke that function when the button is clicked!</li></ul></li></ul><p>Virtual function</p><hr>`,62)]))}const c=i(l,[["render",n],["__file","cpp.html.vue"]]),h=JSON.parse(`{"path":"/education/ms/5600/cpp.html","title":"C++","lang":"en-US","frontmatter":{"description":"C++ pros Runs very fast One of the more scalable modern programming languages Programmer has fine control over memory usage cons memory management older legacy features Compiler...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/education/ms/5600/cpp.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"C++"}],["meta",{"property":"og:description","content":"C++ pros Runs very fast One of the more scalable modern programming languages Programmer has fine control over memory usage cons memory management older legacy features Compiler..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-09T03:55:12.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-09T03:55:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C++\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-09T03:55:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":3,"title":"Pass","slug":"pass","link":"#pass","children":[]},{"level":2,"title":"Class","slug":"class","link":"#class","children":[]},{"level":2,"title":"Memory Model","slug":"memory-model","link":"#memory-model","children":[{"level":3,"title":"Stack","slug":"stack","link":"#stack","children":[]},{"level":3,"title":"Heap","slug":"heap","link":"#heap","children":[]}]},{"level":2,"title":"Pointers","slug":"pointers","link":"#pointers","children":[{"level":3,"title":"std::unique_ptr","slug":"std-unique-ptr","link":"#std-unique-ptr","children":[]},{"level":3,"title":"std::shared_ptr","slug":"std-shared-ptr","link":"#std-shared-ptr","children":[]}]}],"git":{"createdTime":1725612282000,"updatedTime":1731124512000,"contributors":[{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro-3.local","commits":1}]},"readingTime":{"minutes":3.4,"words":1019},"filePathRelative":"education/ms/5600/cpp.md","localizedDate":"September 6, 2024","excerpt":"\\n<p>pros</p>\\n<ul>\\n<li>Runs very fast\\n<ul>\\n<li>One of the more scalable modern programming languages</li>\\n</ul>\\n</li>\\n<li>Programmer has fine control over memory usage</li>\\n</ul>\\n<p>cons</p>\\n<ul>\\n<li>memory management</li>\\n<li>older legacy features</li>\\n<li>Compiler errors can sometimes be cryptic</li>\\n<li>Difficult for a beginner programmer to learn</li>\\n</ul>","autoDesc":true}`);export{c as comp,h as data};
