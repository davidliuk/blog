import{_ as a,V as e,W as i,Z as r}from"./framework-e5d7a6b2.js";const d={},n=r(`<h1 id="aof" tabindex="-1"><a class="header-anchor" href="#aof" aria-hidden="true">#</a> AOF</h1><p>Append Only File (追加文件）。</p><h2 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h2><h3 id="写后日志" tabindex="-1"><a class="header-anchor" href="#写后日志" aria-hidden="true">#</a> 写后日志</h3><p>说到日志，我们比较熟悉的是数据库的redo log写前日志（Write Ahead Log, WAL），也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。</p><p>不过，AOF 日志正好相反，它是写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志，如下图所示：</p><p>那 AOF 为什么要先执行命令再记日志呢？要回答这个问题，我们要先知道 AOF 里记录了什么内容。</p><ul><li>可以避免出现记录错误命令的情况。</li><li>它是在命令执行后才记录日志，所以不会阻塞当前的写操作。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/28afd536c57a46447ddab0a2062abe84.png" alt="img" loading="lazy"></p><h3 id="写回策略" tabindex="-1"><a class="header-anchor" href="#写回策略" aria-hidden="true">#</a> 写回策略</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-16 20.40.43.png" alt="截屏2023-02-16 20.40.43" loading="lazy"></p><ul><li><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li><li><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li><li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li></ul><h3 id="冗余记录" tabindex="-1"><a class="header-anchor" href="#冗余记录" aria-hidden="true">#</a> 冗余记录</h3><p>文件占用体积比RDB大得多。</p><p>解决方案：bgrewriteaof命令，可以让aof重写，只需要最少的内容即可达到一样的效果</p><p>重写触发时机设置：</p><div class="language-conf line-numbers-mode" data-ext="conf"><pre class="language-conf"><code>auto-aof-rewrite-percentage
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,17),s=[n];function t(l,o){return e(),i("div",null,s)}const h=a(d,[["render",t],["__file","AOF.html.vue"]]);export{h as default};
