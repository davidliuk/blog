import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as l}from"./app-BBRqDuqm.js";const e={};function t(h,i){return l(),a("div",null,i[0]||(i[0]=[n(`<h1 id="bfs" tabindex="-1"><a class="header-anchor" href="#bfs"><span>BFS</span></a></h1><p>分类</p><ul><li><p>狭义 BFS：Breadth-first search (BFS)</p><p>结点只能入队一次</p></li><li><p>扩展 BFS：Best-first search (BeFS)</p><p>结点可以入队多次（根据规则）</p></li></ul><p>如果可以预先计算出每个节点到终点的距离，则可以利用这个信息更快的到达终点。</p><p>其原理与 Dijkstra 算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法。</p><h3 id="bfs-实现" tabindex="-1"><a class="header-anchor" href="#bfs-实现"><span>BFS 实现</span></a></h3><p>常见有三种写法：</p><ul><li>dummy、</li><li>BiQueue 双队列</li><li>Queue 单队列</li></ul><h2 id="高频考法" tabindex="-1"><a class="header-anchor" href="#高频考法"><span>高频考法</span></a></h2><ol><li>连通块问题</li><li>分层遍历</li><li>拓扑排序</li></ol><h3 id="连通块问题" tabindex="-1"><a class="header-anchor" href="#连通块问题"><span>连通块问题</span></a></h3><ul><li><p>通过图中一个点找到其他所有连通的点</p></li><li><p>找到所有方案问题的一种非递归实现方式</p><p>DFS vs BFS 在连通块问题上的优劣</p></li></ul><h3 id="分层遍历" tabindex="-1"><a class="header-anchor" href="#分层遍历"><span>分层遍历</span></a></h3><ul><li><p>图的层级遍历</p><p>一层一层的遍历一个图、树、矩阵</p></li><li><p>无权图图最短路径问题</p><ul><li><p>简单图：只有权值都一样，或者说是无权图</p><p>简单图中，层级=最短路</p><p>简单图中：第几层访问到该节点=到达该节点的最短路径</p></li><li><p>复杂图最短路径有什么算法</p><p>SPFA、Dijkstra</p><p>复杂图中：我可能通过三层访问到比通过两层访问到的路径更短</p></li><li><p>最长路径用什么算法</p></li><li><p>什么是隐式图</p></li><li><p>通用的 BFS 模板</p></li><li><p>80%的人都会写错的 BFS 写法</p></li></ul></li></ul><h3 id="拓扑排序" tabindex="-1"><a class="header-anchor" href="#拓扑排序"><span>拓扑排序</span></a></h3><ul><li><p>DFS vs BFS 在拓扑排序上的优劣</p><p>实现容易度远超过 DFS</p></li><li><p>拓扑排序的五个考点</p><ul><li>问有没有拓扑排序</li><li>求任意一个拓扑排序</li><li>求最小的拓扑排序</li><li>求拓扑排序是否唯一</li></ul></li></ul><hr><p>原则：能 BFS 的别 DFS(除非面试官特别要求)</p><p>（其实连通块问题用 dfs 写起来又短又快，且效率往往更高）</p><ul><li>Recursion 版本的 DFS 有 StackOverflow 的风险</li><li>Non-Recursion 版本的 DFS 容易错+面试官未必看得懂</li></ul><h2 id="模版" tabindex="-1"><a class="header-anchor" href="#模版"><span>模版</span></a></h2><h3 id="bfs-1" tabindex="-1"><a class="header-anchor" href="#bfs-1"><span>BFS</span></a></h3><p>屡试不爽的 BFS 代码模板，刷题效率直接翻倍</p><p>应该在哪里做访问标记？入队之前标记 visited/distance 防止重复入队</p><p>矩阵坐标变换数组（如果是矩阵坐标 visited 可以不必 hashmap，二维数组即可）</p><ul><li>deltaX, deltaY</li><li>inBound / isValid</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ReturnType</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> bfs</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Node</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> startNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> [</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Node</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> endNode]) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Queue</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Node</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> queue </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayDeque</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // hashmap 两个作用，一个是记录一个点是否被丢进过队列了，避免重复访问</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 另外一个是记录 startNode 到其他所有节点的最短距离</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 如果只求连通性的话，可以换成 HashSet 就行</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // node 做 key 的时候比较的是内存地址</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 如果是二维坐标可以用二维数组来记录</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Node</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> distance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 把起点放进队列和哈希表里，如果有多个起点，都放进去</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">offer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(startNode);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    distance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(startNode, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // or 1  if necessary</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // while 队列不空，不停的从队列里拿出一个点，拓展邻居节点放到队列中</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">isEmpty</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> node </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">poll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 遍历点的时候，出队后更新</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 如果有明确的终点可以在这里加终点的判断</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (node is endNode) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        	break</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> or </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> something</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> neighbor </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getNeighbors</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">distance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">containsKey</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(neighbor)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            	continue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 若不满足条件，跳过</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 这里可以判断边和点的条件</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isValid</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(neighbor)) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	            continue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            }</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">offer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(neighbor);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 遍历边的时候，入队前更新</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 遍历点的时候也可以，但是建议上面</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 防止重复入队/访问，同时记录层次信息</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            distance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(neighbor, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">distance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(node) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 如果带要返回所有点离起点的距离，就 return hashmap</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> distance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 如果需要返回所有连通的节点，就 return HashMap 里的所有点</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> distance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">keySet</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 如果需要返回离终点的最短距离</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> distance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(endNode);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="befs" tabindex="-1"><a class="header-anchor" href="#befs"><span>BeFS</span></a></h3><div class="language-pseudocode line-numbers-mode" data-highlighter="shiki" data-ext="pseudocode" data-title="pseudocode" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Best-First-Search(Graph g, Node start)</span></span>
<span class="line"><span>    1) Create an empty PriorityQueue</span></span>
<span class="line"><span>       PriorityQueue pq;</span></span>
<span class="line"><span>    2) Insert &quot;start&quot; in pq.</span></span>
<span class="line"><span>       pq.insert(start)</span></span>
<span class="line"><span>    3) Until PriorityQueue is empty</span></span>
<span class="line"><span>          u = PriorityQueue.DeleteMin</span></span>
<span class="line"><span>          If u is the goal</span></span>
<span class="line"><span>             Exit</span></span>
<span class="line"><span>          Else</span></span>
<span class="line"><span>             Foreach neighbor v of u</span></span>
<span class="line"><span>                If v &quot;Unvisited&quot;</span></span>
<span class="line"><span>                    Mark v &quot;Visited&quot;                    </span></span>
<span class="line"><span>                    pq.insert(v)</span></span>
<span class="line"><span>             Mark u &quot;Examined&quot;                    </span></span>
<span class="line"><span>End procedure</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="例题" tabindex="-1"><a class="header-anchor" href="#例题"><span>例题</span></a></h2><p>实际面试围绕 BFS 所涉及算法和数据结构</p><p>二叉树<br> 拓扑排序算法<br> 堆<br> 宽度优先搜素<br> 深度优先搜索<br> 动态规划<br> 字符串处理</p><hr><p>搞定 BFS 知识点，你可以刷这些高频题</p><ul><li>二叉树的层次遍历 I, II</li><li>二叉树的最大深度</li><li>二叉树的右视图</li><li>克隆图</li><li>岛屿的个数</li><li>单词接龙 I, II</li><li>墙和门</li><li>拓扑排序</li><li>外星人字典</li></ul><p>样例，每个题做完相当于啃下 3-5 道类似题</p><h2 id="进阶" tabindex="-1"><a class="header-anchor" href="#进阶"><span>进阶</span></a></h2><ul><li><p>BFS 解决最短路径问题时可能产生的各类变化</p></li><li><p>宽度优先搜索代码模板</p></li><li><p>BFS 两种实现方式</p><ul><li>在不同情况下各自的优劣对比</li></ul></li><li><p>图的邻接表(Adjacency List)存储方法</p></li><li><p>使用 SPFA 算法解决复杂图最短路径问题</p></li><li><p>双向宽度优先搜索代码模板</p></li><li><p>双向宽度优先搜索到底带来多大的优化?</p></li><li><p>如何记录 BFS 求出的最短路径的具体方案</p></li></ul>`,38)]))}const d=s(e,[["render",t],["__file","index.html.vue"]]),r=JSON.parse(`{"path":"/algo/patterns/search/BFS/","title":"BFS","lang":"en-US","frontmatter":{"description":"BFS 分类 狭义 BFS：Breadth-first search (BFS) 结点只能入队一次 扩展 BFS：Best-first search (BeFS) 结点可以入队多次（根据规则） 如果可以预先计算出每个节点到终点的距离，则可以利用这个信息更快的到达终点。 其原理与 Dijkstra 算法类似，我们也使用一个优先队列，但此时以每个节点到达终...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/patterns/search/BFS/"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"BFS"}],["meta",{"property":"og:description","content":"BFS 分类 狭义 BFS：Breadth-first search (BFS) 结点只能入队一次 扩展 BFS：Best-first search (BeFS) 结点可以入队多次（根据规则） 如果可以预先计算出每个节点到终点的距离，则可以利用这个信息更快的到达终点。 其原理与 Dijkstra 算法类似，我们也使用一个优先队列，但此时以每个节点到达终..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-12-02T20:14:33.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-02T20:14:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"BFS\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-02T20:14:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":3,"title":"BFS 实现","slug":"bfs-实现","link":"#bfs-实现","children":[]},{"level":2,"title":"高频考法","slug":"高频考法","link":"#高频考法","children":[{"level":3,"title":"连通块问题","slug":"连通块问题","link":"#连通块问题","children":[]},{"level":3,"title":"分层遍历","slug":"分层遍历","link":"#分层遍历","children":[]},{"level":3,"title":"拓扑排序","slug":"拓扑排序","link":"#拓扑排序","children":[]}]},{"level":2,"title":"模版","slug":"模版","link":"#模版","children":[{"level":3,"title":"BFS","slug":"bfs-1","link":"#bfs-1","children":[]},{"level":3,"title":"BeFS","slug":"befs","link":"#befs","children":[]}]},{"level":2,"title":"例题","slug":"例题","link":"#例题","children":[]},{"level":2,"title":"进阶","slug":"进阶","link":"#进阶","children":[]}],"git":{"createdTime":1732244737000,"updatedTime":1764706473000,"contributors":[{"name":"David Liu","email":"davidliu02k@gmail.com","commits":1}]},"readingTime":{"minutes":4.35,"words":1306},"filePathRelative":"algo/patterns/search/BFS/README.md","localizedDate":"November 22, 2024","excerpt":"\\n<p>分类</p>\\n<ul>\\n<li>\\n<p>狭义 BFS：Breadth-first search (BFS)</p>\\n<p>结点只能入队一次</p>\\n</li>\\n<li>\\n<p>扩展 BFS：Best-first search (BeFS)</p>\\n<p>结点可以入队多次（根据规则）</p>\\n</li>\\n</ul>\\n<p>如果可以预先计算出每个节点到终点的距离，则可以利用这个信息更快的到达终点。</p>\\n<p>其原理与 Dijkstra 算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法。</p>","autoDesc":true}`);export{d as comp,r as data};
