const e=JSON.parse(`{"key":"v-7bfe9bda","path":"/se/lang/java/JUC/aqs/","title":"AQS","lang":"en-US","frontmatter":{"description":"AQS AQS 核心思想是： 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。 如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 CLH 锁 （Craig, Landin, and Hagersten locks） 实现的。 CLH 锁 CLH 锁是对自旋锁的一种改进，解决了自旋锁的两个缺点改进如下： 饥饿问题：将线程组织成一个队列，保证先请求的线程先获得锁，避免了饥饿问题。 锁状态去中心化，让每个线程在不同的状态变量中自旋，相当于减小锁的粒度，这样当一个线程释放它的锁时，只能使其后续线程的高速缓存失效，缩小了影响范围，从而减少了 CPU 的开销。","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/se/lang/java/JUC/aqs/"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"AQS"}],["meta",{"property":"og:description","content":"AQS AQS 核心思想是： 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。 如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 CLH 锁 （Craig, Landin, and Hagersten locks） 实现的。 CLH 锁 CLH 锁是对自旋锁的一种改进，解决了自旋锁的两个缺点改进如下： 饥饿问题：将线程组织成一个队列，保证先请求的线程先获得锁，避免了饥饿问题。 锁状态去中心化，让每个线程在不同的状态变量中自旋，相当于减小锁的粒度，这样当一个线程释放它的锁时，只能使其后续线程的高速缓存失效，缩小了影响范围，从而减少了 CPU 的开销。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-03-29T11:46:59.000Z"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2023-03-29T11:46:59.000Z"}],["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://davidliuk.github.io/blog/blog/zh/se/lang/java/JUC/aqs/"}]]},"headers":[{"level":3,"title":"CLH 锁","slug":"clh-锁","link":"#clh-锁","children":[]},{"level":3,"title":"AQS 使用了模板方法模式","slug":"aqs-使用了模板方法模式","link":"#aqs-使用了模板方法模式","children":[]}],"git":{"createdTime":1680090419000,"updatedTime":1680090419000,"contributors":[{"name":"davidliuk","email":"l729641074@163.com","commits":1}]},"readingTime":{"minutes":2.13,"words":638},"localizedDate":"March 29, 2023","filePathRelative":"se/lang/java/JUC/aqs/README.md","excerpt":"<h1> AQS</h1>\\n<p>AQS 核心思想是：</p>\\n<ul>\\n<li>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</li>\\n<li>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 <strong>CLH 锁</strong> （Craig, Landin, and Hagersten locks） 实现的。</li>\\n</ul>\\n<h3> CLH 锁</h3>\\n<p>CLH 锁是对自旋锁的一种改进，解决了自旋锁的两个缺点改进如下：</p>\\n<ul>\\n<li>饥饿问题：将线程组织成一个队列，保证先请求的线程先获得锁，避免了饥饿问题。</li>\\n<li>锁状态去中心化，让每个线程在不同的状态变量中自旋，相当于减小锁的粒度，这样当一个线程释放它的锁时，只能使其后续线程的高速缓存失效，缩小了影响范围，从而减少了 CPU 的开销。</li>\\n</ul>","autoDesc":true}`);export{e as data};
