import{_ as e,V as a,W as t,a0 as r}from"./framework-705b829b.js";const l={},i=r('<h1 id="collection-接口" tabindex="-1"><a class="header-anchor" href="#collection-接口" aria-hidden="true">#</a> Collection 接口</h1><h2 id="list-接口" tabindex="-1"><a class="header-anchor" href="#list-接口" aria-hidden="true">#</a> List 接口</h2><ul><li>ArrayList</li><li>Vector</li><li>LinkedList</li></ul><h2 id="set-接口" tabindex="-1"><a class="header-anchor" href="#set-接口" aria-hidden="true">#</a> Set 接口</h2><h3 id="comparable-和-comparator-的区别" tabindex="-1"><a class="header-anchor" href="#comparable-和-comparator-的区别" aria-hidden="true">#</a> comparable 和 Comparator 的区别</h3><ul><li>comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用 来排序</li><li>comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2) 方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写 compareTo() 方法或 compare() 方法， 当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序 方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort() .</p><h3 id="无序性和不可重复性" tabindex="-1"><a class="header-anchor" href="#无序性和不可重复性" aria-hidden="true">#</a> 无序性和不可重复性</h3><ol><li>什么是无序性?无序性不等于随机性，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li><li>什么是不可重复性?不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</li></ol><h3 id="比较-hashset、linkedhashset-和-treeset-三者的异同" tabindex="-1"><a class="header-anchor" href="#比较-hashset、linkedhashset-和-treeset-三者的异同" aria-hidden="true">#</a> 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul><li>HashSet 是 Set 接口的主要实现类 ，HashSet 的底层是 HashMap，线程不安全的，可以存储 null 值;</li><li>LinkedHashSet 是 HashSet 的子类，能够按照添加的顺序遍历;</li><li>TreeSet 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</li></ul>',11),o=[i];function h(s,c){return a(),t("div",null,o)}const d=e(l,[["render",h],["__file","collection.html.vue"]]);export{d as default};
