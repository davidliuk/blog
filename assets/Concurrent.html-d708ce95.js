import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as r,d as n}from"./app-9107e99b.js";const i={},t=n('<h1 id="并发容器" tabindex="-1"><a class="header-anchor" href="#并发容器" aria-hidden="true">#</a> 并发容器</h1><ul><li><strong><code>ConcurrentHashMap</code></strong> : 线程安全的 <code>HashMap</code></li><li><strong><code>CopyOnWriteArrayList</code></strong> : 线程安全的 <code>List</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>。</li><li><strong><code>ConcurrentLinkedQueue</code></strong> : 高效的并发队列，使用链表实现。可以看做一个线程安全的 <code>LinkedList</code>，这是一个非阻塞队列。</li><li><strong><code>BlockingQueue</code></strong> : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li><li><strong><code>ConcurrentSkipListMap</code></strong> : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</li></ul><h2 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h2><h3 id="concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap" aria-hidden="true">#</a> ConcurrentHashMap</h3><h4 id="java-8" tabindex="-1"><a class="header-anchor" href="#java-8" aria-hidden="true">#</a> Java 8</h4><p>对 Node 加锁。</p><p>Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><h5 id="inittable" tabindex="-1"><a class="header-anchor" href="#inittable" aria-hidden="true">#</a> initTable</h5><p>从源码中可以发现 <code>ConcurrentHashMap</code> 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p><ol><li>-1 说明正在初始化</li><li>-N 说明有 N-1 个线程正在进行扩容</li><li>0 表示 table 初始化大小，如果 table 没有初始化</li><li>&gt;0 表示 table 扩容的阈值，如果 table 已经初始化。</li></ol><h4 id="java-7" tabindex="-1"><a class="header-anchor" href="#java-7" aria-hidden="true">#</a> Java 7</h4><p>Java7 中 <code>ConcurrentHashMap</code> 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 <code>Segment</code> 都是一个类似 <code>HashMap</code> 数组的结构，它可以扩容，它的冲突会转化为链表。但是 <code>Segment</code> 的个数一但初始化就不能改变。</p><h4 id="hashtable-vs-concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#hashtable-vs-concurrenthashmap" aria-hidden="true">#</a> HashTable vs ConcurrentHashMap</h4><p>共同点：HashTable 与 ConcurrentHashMap 都是线程安全的 Map 集合</p><p>不同点：</p><ul><li><p>HashTable 并发度低，整个 HashTable 对应一把锁，只能有一个线程操作它</p></li><li><p>1.8 之前 ConcurrentHashMap 使用了 Segment + 数组 + 链表，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突</p></li><li><p>1.8 开始 ConcurrentHashMap 将数组的每个头节点作为锁（这个时候结构也是数组加链表或红黑树），如果多个线程访问的头节点不同，则不会冲突。</p></li></ul><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h4><p>ConcurrentHashMap 是 Java 中线程安全的哈希表实现，常用于以下场景：</p><ol><li><p>高并发场景：ConcurrentHashMap 支持高并发的读写操作，可以在多线程环境下保证数据的一致性和线程安全性。</p></li><li><p>缓存场景：ConcurrentHashMap 可以用于缓存数据，提高数据的访问速度和响应速度。</p></li><li><p>分布式场景：ConcurrentHashMap 可以用于分布式环境下的数据共享和同步，例如多个节点之间共享数据、同步数据等。</p></li><li><p>数据统计场景：ConcurrentHashMap 可以用于数据统计，例如统计网站的访问量、用户的在线时长等。</p></li></ol><p>总的来说，ConcurrentHashMap 适用于多线程环境下的高并发场景，可以用于缓存、分布式、数据统计等场景。需要注意的是，ConcurrentHashMap 虽然是线程安全的，但是在使用时需要注意一些细节，例如避免死锁、避免竞争等问题。</p><h3 id="concurrentskiplistmap" tabindex="-1"><a class="header-anchor" href="#concurrentskiplistmap" aria-hidden="true">#</a> ConcurrentSkipListMap</h3><h3 id="线程安全的使用" tabindex="-1"><a class="header-anchor" href="#线程安全的使用" aria-hidden="true">#</a> 线程安全的使用</h3><p>使用 Colletcions 这个工具类 syn 方法类创建个线程安全的 set.</p><p><code>Set&lt;String&gt; synSet = Collections.synchronizedSet(new HashSet&lt;&gt;())</code></p><p>实现比较粗暴，就是在每个方法前加 synchronized</p><h2 id="collection" tabindex="-1"><a class="header-anchor" href="#collection" aria-hidden="true">#</a> Collection</h2><h3 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h3><p><strong><code>CopyOnWriteArraySet</code></strong></p><h3 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h3><h4 id="copyonwritearraylist" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist" aria-hidden="true">#</a> CopyOnWriteArrayList</h4><h3 id="blockingqueue" tabindex="-1"><a class="header-anchor" href="#blockingqueue" aria-hidden="true">#</a> BlockingQueue</h3><ul><li><code>ArrayBlockingQueue</code>、</li><li><code>LinkedBlockingQueue</code>、</li><li><code>PriorityBlockingQueue</code></li></ul><p>blocked queue 双向链表</p><p>waiting queue 单向链表，0-多个</p><p>在等待队列里面的线程获取锁是有顺序的，外面的线程就是无序的可以直接插队先执行</p><p>tryLock(时间)这种会尊从创建锁的时候的公平非公平</p><p>无参的 tryLock，不管创建的锁是什么样，他都是非公平执行</p><h4 id="条件变量-condition" tabindex="-1"><a class="header-anchor" href="#条件变量-condition" aria-hidden="true">#</a> 条件变量 Condition</h4><p>然后就会进入等待队列</p><ul><li>notEmpty</li><li>notFull</li></ul><p>Lock 唤醒 waiting queue 的线程时，会放入 block queue 的尾部</p><p>synchronized 唤醒 waiting queue 的线程时，到 blockde queue 中优先级更高一些</p>',42),o=[t];function c(d,h){return a(),r("div",null,o)}const p=e(i,[["render",c],["__file","Concurrent.html.vue"]]);export{p as default};
