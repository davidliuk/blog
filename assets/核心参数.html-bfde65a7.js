import{_ as l,V as i,W as e,a0 as p}from"./framework-705b829b.js";const o={},a=p('<h1 id="核心参数" tabindex="-1"><a class="header-anchor" href="#核心参数" aria-hidden="true">#</a> 核心参数</h1><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-02 11.10.58.png" alt="截屏2023-02-02 11.10.58" loading="lazy"></p><p>线程</p><ul><li>核心线程：运行完任务以后依然保留在线程池当中</li><li>救急线程：运行完任务以后抛弃不保留</li></ul><p>参数</p><ol><li><p>corePoolSize 核心线程树木</p><ul><li>最多<strong>保留</strong>的线程数，可以为0</li></ul></li><li><p>maximumPoolSize最大线程数目</p><ul><li>核心线程 + 救急线程</li></ul></li><li><p>keepAliveTime 生存时间</p><p>针对救急线程，执行完成以后存留的时间的数字，如20，30等</p></li><li><p>unit</p><p>针对救急线程，执行完成以后存留的时间的单位，如秒、毫秒等</p></li><li><p>workQueue 任务队列上限</p><p>阻塞队列</p></li><li><p>threadFactory 线程工厂</p></li><li><p>handler 拒绝策略</p><p>四种，线程池、等待队列、救急线程都满的时候，如何处理</p><ul><li>AbortPolicy，爆异常</li><li>CallerRunsPolicy，调用者自己去运行这个任务</li><li>DiscardPolicy，新加入的丢弃掉</li><li>DiscardOldestPolicy，把任务队列中等待最久的（最先加入队列的）丢弃掉，然后新任务加入进来</li></ul></li></ol><p>核心线程都在忙的时候，放入任务队列，任务队列也满的时候，进入救急线程</p>',7),t=[a];function c(r,n){return i(),e("div",null,t)}const u=l(o,[["render",c],["__file","核心参数.html.vue"]]);export{u as default};
