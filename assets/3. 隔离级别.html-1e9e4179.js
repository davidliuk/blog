import{_ as n,V as a,W as s,Z as e}from"./framework-e5d7a6b2.js";const o={},l=e(`<h1 id="隔离级别" tabindex="-1"><a class="header-anchor" href="#隔离级别" aria-hidden="true">#</a> 隔离级别</h1><p>目的：解决并发事务问题</p><p>事务隔离级别</p><ul><li><p>RU：事务提交前，就可被其他事务读取到</p></li><li><p>RC：事务提交后，才能被其他事务读取到</p></li><li><p>RR：</p><p>InnoDB 在 RR 下利用 Read View 和锁很大程度上解决了幻读问题</p></li><li><p>Serializable：</p><p>Serialized 把幻读解决了</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/截屏2023-03-04 12.49.05.png" alt="截屏2023-03-04 12.49.05"></p><p>从上往下安全性越来越好，性能越来越低</p><ul><li>MySQL 默认 RR</li><li>oracle, SQL server 默认 RC</li></ul><p>设置</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 查看事务隔离级别</span>
<span class="token keyword">select</span> @<span class="token variable">@transaction_isolation</span><span class="token punctuation">;</span>

<span class="token comment">-- 设置事务隔离级别</span>
<span class="token keyword">set</span> <span class="token punctuation">[</span><span class="token keyword">session</span><span class="token operator">|</span><span class="token keyword">global</span><span class="token punctuation">]</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> {<span class="token keyword">read</span> <span class="token keyword">uncommitted</span> <span class="token operator">|</span> <span class="token keyword">read</span> commited <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="innodb-rr-级别下避免幻读的方式" tabindex="-1"><a class="header-anchor" href="#innodb-rr-级别下避免幻读的方式" aria-hidden="true">#</a> InnoDB RR 级别下避免幻读的方式</h3><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select ... for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><h3 id="解决幻读的方式" tabindex="-1"><a class="header-anchor" href="#解决幻读的方式" aria-hidden="true">#</a> 解决幻读的方式</h3><p>解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。解决幻读的方式主要有以下几种：</p><ol><li>将事务隔离级别调整为 <code>SERIALIZABLE</code> 。</li><li>在可重复读的事务级别下，给事务操作的这张表添加表锁。</li><li>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-key Lock（Record Lock+Gap Lock）</code>。</li></ol><h3 id="innodb-rr-级别下出现幻读的情况" tabindex="-1"><a class="header-anchor" href="#innodb-rr-级别下出现幻读的情况" aria-hidden="true">#</a> InnoDB RR 级别下出现幻读的情况</h3>`,16),t=[l];function i(r,p){return a(),s("div",null,t)}const d=n(o,[["render",i],["__file","3. 隔离级别.html.vue"]]);export{d as default};
