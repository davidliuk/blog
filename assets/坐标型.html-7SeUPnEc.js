import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as i,o as c}from"./app-DQpqR3jB.js";const d={};function a(t,e){return c(),o("div",null,e[0]||(e[0]=[i('<h1 id="坐标型" tabindex="-1"><a class="header-anchor" href="#坐标型"><span>坐标型</span></a></h1><p>状态：<code>f[i]</code>表示以<code>a[i]</code>为<strong>结尾</strong>的子序列的某种性质</p><p>边界：<code>f[0]</code>就是以<code>a[0]</code>为结尾的子序列的性质（没法从前面推导）</p><p>本质上是找一个以i结尾的路径（子序列）</p><p>给定一个序列或网格，需要找到序列中某个/些子序列或网格中的某条路径的性质</p><p>坐标型动态规划的初始条件f[0]就是指以a[0]为结尾的子序列的性质</p><p>状态i表示以a为结尾的满足条件的子序列的性质</p><p><code>f[i][j]</code>中的下标，表示以格子<code>(i,j)</code>为结尾的满足条件的路径的性质</p><ul><li>最大值/最小值</li><li>个数</li><li>是否存在</li></ul><h2 id="一维型" tabindex="-1"><a class="header-anchor" href="#一维型"><span>一维型</span></a></h2><p>fibonacci 数列</p><p>状态：<code>f[i]</code>表示第i个fib数列的值（也是一个小序列自己及前面两个得到）</p><p>转移：<code>f[i]=f[i-1]+f[i-2]</code></p><p>边界：<code>f[0]=0,f[1]=1</code></p><hr><p>Jump Game 跳跃游戏</p><blockquote><p>从0是否可以跳到n-1</p></blockquote><p>状态：<code>f[i]</code>表示可以跳到坐标i</p><p>转移：<code>f[i]=or{f[j]|j+nums[j]&gt;=i}</code></p><p>边界：<code>f[0]=true</code></p><p>答案：<code>f[n-1]</code></p><hr><p>Jump Game II 跳跃游戏II</p><blockquote><p>问一开始站在 index=0 一直向右跳<strong>最少</strong>跳几次跳到 index = n-1</p></blockquote><p>状态：<code>f[i]</code>表示跳到坐标i最小步数</p><p>转移：<code>f[i]=min{f[j]|j+nums[j]&gt;=i}+1</code></p><p>边界：<code>f[0]=0</code></p><p>答案：<code>f[n-1]</code></p><hr><p>打家劫舍</p><blockquote><p>如果用坐标型，这样写，边界不好搞有问题，但是如果用滚动数组还行</p></blockquote><p>状态：<code>f[i]</code>表示抢i的最大值</p><p>转移：<code>f[i]=a[i] + max{f[i-2], f[i-3]}</code></p><p>边界：<code>f[0]=a[0],f[1]=a[1],f[2]=a[0]+a[2]</code></p><p>答案：<code>max{f[n-1],f[n-2]}</code></p><p>不然可以多加边界判断</p><hr><p>Bomb Enemy</p><p>暴力：Omnm</p><p>四周方向各dp一次，就是朝各个方向求炸的个数，然后结果就是遍历一遍二维数组和最大的，Omn</p><h3 id="约束" tabindex="-1"><a class="header-anchor" href="#约束"><span>约束</span></a></h3><p>老鼠跳跃 Rat Jump (LintCode 1861)</p><blockquote><p>给定一个长n数组A，一个老鼠可以从A[0]开始跳，第奇数次跳可以跳1,2,4个单位，第偶数次跳可以跳1,3,4个单位。A[i]或者是0或者1，是1的时候表示该位置有胶水，一旦跳到有胶水的地方，就不能继续跳。问它有多少方式可以跳到A[n-1]或者更右边的位置。A[n-1]有胶水没关系。答案对10^9 +7取模。</p><p>坐标型+状态型（需要知道来这里之前的一步的状态）</p></blockquote><p>状态：<code>f[i][j]</code>表示从0跳奇/偶数步到坐标i位置的方案数</p><p>转移：<code>f[i][j]=0|arr[i]==1, sum{f[i-k][1-j]}|k in {1,2,4}</code></p><p>边界：<code>f[0][0]=1</code></p><p>优化：可以滚动i，开5个大小，因为最多需要从4步前拿状态</p><hr><p>Frog Jump</p><blockquote><p>有一条小河上有N个石头，位置依次在a0&lt;a1&lt;...&lt;an-1</p><p>• 有一只青蛙在第一个石头上<br> • 青蛙一开始可以向右跳距离为1<br> • 它必须一直向右跳，并且落在石头上</p><p>如果上次跳的距离是L，这次跳的距离可以是L-1, L或者L+1</p><p>问能否到达最后一个石头</p></blockquote><p>状态：<code>f[i][j]</code>表示是否能最后一跳长度j跳到石头a[i]</p><p>转移：<code>f[i][j]=f[k][j-1] OR f[k][j] OR f[k][j+1] | a[k]=a[i]-j</code></p><p>边界：<code>f[0][0]=true</code></p><p>答案：<code>or{f[n-1][j]}</code></p><hr><p>1269 停在原地的方案数</p><blockquote><p>从坐标1出发，每次可以向左一格、向右一格、原地不动 问 steps 次操作后停留在原地的方案总数</p><p>坐标+背包1维费用</p></blockquote><p>状态：<code>dp[i][j]</code>表示走了 i 次以后, 走到坐标 j 的路径数</p><p>（j可能是负数但是范围有限是n，故可以限制其范围并坐标映射+n/2）</p><p>转移：<code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] + dp[i - 1][j + 1]</code></p><p>边界：<code>dp[0][0]=1</code></p><p>答案：<code>dp[n-1][0]</code></p><h2 id="子序型" tabindex="-1"><a class="header-anchor" href="#子序型"><span>子序型</span></a></h2><p>又称为接龙型，传统的接龙动规做法，一般是告诉你一个接龙规则，让你找最长的龙</p><p>状态：<code>dp[i]</code>表示以下i标结尾的龙最长是多长</p><p>LCIS</p><p>状态：<code>f[i]</code>表示以下i标结尾的连续递增串最长是多长</p><p>转移：<code>f[i]=f[i-1]+1|a[i]&gt;a[i-1]</code></p><p>边界：<code>f[i]=1</code></p><p>答案：<code>max(dp[i])</code></p><hr><p>LIS</p><p>状态：<code>dp[i]</code>表示以下i标结尾的龙最长是多长</p><p>转移：<code>dp[i]=max{dp[j]+1|j&lt;i&amp;&amp;nums[j]&lt;nums[i]}</code></p><p>边界：<code>dp[0..n-1]=1</code></p><p>答案：<code>max(dp[i])</code></p><hr><p>LIS</p><p>状态：<code>f[i]</code>表示以下i标结尾的龙最长是多长</p><p>转移：<code>f[i]=max{1,f[j]+1|i&lt;j and a[i]&lt;a[j]}</code></p><p>LIS 的二分做法选择性的掌握即可，并不是所有的接龙型DP都可以用二分来优化</p><hr><p>Russian Doll Envelopes</p><p>给定N个信封的长度和宽度。如果一个信封的长和宽都分别小于另一个信封的长和宽，则这个信封可以放入另一个信封。问最多嵌套多少个信封</p><hr><p>Longest Continuous Increasing Subsequence II</p><blockquote><p>四个方向，依然可以动态规划</p></blockquote><hr><p>Largest Divisible Subset</p><p>特殊点：需要一个额外的数组记录上一个位置的值</p><p>如果需要找到这个路径的话会麻烦一些，需要hashmap或倒推法</p><hr><p>单词接龙问题</p><blockquote><p>给一个单词集合，两个单词可以接在一起当且仅当前一个单词的后缀和后一个单词的前缀，能够重叠至少1个字符</p><p>每个单词可以且仅可以使用一次，请问最长接出来的龙的长度多少?</p></blockquote><hr><p>不同的子序列</p><blockquote><p>给定一个小写字母组成的字符串S，问S中不同的非空子序列的个数</p></blockquote><p>状态：<code>f[i]</code>表示以下标 i 字符结尾的不同子序列有多少个</p><p>转移：<code>f[i]=sum{f[j]|a[i] not in f[j+1,i-1]}</code></p><p>边界：<code>f[i]=1, a[i]是第一次出现</code></p><hr><p>等差数列划分</p><h3 id="子串型" tabindex="-1"><a class="header-anchor" href="#子串型"><span>子串型</span></a></h3><p>核心：连续，Kadane 算法</p><blockquote><p>在数组或滑动窗口中找到子串和的最大值或最小值的 O(N) 算法（可拓展到别的）</p></blockquote><p><strong>最大子数组和</strong></p><p>状态：<code>f[i]</code>表示以下i标结尾的最大子数组和</p><p>转移：<code>f[i]=nums[i]+max{0, f[i-1]}</code></p><p>边界：<code>f[0]=nums[0]</code></p><p>答案：<code>max{f[i]}</code></p><hr><p><strong>最长连续序列</strong></p><p>状态：<code>f[i]</code>表示以下i标结尾的最长连续序列长度</p><p>转移：</p><ul><li><code>f[i]=f[i-1]+1, nums[i]==nums[i-1]</code></li><li><code>f[i]=1, nums[i]!=nums[i-1]</code></li></ul><p>答案：<code>max{f[i]}</code></p><hr><p><strong>最大子数组积</strong></p><blockquote><p>坐标型+状态型（需要知道来这里之前的一步的状态：最大/最小）</p></blockquote><p>状态：<code>f[i][0/1]</code>表示以下i标结尾的最小/大子数组积</p><p>转移：</p><ul><li><code>f[i][0]=min{nums[i], f[i-1][0]*nums[i], f[i-1][1]*nums[i]}}</code></li><li><code>f[i][1]=max{nums[i], f[i-1][0]*nums[i], f[i-1][1]*nums[i]}}</code></li></ul><p>边界：<code>f[0]=nums[0]</code></p><p>答案：<code>max{f[i][1]}</code></p><h2 id="位运算型" tabindex="-1"><a class="header-anchor" href="#位运算型"><span>位运算型</span></a></h2><p><code>&amp;|^!</code></p><p>i是一个数字，也是一个状态</p><p><strong>Counting Bits 比特位计数</strong></p><blockquote><p>求 0, 1, ..., n 每个数字的二进制1的个数</p></blockquote><p>状态：<code>f[i]</code>表示数字i的1个数</p><p>转移：<code>f[i]=f[i&gt;&gt;1]+(i&amp;1)</code></p><hr><p>写法二：最低设置位法</p><p>转移：<code>f[i]=f[i &amp; (i - 1)] + 1</code></p><h2 id="多坐标" tabindex="-1"><a class="header-anchor" href="#多坐标"><span>多坐标</span></a></h2><p>摘樱桃</p><p>摘樱桃 II</p>',137)]))}const r=p(d,[["render",a],["__file","坐标型.html.vue"]]),s=JSON.parse(`{"path":"/algo/summary/optimise/dynamic-programming/%E5%9D%90%E6%A0%87/%E5%9D%90%E6%A0%87%E5%9E%8B.html","title":"坐标型","lang":"en-US","frontmatter":{"description":"坐标型 状态：f[i]表示以a[i]为结尾的子序列的某种性质 边界：f[0]就是以a[0]为结尾的子序列的性质（没法从前面推导） 本质上是找一个以i结尾的路径（子序列） 给定一个序列或网格，需要找到序列中某个/些子序列或网格中的某条路径的性质 坐标型动态规划的初始条件f[0]就是指以a[0]为结尾的子序列的性质 状态i表示以a为结尾的满足条件的子序列的...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/summary/optimise/dynamic-programming/%E5%9D%90%E6%A0%87/%E5%9D%90%E6%A0%87%E5%9E%8B.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"坐标型"}],["meta",{"property":"og:description","content":"坐标型 状态：f[i]表示以a[i]为结尾的子序列的某种性质 边界：f[0]就是以a[0]为结尾的子序列的性质（没法从前面推导） 本质上是找一个以i结尾的路径（子序列） 给定一个序列或网格，需要找到序列中某个/些子序列或网格中的某条路径的性质 坐标型动态规划的初始条件f[0]就是指以a[0]为结尾的子序列的性质 状态i表示以a为结尾的满足条件的子序列的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-12-04T01:12:41.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-04T01:12:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"坐标型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-04T01:12:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":2,"title":"一维型","slug":"一维型","link":"#一维型","children":[{"level":3,"title":"约束","slug":"约束","link":"#约束","children":[]}]},{"level":2,"title":"子序型","slug":"子序型","link":"#子序型","children":[{"level":3,"title":"子串型","slug":"子串型","link":"#子串型","children":[]}]},{"level":2,"title":"位运算型","slug":"位运算型","link":"#位运算型","children":[]},{"level":2,"title":"多坐标","slug":"多坐标","link":"#多坐标","children":[]}],"git":{"createdTime":1732244737000,"updatedTime":1733274761000,"contributors":[{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro-3.local","commits":1}]},"readingTime":{"minutes":6.3,"words":1890},"filePathRelative":"algo/summary/optimise/dynamic-programming/坐标/坐标型.md","localizedDate":"November 22, 2024","excerpt":"\\n<p>状态：<code>f[i]</code>表示以<code>a[i]</code>为<strong>结尾</strong>的子序列的某种性质</p>\\n<p>边界：<code>f[0]</code>就是以<code>a[0]</code>为结尾的子序列的性质（没法从前面推导）</p>\\n<p>本质上是找一个以i结尾的路径（子序列）</p>\\n<p>给定一个序列或网格，需要找到序列中某个/些子序列或网格中的某条路径的性质</p>\\n<p>坐标型动态规划的初始条件f[0]就是指以a[0]为结尾的子序列的性质</p>\\n<p>状态i表示以a为结尾的满足条件的子序列的性质</p>\\n<p><code>f[i][j]</code>中的下标，表示以格子<code>(i,j)</code>为结尾的满足条件的路径的性质</p>","autoDesc":true}`);export{r as comp,s as data};
