import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as p,o as r}from"./app-DtA_0glx.js";const i={};function a(l,e){return r(),o("div",null,e[0]||(e[0]=[p('<h1 id="拓扑排序" tabindex="-1"><a class="header-anchor" href="#拓扑排序"><span>拓扑排序</span></a></h1><p>入度(In-degree)：有向图(Directed Graph)中指向当前节点的点的个数(或指向当前节点的边的条数)</p><p>算法描述:</p><ol><li>统计每个点的入度</li><li>将每个入度为 0 的点放入队列(Queue)中作为起始节点</li><li>不断从队列中拿出一个点，去掉这个点的所有连边(指向其他点的边)，其他点的相应的入度 - 1 4. 一旦发现新的入度为 0 的点，丢回队列中</li></ol><p>拓扑排序并不是传统的排序算法<br> 一个图可能存在多个拓扑序(Topological Order)，也可能不存在任何拓扑序</p><p>拓扑排序的四种不同问法</p><ol><li>求任意一个拓扑序</li><li>问是否存在拓扑序</li><li>求是否存在且仅存在一个拓扑序</li><li>求字典序最小的拓扑排序</li></ol><hr><p>求任意一个拓扑排序</p><p>一个个把点从图中抠出来</p><hr><p>判断是否存在拓扑排序</p><p>所有节点均能从图中被删除进入拓扑序</p><hr><p>问拓扑序是否唯一</p><p>保持队列中有且仅有一个元素</p><hr><p>求字典序最小的拓扑排序</p><p>优先队列</p><p>alienOrder</p>',20)]))}const d=t(i,[["render",a],["__file","topo.html.vue"]]),m=JSON.parse(`{"path":"/algo/summary/search/BFS/topo.html","title":"拓扑排序","lang":"en-US","frontmatter":{"description":"拓扑排序 入度(In-degree)：有向图(Directed Graph)中指向当前节点的点的个数(或指向当前节点的边的条数) 算法描述: 统计每个点的入度 将每个入度为 0 的点放入队列(Queue)中作为起始节点 不断从队列中拿出一个点，去掉这个点的所有连边(指向其他点的边)，其他点的相应的入度 - 1 4. 一旦发现新的入度为 0 的点，丢回队...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/summary/search/BFS/topo.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"拓扑排序"}],["meta",{"property":"og:description","content":"拓扑排序 入度(In-degree)：有向图(Directed Graph)中指向当前节点的点的个数(或指向当前节点的边的条数) 算法描述: 统计每个点的入度 将每个入度为 0 的点放入队列(Queue)中作为起始节点 不断从队列中拿出一个点，去掉这个点的所有连边(指向其他点的边)，其他点的相应的入度 - 1 4. 一旦发现新的入度为 0 的点，丢回队..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-22T03:05:37.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-22T03:05:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"拓扑排序\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-22T03:05:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[],"git":{"createdTime":1732244737000,"updatedTime":1732244737000,"contributors":[{"name":"David Liu","email":"liudawei@seas.upenn.edu","commits":1}]},"readingTime":{"minutes":1.03,"words":308},"filePathRelative":"algo/summary/search/BFS/topo.md","localizedDate":"November 22, 2024","excerpt":"\\n<p>入度(In-degree)：有向图(Directed Graph)中指向当前节点的点的个数(或指向当前节点的边的条数)</p>\\n<p>算法描述:</p>\\n<ol>\\n<li>统计每个点的入度</li>\\n<li>将每个入度为 0 的点放入队列(Queue)中作为起始节点</li>\\n<li>不断从队列中拿出一个点，去掉这个点的所有连边(指向其他点的边)，其他点的相应的入度 - 1 4. 一旦发现新的入度为 0 的点，丢回队列中</li>\\n</ol>\\n<p>拓扑排序并不是传统的排序算法<br>\\n一个图可能存在多个拓扑序(Topological Order)，也可能不存在任何拓扑序</p>\\n<p>拓扑排序的四种不同问法</p>","autoDesc":true}`);export{d as comp,m as data};
