import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as n,o as i}from"./app-D4ZvIHfO.js";const a={};function r(l,e){return i(),o("div",null,e[0]||(e[0]=[n('<h1 id="引用" tabindex="-1"><a class="header-anchor" href="#引用"><span>引用</span></a></h1><p>左指引用</p><p>右值引用</p><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p><ol><li>普通类型的变量，因为有名字，可以取地址，都认为是左值。</li><li>const修饰的常量，不可修改，只读类型的，理论应该按照右值对待，但因为其可以取地址(如果只是const类型常量的定义，编译器不给其开辟空间，如果对该常量取地址时，编译器才为其开辟空间)，C++11认为其是左值。</li><li>如果表达式的运行结果是一个临时变量或者对象，认为是右值。</li><li>如果表达式运行结果或单个变量是一个引用则认为是左值。</li></ol><hr><p>按照语法，右值引用只能引用右值，但右值引用一定不能引用左值吗？因为：有些场景下，可能真的需要用右值去引用左值实现移动语义。当需要用右值引用引用一个左值时，可以通过move函数将左值转化为右值。C++11中，std::move()函数位于 头文件中，该函数名字具有迷惑性，它并不搬移任何东西，唯一的功能就是将一个左值强制转化为右值引用，然后实现移动语义。</p>',7)]))}const s=t(a,[["render",r],["__file","reference.html.vue"]]),d=JSON.parse(`{"path":"/se/lang/cpp/reference.html","title":"引用","lang":"en-US","frontmatter":{"description":"引用 左指引用 右值引用 引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 普通类型的变量，因为有名字，可以取地址，都认为是左值。 const修饰的常量，不可修改，只读类型的，理论应该按照右值对待，但因为其可以取地址(如果只是const类型常量的定义，编译器不给其开辟空...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/se/lang/cpp/reference.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"引用"}],["meta",{"property":"og:description","content":"引用 左指引用 右值引用 引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 普通类型的变量，因为有名字，可以取地址，都认为是左值。 const修饰的常量，不可修改，只读类型的，理论应该按照右值对待，但因为其可以取地址(如果只是const类型常量的定义，编译器不给其开辟空..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-05-08T07:35:02.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-08T07:35:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"引用\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-08T07:35:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[],"git":{"createdTime":1715153702000,"updatedTime":1715153702000,"contributors":[{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":1}]},"readingTime":{"minutes":1.26,"words":379},"filePathRelative":"se/lang/cpp/reference.md","localizedDate":"May 8, 2024","excerpt":"\\n<p>左指引用</p>\\n<p>右值引用</p>\\n<p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>\\n<ol>\\n<li>普通类型的变量，因为有名字，可以取地址，都认为是左值。</li>\\n<li>const修饰的常量，不可修改，只读类型的，理论应该按照右值对待，但因为其可以取地址(如果只是const类型常量的定义，编译器不给其开辟空间，如果对该常量取地址时，编译器才为其开辟空间)，C++11认为其是左值。</li>\\n<li>如果表达式的运行结果是一个临时变量或者对象，认为是右值。</li>\\n<li>如果表达式运行结果或单个变量是一个引用则认为是左值。</li>\\n</ol>","autoDesc":true}`);export{s as comp,d as data};
