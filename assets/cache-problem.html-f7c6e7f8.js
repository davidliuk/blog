const e=JSON.parse(`{"key":"v-30b7ac52","path":"/cs/database/redis/practice/cache-problem.html","title":"缓存问题：穿透、击穿、雪崩","lang":"en-US","frontmatter":{"description":"缓存问题：穿透、击穿、雪崩 缓存穿透 Pass Through 概念： 客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。 被动解决方案： 缓存空对象 优点：实现简单，维护方便 缺点： 额外的内存消耗（不过可以通过TTL来缓解） 可能造成短期的不一致 布隆过滤 优点：内存占用比较少，没有多余key 缺点： 实现复杂（hash + bitmap + 概率实现的） 存在误判可能（说不存在一定不存在，但是说存在的时候也有一定概率是不存在的）","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/cs/database/redis/practice/cache-problem.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"缓存问题：穿透、击穿、雪崩"}],["meta",{"property":"og:description","content":"缓存问题：穿透、击穿、雪崩 缓存穿透 Pass Through 概念： 客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。 被动解决方案： 缓存空对象 优点：实现简单，维护方便 缺点： 额外的内存消耗（不过可以通过TTL来缓解） 可能造成短期的不一致 布隆过滤 优点：内存占用比较少，没有多余key 缺点： 实现复杂（hash + bitmap + 概率实现的） 存在误判可能（说不存在一定不存在，但是说存在的时候也有一定概率是不存在的）"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-02-27T13:30:02.000Z"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2023-02-27T13:30:02.000Z"}],["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://davidliuk.github.io/blog/blog/zh/cs/database/redis/practice/cache-problem.html"}]]},"headers":[{"level":2,"title":"缓存穿透","slug":"缓存穿透","link":"#缓存穿透","children":[{"level":3,"title":"概念：","slug":"概念","link":"#概念","children":[]},{"level":3,"title":"被动解决方案：","slug":"被动解决方案","link":"#被动解决方案","children":[]},{"level":3,"title":"主动方案：","slug":"主动方案","link":"#主动方案","children":[]}]},{"level":2,"title":"缓存雪崩","slug":"缓存雪崩","link":"#缓存雪崩","children":[{"level":3,"title":"概念","slug":"概念-1","link":"#概念-1","children":[]},{"level":3,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[]}]},{"level":2,"title":"缓存击穿","slug":"缓存击穿","link":"#缓存击穿","children":[{"level":3,"title":"概念","slug":"概念-2","link":"#概念-2","children":[]},{"level":3,"title":"解决方案","slug":"解决方案-1","link":"#解决方案-1","children":[]}]}],"git":{"createdTime":1672229303000,"updatedTime":1677504602000,"contributors":[{"name":"刘大维","email":"davidliu@liudaweideMacBook-Pro.local","commits":2}]},"readingTime":{"minutes":1.75,"words":526},"localizedDate":"December 28, 2022","filePathRelative":"cs/database/redis/practice/cache-problem.md","excerpt":"<h1> 缓存问题：穿透、击穿、雪崩</h1>\\n<h2> 缓存穿透</h2>\\n<p>Pass Through</p>\\n<h3> 概念：</h3>\\n<p>客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>\\n<h3> 被动解决方案：</h3>\\n<ul>\\n<li>缓存空对象\\n<ul>\\n<li>优点：实现简单，维护方便</li>\\n<li>缺点：\\n<ul>\\n<li>额外的内存消耗（不过可以通过TTL来缓解）</li>\\n<li>可能造成短期的不一致</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>布隆过滤\\n<ul>\\n<li>优点：内存占用比较少，没有多余key</li>\\n<li>缺点：\\n<ul>\\n<li>实现复杂（hash + bitmap + 概率实现的）</li>\\n<li>存在误判可能（说不存在一定不存在，但是说存在的时候也有一定概率是不存在的）</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}`);export{e as data};
