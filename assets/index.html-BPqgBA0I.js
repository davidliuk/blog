import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as t}from"./app-BtADw1TI.js";const i={};function r(o,p){return t(),a("div",null,[...p[0]||(p[0]=[n('<h1 id="递归" tabindex="-1"><a class="header-anchor" href="#递归"><span>递归</span></a></h1><p>啥是递归？</p><p>当函数直接或者间接调用自己时，则发生了递归</p><p>递归的定义：参见“递归的定义”</p><hr><p>递归的三要素</p><ul><li><p>递归的定义 (接收什么参数, 返回什么值, 代表什么含义)</p></li><li><p>递归的拆解 (把大问题拆解成小问题)（或者叫转移）</p></li><li><p>递归的出口 (到什么时候结束)</p></li></ul><hr><p>迭代形式与递归形式比较</p><p>时间复杂度：迭代O(n), 递归O(n)</p><p>空间复杂度：迭代O(1), 递归O(n)</p><p>递归的O(n)空间是栈空间</p><hr><h3 id="内存中的堆和栈" tabindex="-1"><a class="header-anchor" href="#内存中的堆和栈"><span>内存中的堆和栈</span></a></h3><p>堆空间</p><ul><li>存放 new 得到的对象</li><li>无限制 (剩余内存的大小)</li></ul><p>栈空间</p><ul><li>存放对象的引用</li><li>值类型变量</li><li>C++函数中的数组</li><li>有限制, 一般很小, MB量级</li><li>函数调用栈</li></ul><p>函数调用栈</p><p>想象一个“圆筒”，调用的函数需要放到筒里</p><p>第一个进入“圆筒”的是main函数</p><p>每发生一次新的函数调用，就会有一个新函数进入“圆筒”</p><p>正在执行的就是最上面的函数</p><p>一个函数执行完毕，就会被拿出来</p><p>圆筒满了怎么办？</p><p>N 如果过大，有可能还没来得及从圆筒中拿出函数圆筒就满了</p><p>递归需谨慎</p><p>递归调用容易爆栈</p><p>人为调用栈不会爆栈</p><p>除非在C/C++的函数中定义大数组——危险行为</p><hr><p>排序算法（归并排序、快速排序）、傅立叶变换（快速傅立叶变换）。</p><h2 id="参数传递" tabindex="-1"><a class="header-anchor" href="#参数传递"><span>参数传递</span></a></h2><p>Java(值传递，引用传递)</p><p>Python(引用传递)</p><p>C++(值传递，引用传递，指针传递)</p><hr><h3 id="值传递" tabindex="-1"><a class="header-anchor" href="#值传递"><span>值传递</span></a></h3><p>文件复制、克隆羊多莉</p><p>值传递相当于创建个新的变量，把值拷贝一份</p><p>修改新的变量原来的变量不会受到影响</p><hr><p>不同语言中呈现值传递的场景</p><p>Java的基本数据类型</p><p>(byte,short,int,long,float,double,char,boolean)</p><p>C++中默认值传递</p><p>Python没有值传递</p><p>基本数据类型的值传递</p><hr><p>Python 没有值传递</p><p>但是 Python 的不可变类型可以认为是值传递的</p><h3 id="引用传递" tabindex="-1"><a class="header-anchor" href="#引用传递"><span>引用传递</span></a></h3><p>可以理解为别名，代号</p><p>文件的快捷方式</p><p>所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p><p>Java 除基本数据类型以外的其他数据</p><p>C++ 中在参数列表中加地址符 &amp; 修饰</p><p>Python 中全是引用传递</p><h3 id="修改实例和修改引用" tabindex="-1"><a class="header-anchor" href="#修改实例和修改引用"><span>修改实例和修改引用</span></a></h3><p>带 “.” 或者带 “[]” 修改的是实例</p><p>否则修改的是引用</p><p>包装类和不可修改类型的传参</p><p>虽然是引用传递，但是能看成是值传递</p>',63)])])}const s=e(i,[["render",r]]),c=JSON.parse(`{"path":"/algo/search/DFS/recursion/","title":"递归","lang":"en-US","frontmatter":{"description":"递归 啥是递归？ 当函数直接或者间接调用自己时，则发生了递归 递归的定义：参见“递归的定义” 递归的三要素 递归的定义 (接收什么参数, 返回什么值, 代表什么含义) 递归的拆解 (把大问题拆解成小问题)（或者叫转移） 递归的出口 (到什么时候结束) 迭代形式与递归形式比较 时间复杂度：迭代O(n), 递归O(n) 空间复杂度：迭代O(1), 递归O(...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"递归\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-15T23:09:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"],["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/algo/search/DFS/recursion/"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"递归"}],["meta",{"property":"og:description","content":"递归 啥是递归？ 当函数直接或者间接调用自己时，则发生了递归 递归的定义：参见“递归的定义” 递归的三要素 递归的定义 (接收什么参数, 返回什么值, 代表什么含义) 递归的拆解 (把大问题拆解成小问题)（或者叫转移） 递归的出口 (到什么时候结束) 迭代形式与递归形式比较 时间复杂度：迭代O(n), 递归O(n) 空间复杂度：迭代O(1), 递归O(..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-12-15T23:09:49.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-15T23:09:49.000Z"}]]},"git":{"createdTime":1765840189000,"updatedTime":1765840189000,"contributors":[{"name":"David Liu","username":"","email":"davidliu02k@gmail.com","commits":1}]},"readingTime":{"minutes":2.36,"words":709},"filePathRelative":"algo/search/DFS/recursion/README.md","excerpt":"\\n<p>啥是递归？</p>\\n<p>当函数直接或者间接调用自己时，则发生了递归</p>\\n<p>递归的定义：参见“递归的定义”</p>\\n<hr>\\n<p>递归的三要素</p>\\n<ul>\\n<li>\\n<p>递归的定义 (接收什么参数, 返回什么值, 代表什么含义)</p>\\n</li>\\n<li>\\n<p>递归的拆解 (把大问题拆解成小问题)（或者叫转移）</p>\\n</li>\\n<li>\\n<p>递归的出口 (到什么时候结束)</p>\\n</li>\\n</ul>\\n<hr>\\n<p>迭代形式与递归形式比较</p>\\n<p>时间复杂度：迭代O(n), 递归O(n)</p>\\n<p>空间复杂度：迭代O(1), 递归O(n)</p>","autoDesc":true}`);export{s as comp,c as data};
