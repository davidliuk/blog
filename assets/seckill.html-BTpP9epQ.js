import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as i,o as n}from"./app-CybQbXIt.js";const l={};function p(c,e){return n(),a("div",null,e[0]||(e[0]=[i('<h1 id="秒杀" tabindex="-1"><a class="header-anchor" href="#秒杀"><span>秒杀</span></a></h1><h3 id="超卖解决" tabindex="-1"><a class="header-anchor" href="#超卖解决"><span>超卖解决</span></a></h3><p>悲观锁：添加同步锁，让线程串行执行</p><ul><li>优点：简单粗暴</li><li>缺点：性能一般</li></ul><p>乐观锁：不加锁，在更新的时候判断是否有其他线程在修改</p><p>版本号，这样需要数据库加字段；或简化为：CAS 法</p><ul><li>优点：性能好</li><li>缺点：成功率太低</li></ul><p>改进：不再判断是否相等，只判断是否大于零，类似双锁校验</p><h3 id="一人一单" tabindex="-1"><a class="header-anchor" href="#一人一单"><span>一人一单</span></a></h3><p>因为购买数量是否修改过数据库里面不存在，所以不难使用乐观锁方案，</p><p>如果是带事物的情况下，锁的范围应该包括整个方法，否则回滚的时候又线程不安全了</p><ul><li>在调用方法前加锁，可以控制的粒度更细，控制好拿什么作为锁以后，该方法吞吐量更好</li><li>在方法前面前加锁，粒度粗，省事，但是吞吐量太低</li></ul><p>集群模式下，用 synchronized 控制并发就不安全了，用 redis 做分布式锁</p><h3 id="异步秒杀" tabindex="-1"><a class="header-anchor" href="#异步秒杀"><span>异步秒杀</span></a></h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-08 22.20.08.png" alt="截屏2023-02-08 22.20.08" loading="lazy"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-08 22.19.47.png" alt="截屏2023-02-08 22.19.47" loading="lazy"></p>',16)]))}const r=t(l,[["render",p],["__file","seckill.html.vue"]]),d=JSON.parse(`{"path":"/cs/database/redis/practice/design/seckill.html","title":"秒杀","lang":"en-US","frontmatter":{"description":"秒杀 超卖解决 悲观锁：添加同步锁，让线程串行执行 优点：简单粗暴 缺点：性能一般 乐观锁：不加锁，在更新的时候判断是否有其他线程在修改 版本号，这样需要数据库加字段；或简化为：CAS 法 优点：性能好 缺点：成功率太低 改进：不再判断是否相等，只判断是否大于零，类似双锁校验 一人一单 因为购买数量是否修改过数据库里面不存在，所以不难使用乐观锁方案， ...","head":[["meta",{"property":"og:url","content":"https://davidliuk.github.io/blog/blog/cs/database/redis/practice/design/seckill.html"}],["meta",{"property":"og:site_name","content":"David's Blog"}],["meta",{"property":"og:title","content":"秒杀"}],["meta",{"property":"og:description","content":"秒杀 超卖解决 悲观锁：添加同步锁，让线程串行执行 优点：简单粗暴 缺点：性能一般 乐观锁：不加锁，在更新的时候判断是否有其他线程在修改 版本号，这样需要数据库加字段；或简化为：CAS 法 优点：性能好 缺点：成功率太低 改进：不再判断是否相等，只判断是否大于零，类似双锁校验 一人一单 因为购买数量是否修改过数据库里面不存在，所以不难使用乐观锁方案， ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/%E6%88%AA%E5%B1%8F2023-02-08%2022.20.08.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-03-29T11:46:59.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-29T11:46:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"秒杀\\",\\"image\\":[\\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/%E6%88%AA%E5%B1%8F2023-02-08%2022.20.08.png\\",\\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/%E6%88%AA%E5%B1%8F2023-02-08%2022.19.47.png\\"],\\"dateModified\\":\\"2023-03-29T11:46:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Liu\\",\\"url\\":\\"https://github.com/davidliuk\\"}]}"]]},"headers":[{"level":3,"title":"超卖解决","slug":"超卖解决","link":"#超卖解决","children":[]},{"level":3,"title":"一人一单","slug":"一人一单","link":"#一人一单","children":[]},{"level":3,"title":"异步秒杀","slug":"异步秒杀","link":"#异步秒杀","children":[]}],"git":{"createdTime":1677504602000,"updatedTime":1680090419000,"contributors":[{"name":"davidliuk","email":"l729641074@163.com","commits":1}]},"readingTime":{"minutes":1.02,"words":305},"filePathRelative":"cs/database/redis/practice/design/seckill.md","localizedDate":"February 27, 2023","excerpt":"\\n<h3>超卖解决</h3>\\n<p>悲观锁：添加同步锁，让线程串行执行</p>\\n<ul>\\n<li>优点：简单粗暴</li>\\n<li>缺点：性能一般</li>\\n</ul>\\n<p>乐观锁：不加锁，在更新的时候判断是否有其他线程在修改</p>\\n<p>版本号，这样需要数据库加字段；或简化为：CAS 法</p>\\n<ul>\\n<li>优点：性能好</li>\\n<li>缺点：成功率太低</li>\\n</ul>\\n<p>改进：不再判断是否相等，只判断是否大于零，类似双锁校验</p>\\n<h3>一人一单</h3>\\n<p>因为购买数量是否修改过数据库里面不存在，所以不难使用乐观锁方案，</p>\\n<p>如果是带事物的情况下，锁的范围应该包括整个方法，否则回滚的时候又线程不安全了</p>","autoDesc":true}`);export{r as comp,d as data};
