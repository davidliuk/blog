# BFS

分类

- 狭义 BFS：Breadth-first search (BFS)

  结点只能入队一次

- 扩展 BFS：Best-first search (BeFS)

  结点可以入队多次（根据规则）

如果可以预先计算出每个节点到终点的距离，则可以利用这个信息更快的到达终点。

其原理与 Dijkstra 算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法。

## 高频考法

1. 连通块问题
2. 分层遍历
3. 拓扑排序

### 连通块问题

- 通过图中一个点找到其他所有连通的点

- 找到所有方案问题的一种非递归实现方式

  DFS vs BFS 在连通块问题上的优劣

### 分层遍历

- 图的层级遍历

  一层一层的遍历一个图、树、矩阵

- 简单图最短路径问题

  - 简单图：只有权值都一样，或者说是无权图

    简单图中，层级=最短路

    简单图中：第几层访问到该节点=到达该节点的最短路径

  - 复杂度最短路径有什么算法

    SPFA、Dijkstra

    复杂图中：我可能通过三层访问到比通过两层访问到的路径更短

  - 最长路径用什么算法

  - 什么是隐式图

  - 通用的 BFS 模板

  - 80%的人都会写错的 BFS 写法

### 拓扑排序

- DFS vs BFS 在拓扑排序上的优劣

  实现容易度远超过 DFS

- 拓扑排序的五个考点

  - 问有没有拓扑排序
  - 求任意一个拓扑排序
  - 求最小的拓扑排序
  - 求拓扑排序是否唯一

---

原则：能 BFS 的别 DFS(除非面试官特别要求)

（其实连通块问题用 dfs 写起来又短又快，且效率往往更高）

- Recursion 版本的 DFS 有 StackOverflow 的风险
- Non-Recursion 版本的 DFS 容易错+面试官未必看得懂

## BFS 模版

屡试不爽的 BFS 代码模板，刷题效率直接翻倍

应该在哪里做访问标记？入队之前标记 visited/distance 防止重复入队

矩阵坐标变换数组（如果是矩阵坐标 visited 可以不必 hashmap，二维数组即可）

- deltaX, deltaY
- inBound / isValid

```java
ReturnType bfs(Node startNode, [Node endNode]) {
    // BFS 必须要用 queue，別用 stack！
    Queue<Node> queue = new ArrayDeque<>();
    // hashmap 两个作用，一个是记录一个点是否被丢进过队列了，避免重复访问
    // 另外一个是记录 startNode 到其他所有节点的最短距离
    // 如果只求连通性的话，可以换成 HashSet 就行
    // node 做 key 的时候比较的是内存地址
    // 如果是二维坐标可以用二维数组来记录
    Map<Node, Integer> distance = new HashMap<>();
    // 把起点放进队列和哈希表里，如果有多个起点，都放进去
    queue.offer(startNode);
    distance.put(startNode, 0); // or 1  if necessary
    // while 队列不空，不停的从队列里拿出一个点，拓展邻居节点放到队列中
    while (!queue. isEmpty)) {
        Node node = queue.poll();
        // 遍历点的时候，出队后更新
        // 如果有明确的终点可以在这里加终点的判断
        if (node 是終点) {
        	break or return something;
        }
        for (Node neighbor : node.getNeighbors()) {
            if (distance.containsKey(neighbor)) {
            	continue;
            }
            // 若不满足条件，跳过
            // 这里可以判断边和点的条件
            if (!isValid(neighbor)) {
	            continue;
            }
            queue.orter(neighbor);
            // 遍历边的时候，入队前更新
            // 遍历点的时候也可以，但是建议上面
            // 防止重复入队/访问，同时记录层次信息
            distance.put(neighbor, distance.get (node) + 1);
        }
    }
    // 如果带要返回所有息离起息的跑离，就 return hashmap
    return distance;
    // 如果需要返回所有连通的节点，就 return HashMap 里的所有点
    return distance.keySet();
    // 如果需要返回离终点的最短距离
    return distance.get(endNode);
}
```

## A \* 算法

A \* search algorithm，简称 A\* 算法，是一种在图形平面上，对于有多个节点的路径求出最低通过成本的算法。它属于图遍历（Graph traversal）和最佳优先搜索算法（Best-first search），亦是 BFS 的改进。

A\*算法是综合上面这些算法的特点于一身的。A\*算法通过下面这个函数来计算每个节点的优先级。

$$
f(n)=g(n)+h(n)
$$

- f(n) 是起点 s 到终点 t 的预估长度，是节点 n 的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。
- g(n) 是节点 n 距离起点 s 的代价。
- h\*(n) 是节点 n 距离终点 t 的代价。搜索过程中很难准确的知道这个代价。
- h(n) 是节点 n 距离终点 t 的预估代价。采用预计代价，是 A\*算法的启发函数。

A\*算法在运算过程中，每次从优先队列中选取 f(n)值最小（优先级最高）的节点作为下一个待遍历的节点。

另外，A\*算法使用两个集合来表示：

- `open_set`：待遍历的节点
- `close_set`：已经遍历过的节点

我们知道，A\*的时间复杂度是和节点数量以及起始点难度呈幂函数正相关的。

[网址](http://qiao.github.io/PathFinding.js/visual/)很好的演示了双向 A\*的效果，我们来看一看。

绿色表示起点，红色表示终点，灰色是墙面。稍浅的两种绿色分别代表 open 节点和 close 节点：

针对 A\*算法的节点多导致搜索时间太长作了一定的改进

1. 估价函数采用两点之间的欧式距离

2. 交替进行前向和后向搜寻

3. 设置搜寻阈值，当超过这一阈值时，设定方向点的为阈值临界点，只有目标点在阈值范围内时再进行搜寻

### 对 h 的估计

它是 A\*算法中的最特别之处，是“启发式”体现的核心，也是与 Dijkstra 算法相比，差别最大的部分。

令$\hat h(n)$为$h(n)$的一个估计。估计$\hat h(n)$的过程通常被称为**试探法**，因为估计过程是从当前节点向终点（尚未探测到的节点）的一种估计。估计的准确度依赖于问题域中可用的信息数。

迪杰斯特拉算法在寻找下个点时，选择标准为：

open 列表中，距离起点最近的点。即：起点到该点的距离最短

最佳优先搜索算法在寻找下个点时，选择标准为：

open 列表中，距离终点最近的点。即：起点到该点的距离最短

A\*算法在寻找下个点时，选择标准为：

open 列表中，起点到该点的距离 + 该点到终点的直线距离 之和 最短。

从下表可知，选择一个好的启发函数是重要的。

| 情况                    | 函数                                           | 结果                                   |
| ----------------------- | ---------------------------------------------- | -------------------------------------- |
| $\hat h(n)=0$           | A\*算法退化为 Dijkstra 算法                    | 保证能找到一条最短路径                 |
| $\hat h(n)< h(n)$       | $\hat h(n)$越小，A\*扩展的节点越多，运行的越慢 | 保证能找到一条最短路径，但运算更快了   |
| $\hat h(n)= h(n)$       | 仅寻找最佳路径，而不扩展任何别的节点。         | 保证能找到一条最短路径，并且运算非常快 |
| $\hat h(n)> h(n)$       | 寻找最佳路径且扩展别的任何节点                 | 不能保证找到一条最短路径，但运算更快了 |
| $\hat h(n)\gg\hat g(n)$ | A\*算法退化为 BFS 算法                         | 不能保证找到一条最短路径，但运算非常快 |

所以得到一个很有趣的情况，那就是可以决定想要从 A\*中获得什么。

理想情况下，我们想最快地得到最短路径；但如果目标太低，仍会得到最短路径，不过速度变慢了；如果目标太高，那就放弃了最短路径，但它运行得更快。

### 启发函数

常见估价函数（用距离）

- 欧几里得距离：直线距离

  一般不行

- 曼哈顿距离：xy 距离绝对值的和

  不能斜着走

- 切比雪夫距离：xy 距离绝对值的最大值

  可以斜着走的时候

---

openSet queue

closeSet visited

---

可以很好的解决八数码问题

完整的 A\*算法描述如下：

```text
* 初始化open_set和close_set；
* 将起点加入open_set中，并设置优先级为0（优先级最高）；
* 如果open_set不为空，则从open_set中选取优先级最高的节点n：
    * 如果节点n为终点，则：
        * 从终点开始逐步追踪parent节点，一直达到起点；
        * 返回找到的结果路径，算法结束；
    * 如果节点n不是终点，则：
        * 将节点n从open_set中删除，并加入close_set中；
        * 遍历节点n所有的邻近节点：
            * 如果邻近节点m在close_set中，则：
                * 跳过，选取下一个邻近节点
            * 如果邻近节点m在open_set中，则：
                * 判断节点n到节点m的 F(n) + cost[n,m] 值是否 < 节点m的 F(m) 。来尝试更新该点，重新设置f值和父节点等数据
            * 如果邻近节点m也不在open_set中，则：
                * 设置节点m的parent为节点n
                * 计算节点m的优先级
                * 将节点m加入open_set中
```

### BFS 实现

常见有三种写法：

- dummy、
- BiQueue 双队列
- Queue 单队列

### BFS 例题

二叉树的层次遍历 - LintCode
二叉树的层次遍历 II - LintCode
二叉树的最大深度 - LintCode
单词接龙 II - LintCode
岛屿的个数 - LintCode

---

实际面试围绕 BFS 所涉及算法和数据结构

二叉树
拓扑排序算法
堆
宽度优先搜素
深度优先搜索
动态规划
字符串处理

---

二叉树的层次遍历
二叉树的层次遍历川
二叉树的最大深度
单词接龙
拓扑排序
克隆图
岛屿的个数
墙和门
二叉树的右视图
外星人字典

---

搞定 BFS 知识点，你可以刷这些高频题

- 二叉树的层次遍历
- 克隆图
- 二叉树的最大深度
- 岛屿的个数
- 单词接龙
- 墙和门
- 拓扑排序
- 外星人字典

样例，每个题做完相当于啃下 3 一 5 道类似题

## 进阶

- BFS 解决最短路径问题时可能产生的各类变化
- 宽度优先搜索代码模板
- BFS 两种实现方式

  - 在不同情况下各自的优劣对比

- 图的邻接表(Adjacency List)存储方法
- 使用 SPFA 算法解决复杂图最短路径问题
- 双向宽度优先搜索代码模板
- 双向宽度优先搜索到底带来多大的优化?
- 如何记录 BFS 求出的最短路径的具体方案

例题
