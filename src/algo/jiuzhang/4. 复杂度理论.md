# 复杂度理论

四个复杂度

1. 时间复杂度 - 核心考察点
2. 空间复杂度 - 次要考察点
3. 编程复杂度 - 能看得懂
4. 思维复杂度 - 能想得出



双指针线性复杂度

但有的时候，很明显的小数据的情况下，可以略微损失一点时间复杂度来降低编程复杂度，提高可读性



## 时间复杂度

只考虑最高项，不考虑常数项和系数项

O(2^N+N^2) = O(2^N) 

O(N^3+1000N^2) = O(N^3)

O(logN) = O(log(N^2)) = O(log4(N))

Omax(n, m) = O(n+m)

### P 问题 Polynomial

（多项式问题）

- On，On2，On3
- O1，On0.5, Om+n
- Ologn，Onlogn

### NP 问题

- O2n，On^n, On!

## 分类

O(IogN)二分法比较多
O(N0.5)分解质因数（极少）
O(N)双指针，单调栈，枚举法
O(NlogN)排序，O(N*logN的数据结构上的操作)
O(N2),O(N3),动态规划等
O(2n)组合类(combination)的搜索问题
O(N!)排列类(permutation)的搜索问题

根据时间复杂度来倒推算法

On 算法有

1. 双指针算法：最常见，频率远大于后面的所有算法的和
2. 打擂台算法：找最大值（一开始赋值成负无穷，每次把最大的打下来）
3. 单调栈算法：四五道题稍微多一些
4. 单调队列算法

双指针

1. 相向双指针

   两根指针一头一尾，向中间靠拢直到相遇

   1. Reverse 型（题目不多）

      翻转字符串

      判断回文串

   2. Two Sum 型（两位数题）

      两数之和

      1. Hashmap: On, On
      2. 排序+双指针: Onlogn, O1

      三数之和

   3. Partition 型（两位数题）

      快速排序

      颜色排序

2. 同向双指针

   1. 滑动窗口类
   2. 快慢指针类

3. 背向双指针

   非常少见，就几个题

   最长回文串

   k closest element



如果while或if里面过长，则可以考虑可以拆出来一个函数来处理，过长的时候不容易读懂，然后可能出错



返回多个值，需要构建类



两数之和，有十种变形

follow up

1. 排好序的情况下，哪种更好

   双指针

2. 需要返回下标的时候，哪种更好

   hashmap更好

   否则双指针需要将数组转换成一个pair的数组进行排序，保存数值和原来的位置

