# 序列型

题目变种多，没有固定模板，见招拆招

分类

前缀型/序列型

- 背包型
- 划分型
- 双序型/匹配型

后缀型

对于博弈问题，每次都取头部的东西（边不可逆），再往后选，这样只能从后往前推

也适合于不确定终点的时候使用

---

给定一个序列

状态：`f[i]`表示前i个元素`a[0],a[1],...,a[i-1]`的某种性质

边界：`f[0]`表示空序列的性质

给定一个序列

状态：`f[i]`表示从i开头到结尾元素`a[i],a[i+1],...,a[n-1]`的某种性质

边界：`f[n]`表示空序列的性质

## 前缀型

Decode Ways

> lc91. 即带限制的爬楼梯/fib

状态：`f[i]`表示前i个数字解密成字符串的方案数

转移：`f[i]=f[i-1]|letter(i-1) + f[i-2]|letter(i-2,i-1)`

边界：`f[0]=1,f[1]=letter(1)`

顺序：0-n

---

Decode Ways II

> 有一段由A-Z组成的字母串信息被加密成数字串
>  • 加密方式为:Aà1, Bà2, ..., Zà26
>  • 给定加密后的数字串S[0...N-1]，问有多少种方式解密成字母串 • 其中可能出现*字符，可以被替换成为1~9中的任何一个字符

状态：`f[i]`表示前i个数字解密成字符串的方案数

转移：`f[i]=f[i-1]*letter(i-1) + f[i-2]*letter(i-2,i-1)`

边界：`f[0]=1,f[1]=letter(1)`

顺序：0-n

---

Paint House

> 一共3个颜色，相邻两家不能颜色一样
>
> lc256. Paint House
>
> 序列+状态

状态：`f[i][j]`表示前i个房子，第i-1是颜色j，最小花费

转移：$f[i][j]=min_{k\ne j}{f[i-1][k]}+cost[i-1][j]$

---

Paint House II

> 一共k个颜色，相邻两家不能颜色一样

状态：`f[i][j]`表示前i个房子，第i-1是颜色j，最小花费

转移：$f[i][j]=min_{k\ne j}{f[i-1][k]}+cost[i-1][j]$

O(nk2)

优化：每次要求出了j以外其他元素的最小值，加速方法，记录最小值和次小值O(nk)

---

Paint House III

> m个房子，一共n个颜色，相邻几家颜色一样构成一个街区，要求构成target个街区最小花费

状态：`f[i][j][k]`表示前i个房子，第i-1是颜色j，构成k个街区，最小花费

转移：`f[i][j][k]=min{f[i-1][j][k],min{f[i-1][x][k-1]}}+cost[i-1][j]`

O(nk2)

优化：每次要求出了j以外其他元素的最小值，加速方法，记录最小值和次小值O(nk)

用`b[i][k]`表示`f[i][?][k]`的(1st,1stIdx,2st)，这样可以O1取得min

---

House Robber

> 不能偷相邻两家
>
> 两种理解思路，可以推出两种状态和对应的状态转移

状态：`f[i]`表示前i个房子的最大值（不限制i-1是否被抢）

转移：`f[i]=min{f[i-1],f[i-2]+a[i-1]}`

边界：`f[0]=0,f[1]=a[0]`

答案：`f[n]`

---

状态：`f[i][j]`表示前i个房子，i-1是否被抢为j，的最大值

转移：

- `f[i][1]=f[i-1][0]+a[i-1]`
- `f[i][0]=min{f[i-1][0],f[i-1][1]}`

边界：`f[0][j]=0`

答案：`Math.max{f[n][0], f[n][1]}`

---

House Robber II

> 不能偷相邻两家，环型的，即首位不能同时被偷

化为1-n-1和0-n-2

---

Best Time To Buy And Sell Stock

> 只能买卖一次

状态：`f[i][j]`表示前i个股票，i-1是否有j，的最大值

转移：

- `f[i][0]=max{f[i-1][0],f[i-1][1]+v[i-1]}`
- `f[i][1]=max{f[i-1][1],0-v[i-1]}`

答案：`f[n][0]`

方向：从0到N-1枚举j，即第几天卖

时刻保存当前为止（即0~j-1天）的最低价格P:

最大的P,-P即为答案

---

Best Time To Buy And Sell Stock II

> 可以买卖无限次

状态：`f[i][j]`表示前i个股票，i-1是否有j，的最大值

转移：

- `f[i][0]=max{f[i-1][0],f[i-1][1]+v[i-1]}`
- `f[i][1]=max{f[i-1][1],f[i-1][0]-v[i-1]}`

---

Best Time To Buy And Sell Stock III

> 可以买卖2次
>
> 零一背包+状态

状态：`f[i][k][j]`表示前i个股票，买卖k次，i-1是否有j，的最大值

转移：

- `f[i][0]=max{f[i-1][0],f[i-1][1]+v[i-1]}`
- `f[i][1]=max{f[i-1][1],f[i-1][0]-v[i-1]}`

---

Best Time To Buy And Sell Stock IV

> 可以买卖k次

状态：`f[i][k][j]`表示前i个股票，买卖k次，i-1是否有j，的最大值

转移：

- `f[i][0]=max{f[i-1][0],f[i-1][1]+v[i-1]}`
- `f[i][1]=max{f[i-1][1],f[i-1][0]-v[i-1]}`

---

跳跃游戏

> 这个题还是建议用坐标型

状态：`f[i]`表示前i个位置最大可以跳到哪里

转移：`f[i]=max{f[i-1],nums[i-1]+i-1|f[i-1]>i-1}`

边界：`f[0]=0`

答案：`f[n]>=n-1`

滚i，开2或者一个变量即可

---

Minimum Adjustment Cost

> 给定数组A，每个元素是不超过100的正整数
>  • 将A中每个元素修改后形成数组B
>  • 要求B中任意两个相邻的元素的差不能超过Target
>  • 求最小修改代价，即|A[0]-B[0]| + ... + |A[n-1]-B[n-1]|
>
> 不知道是多少就记录下来：序列加状态

状态：`f[i][j]`表示前i个位置，第i-1变成j，都符合条件，的最小花费

转移：`f[i][j]=min{f[i-1][k]+abs(j-a[i-1])|abs(k-j)<=target, k in [1,100]}`

边界：`f[0][j]=0`

---

染色问题(阿里)

> 有一个圆形被分成n个扇形，用m种颜色给每个扇形染色，相邻扇形颜色不 能相同，求方案总数(不考虑对称性)。由于这个数可能很大，因此只需返回方 案数模1e9 + 7。
>
> LintCode 1444. 

令dp[i]表示共 i 个扇形时，使用 m 种配色的上色方案数

---

分隔数组以得到最大和

状态：`f[i]`表示前i个位置，最大和

转移：`f[i]=max{f[j]+(i-j)*max[j, i-1]}`

边界：`f[0]=0`

---

### 总结

序列+状态型DP

当思考最后一步时，这一步的选择依赖于前一步的某种状态

Paint House

House Robber

---

当思考动态规划最后一步时，这一步的选择依赖于前一步的某种状态
初始化时，[0]代表前0个元素/前0天的情况
与坐标型动态规划区别
计算时，的代表前i个元素（即元素0~i-)的某种性质

### [276. Paint Fence](https://leetcode.com/problems/paint-fence/)

You are painting a fence of `n` posts with `k` different colors. You must paint the posts following these rules:

- Every post must be painted **exactly one** color.
- There **cannot** be three or more **consecutive** posts with the same color.

Given the two integers `n` and `k`, return *the **number of ways** you can paint the fence*.

```java
public int numWays(int n, int k) {
    // Base cases for the problem to avoid index out of bound issues
    if (n == 1) return k;

    int dp[] = new int[n + 1];
    dp[1] = k;
    dp[2] = k * k;

    for (int i = 3; i <= n; i++) {
        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]);
    }

    return dp[n];
}
```

### [91. Decode Ways](https://leetcode.com/problems/decode-ways/)

Given a string s containing only digits, return the **number of ways** to **decode** it. If the entire string cannot be decoded in any valid way, return `0`.

```java
public int numDecodings(String s) {
    if (s.charAt(0) == '0') {
        return 0;
    }

    int n = s.length();
    int[] f = new int[3];
    f[0] = 1;
    f[1] = 1;
    for (int i = 2; i <= n; i++) {
        f[i % 3] = f[(i - 1) % 3] * getOne(s.charAt(i - 1))
                + f[(i - 2) % 3] * getTwo(s.charAt(i - 2), s.charAt(i - 1));
    }
    return f[n % 3];
}

int getOne(char a) {
    if (a == '0')
        return 0;
    return 1;
}

int getTwo(char a, char b) {
    if (a == '0')
        return 0;
    if (a > '2')
        return 0;
    if (a == '2' && b > '6')
        return 0;
    return 1;
}
```

