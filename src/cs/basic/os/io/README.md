# I/O

> [参考](https://blog.csdn.net/lixinkuan328/article/details/114198739)

UNIX 系统下， IO 模型一共有 5 种：

- 同步阻塞 I/O、
- 同步非阻塞 I/O、
- 事件驱动 I/O （多路复用 I/O）
- 信号驱动 I/O 
- 异步 I/O

![img](https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/83871b6390d8c993af4c9b02b8dccf31.png)

为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 **用户空间（User space）** 和 **内核空间（Kernel space ）** 。

像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。

并且，用户空间的程序不能直接访问内核空间。

当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。

因此，用户进程想要执行 IO 操作的话，必须通过 **系统调用** 来间接访问内核空间

我们在平常开发过程中接触最多的就是 **磁盘 IO（读写文件）** 和 **网络 IO（网络请求和响应）**。

**从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。**

当应用程序发起 I/O 调用后，会经历两个步骤：

1. 内核等待 I/O 设备准备好数据
2. 内核将数据从内核空间拷贝到用户空间

## 多路复用 Multiplexing

select

poll

epoll

IO multiplexing 就是我们说的select，poll，epoll，也称为event driven IO。java中NIO使用的就是该模型，也就是使用的Linux的epoll库。JDK1.4之前只支持阻塞IO，在JDK1.4引入了NIO，在JDK1.7对NIO包进行了升级，支持了异步IO。现在手写NIO的比较少了，大都是直接使用netty进行开发。它们用到的就是经典的reactor模式。

由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。UNIX/Linux 下的 select、poll、epoll 就是干这个的（epoll 比 poll、select 效率高，做的事情是一样的）。这就是所谓的 “IO 多路复用”。

select调用是内核级别的，select轮询能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。所以IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。

对于多路复用其实也就是轮询多个socket。具体流程，如下图所示：

## 异步 I/O

asynchronous IO 即经典的Proactor设计模式相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。Linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。异步过程如下图所示：
