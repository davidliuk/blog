# 秒杀



### 超卖解决



悲观锁：添加同步锁，让线程串行执行

- 优点：简单粗暴
- 缺点：性能一般

乐观锁：不加锁，在更新的时候判断是否有其他线程在修改

版本号，这样需要数据库加字段；或简化为：CAS法

- 优点：性能好
- 缺点：成功率太低



改进：不再判断是否相等，只判断是否大于零，类似双锁校验





### 一人一单



因为购买数量是否修改过数据库里面不存在，所以不难使用乐观锁方案，



如果是带事物的情况下，锁的范围应该包括整个方法，否则回滚的时候又线程不安全了

- 在调用方法前加锁，可以控制的粒度更细，控制好拿什么作为锁以后，该方法吞吐量更好
- 在方法前面前加锁，粒度粗，省事，但是吞吐量太低



集群模式下，用synchronized控制并发就不安全了，用redis做分布式锁





### 异步秒杀

![截屏2023-02-08 22.20.08](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/%E6%88%AA%E5%B1%8F2023-02-08%2022.20.08.png)

![截屏2023-02-08 22.19.47](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/%E6%88%AA%E5%B1%8F2023-02-08%2022.19.47.png)