# 原子性保证

**Redis 并不一定保证原子性**（原子性：事务中的命令要不全部成功，要不全部失败）。



## 事务

### 命令

`MULTI`：开启事务

`EXEC`：执行事务

`DISCARD`：取消事务（只是清空暂存的命令队列，不能起到回滚的作用）



### 异常处理

#### 组队时错误

如下，我们在组队时输入错误的指令，redis会之间将所有指令都会失效，因为这是一个问题队列。

#### 执行时错误

执行时错误比较特殊，他在按序处理所有指令，遇到错误就按正常流程处理继续执行下去。

#### 不支持回滚原因

大概的意思是，作者不支持事务回滚的原因有以下两个：

- 他认为 Redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能；
- 不支持事务回滚是因为这种复杂的功能和 Redis 追求的简单高效的设计主旨不符合。

这里不支持事务回滚，指的是不支持事务运行时错误的事务回滚。



## lua

**为什么建议 Redis+Lua 的方式？** 主要有两点原因：

- **减少了网络开销** ：我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。
- **原子性** ：一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。



