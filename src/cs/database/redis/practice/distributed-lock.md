# 分布式锁

满足分布式系统或集群模式下多进程可见并且互斥的锁。

- 多进场可见
- 互斥
- 高可用
- 高性能
- 安全性
- 锁自身的特性：公平非公平等



三种常见方式对比：

![截屏2023-02-08 11.12.18](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/%E6%88%AA%E5%B1%8F2023-02-08%2011.12.18.png)



## Redis 实现



### 操作

#### 获取锁

```redis
# 添加锁，NX是互斥，EX是超时时间
SET lock thread1 EX 10 NX
```



#### 释放锁

由于不是单一指令，需要借助lua脚本来保证原子性

> 可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。

```lua
// 释放锁时，先比较 thread号 是否相等，避免锁的误释放
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```



### 缺点

- 不可重入

  同一个线程无法多次获取同一把锁

  解决：

  为每个锁关联⼀个请求计数器和⼀个占有它的线程。当计数为0，认为锁未被占有。就加锁解锁都用lua了

  线程请求⼀个未被占有的锁时，JVM将记录锁的占有者，并将请求计数器置1。

  若同⼀线程再请求该锁，计数将递增
  每次占⽤线程退出同步块，计数器值将递减。直到计数器为0, 锁被释放
  ⽗类和⼦类的锁的重⼊：⼦类重写⽗类的 synchonized ⽅法，然后调⽤⽗类中的⽅法，此时若没有重⼊锁，这段代码将死锁。

- 不可重试

  获取锁只尝试一次就返回false

- 超时释放

  如果超时释放的时候任务还未完成，会出现脏读等情况

  解决方案：需要有超时续期机制，redisson是watchDog机制

- 主从一致性问题

  由于主从有延迟，可能有的在别的节点加锁，有的没有加索成功
  
  解决方案：redlock算法，向集群里面每一个节点都申请，如果成功一半以上，就认为是成功，否则失败（慢、消耗大，好处不如坏处多所以一般不用）
  
- 超时时间不好设置

  。如果锁的超时时间设置过长，会影响性能，如果设置的超时时间过短会保护不到共享资源。比如在有些场景中，一个线程 A 获取到了锁之后，由于业务代码执行时间可能比较长，导致超过了锁的超时时间，自动失效，注意 A 线程没执行完，后续线程 B 又意外的持有了锁，意味着可以操作共享资源，那么两个线程之间的共享资源就没办法进行保护了。
  
  - **那么如何合理设置超时时间呢？** 我们可以基于续约的方式设置超时时间：先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间后，重新设置这个锁的超时时间。实现方式就是：写一个守护线程，然后去判断锁的情况，当锁快失效的时候，再次进行续约加锁，当主线程执行完成后，销毁续约锁即可，不过这种方式实现起来相对复杂。
  
- **Redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性**。如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。





