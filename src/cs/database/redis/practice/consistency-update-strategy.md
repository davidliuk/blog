# 缓存更新策略



## 概览

|          | 内存淘汰                                                     | 超时剔除                                                     | 主动更新                                   |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------ |
| 说明     | 不用自己维护，利用Redis内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存。 | 给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存。 | 编写业务逻辑，再修改数据库的同时，更新缓存 |
| 一致性   | 差                                                           | 一般                                                         | 好                                         |
| 维护成本 | 无                                                           | 低                                                           | 高                                         |



业务场景：

- 低一致性需求：使用内存淘汰机制。例如店铺类型等查询。
- 高一致性需求：主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存





## 主动更新策略

### Cache Aside Pattern

由缓存的调用者，在更新数据库的同时更新缓存。

需要开发者自己编码，但是可控性很高



#### 需要考虑的问题

1. 删除缓存还是更新缓存？

   - 更新缓存：每次更新数据库都更新缓存，无效读写多❌
   - 删除缓存：更新数据库时，让缓存失效，查询时再更新缓存:accept:

2. 如何保证缓存与数据库操作的同时成功或失败？

   - 单体系统，将缓存与数据库操作放在一个事务
   - 分布式系统，利用TCC等分布式事务方案

3. 先操作缓存还是先操作数据库？***多线程并发访问***

   - 先删除缓存，再操作数据库❌
   - 先操作数据库，再删除缓存:accept:

   一致性问题，操作数据库比操作redis慢得多，所以先操作数据库出现一致性问题的概率更小，且有过期时间可以作为保障

   ![IMG_B987FACCF2BA-1](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/IMG_B987FACCF2BA-1.jpeg)





### Read/Write Through Pattern

方案是由某种第三方服务提供，但是这样的服务很少



### Write Behind Caching Pattern 写回

调用者只操作缓存，由其他线程异步的将缓存数据持久化道数据库，保证最终一致性

一致性和可靠性都存在一定的问题



