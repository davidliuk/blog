# 使用原则



## 最左前缀法则

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。

如果跳跃某一列，索引将部分失效(后面的字段索引失效)。



最左边的列必须存在，否则不走索引（索引不生效）

> 右边缺省不影响，可以索引的右边部分失效



### 范围查询

范围查询（>, <）右边的列的部分索引失效

> `>=`, `<=`不会导致索引失效，所以尽量使用这两个



字符串不加单引号，不会走索引（虽然可以走普通的查）



### 模糊查询

如果仅仅是尾部模糊查询，索引不会失效，如果头部模糊查询，索引失效

- `A%` 可以
- `%A` 不行



## 索引失效



### 索引列函数

不要在索引列上进行运算操作，索引将失效。不能进行的运算包括：

- 表达式
- 函数调用

```sql
explain select * from tb_user where substring(phone,10,2) = '15'
explain select * from tb_user where id + 1 = 5
```



### 索引列隐式转换

MySQL隐式转换规则：**在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较**。

如果索引字段是字符串存的纯数字序列，查询的时候用的整数去匹配的就会发生隐式转换，将字符串转化为整数进行比较，从而发生索引失效（因为相当于对索引列进行了CAST函数），例如：

```sql
explain select * from tb_user where phone = 15000000000
```



### 模糊查询

如果仅仅是尾部模糊查询，索引不会失效，如果头部模糊查询，索引失效

- `A%` 可以索引
- `%A` 不能索引



### or连接的条件

用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。

> 都有索引就可以生效



### 数据分布影响

如果MySQL评估使用索引比全表更慢，则不使用索引。根据代价（优化器自动评估）

```sql
select * from tb_user where phone >= '150000000'
select * from tb_user where phone >= '150000015'
```





## SQL提示

SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。



use index：建议用哪个索引

`explain select * from tb_user use(idx_user_pro) where profession='1'`

ignore index：忽略哪个索引

`explain select * from tb_user ignore(idx_user_pro)`

Force index：必须用这个索引



## 覆盖索引

尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），可以减少回表查询，提高效率。

> 减少`select *`。这样及容产生回表查询

知识小贴士：

- using index condition:查找使用了索引，但是需要回表查询数据
- using where; using index:查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据



![截屏2023-02-25 20.48.48](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/%E6%88%AA%E5%B1%8F2023-02-25%2020.48.48.png)



eg. 优化如下SQL，`select id, name, password from table where name = 'li'`，如何建立索引效率最高

建立(name, password)链和索引



## 前缀索引

当字段类型为字符串(varchar,text等)时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘O,影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

语法：

`create index idx_xxx on table_name(column(n))`

长度：

找区分度比较好的字符前缀个数即可，尽量短



## 单列索引与联合索引

- 单列索引：即一个索引只包含单个列：
- 联合素引：即一个索引包含了多个列。
- 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立素引时，建议建立联合索引，而非单列索引。





在MySQL中使用!=还能走索引吗？

走不走索引，只取决于一个因素，那就是成本。

我们知道，MySQL中有一个叫做优化器的东西，他会对每一条查询sql做成本分析，然后根据分析结果选择是否使用索引或者全表扫描。

如果使用二级索引的成本更低，MySQL就会倾向于使用二级索引。

如果使用二级索引扫描的行数占比过高，导致需要频繁的回表，MySQL经过计算之后觉得走二级索引的代价太大了，就会使用全表扫描。
