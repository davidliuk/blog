# 行级锁

操作锁住对应的行数据，锁定粒度最小，发生锁冲突的概率最低



### 分类

对于行级锁，主要分为以下三类：

- 行锁 Record Lock

- 间隙锁 Gap Lock

- 临键锁 next-key lock

  =行锁 + 间隙锁



### 行锁

InnoDB实现了以下两种类型的行锁：

1. 共享锁（S）：允许一个事务去读一行，阻止其他事物获得相同数据集的排他锁
2. 排他锁（X）：允许获取排他锁的事物更新数据，阻止其他事物获取相同数据集的共享锁和排他锁



共享锁于共享锁直接兼容，其他情况均冲突

执行SQL时的锁：

![截屏2023-01-02 23.57.41](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/%E6%88%AA%E5%B1%8F2023-01-02%2023.57.41.png)

默认情况下，InnoDB在RR事物隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。

1. 针对唯一索引进行检索时，对以存在的记录进行等值匹配时，将会自动优化为行锁。
2. InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中所有的记录加锁，此时就会升级为表锁。



```sql
select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks
```





### 间隙锁/临键锁

间隙锁是锁住两个元素中间一个空隙的共享锁（目的：防止别的事物在间隙插入出现幻读现象）



默认情况下，InnoDB在RR事物隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。

1. 索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。
2. 索引上的等值查询（普通索引），向呦遍历时，最后一个值不满足查询需求时，next-key lock退化成间隙锁。
3. 索引上的范围查询（唯一索引），会访问到不满足条件的第一个值为止。（会加上对应的临键锁）



