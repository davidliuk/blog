# 事务原理

事务性质

![截屏2023-02-24 23.15.51](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/%E6%88%AA%E5%B1%8F2023-02-24%2023.15.51.png)



## redo log

保证：**持久性**

该日志文件由两部分组成：

- 重做日志缓冲(redo log buffer)
- 重做日志文件(redo log file)

前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。

**WAL**，先写日志，再往磁盘写，这样可以先记录下来

保证刷新脏页发生错误时，可以恢复数据



既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：

1. 刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。
2. 刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。
  

物理日志：存操作的指令



## undo log

保证：**原子性**

作用：

- 提供回滚
- MVCC



逻辑日志：存操作的指令的反向操作

- Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即别除undo log,因为这些日志可能还用于MVCC。
- Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的rollback segment回滚段中，内部包含1024个undo log segment。



## MVCC

保证：**隔离性**Isolation

实现：隔离级别

### 概念

#### 当前读

特点：读取的记录是最新版本，加锁防止别人修改。

- `select xxx lock in share mode`
- for update
- update
- insert
- delete

#### 快照读

简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。

- Read Committed:每次select,都生成一个快照读。
- Repeatable Read:开启事务后第一个select语句才是快照读的地方。
- Serializable:快照读会退化为当前读。

#### MVCC

全称Multi--Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现。

MvCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于：

- 数据库记录中的三个隐式字段
- undo log日志
- readview



### 隐藏字段

- `DB_TRX_ID`：最近修改事务ID
- `DB_ROLL_PTR`：回滚指针，指向这条记录的上一个版本（在undo log中），配合undo log，指向上一个版本
- `DB_ROW_ID`：隐藏主键，如果表本身没有指定主键，将会生成该隐藏字段

`ibd2sdi xxx.ibd`可以查看这张表的定义格式，可以看到所有的字段包括隐藏字段



### undo log

回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。

- 当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。
- 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。



undo log中是一个版本链（链表）

不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。



### readview

读视图，是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活动的事务（未提交的）id。确定当前快照读应该读哪个版本

ReadView中包含了四个核心字段：

| 字段           | 含义                                             |
| -------------- | ------------------------------------------------ |
| m_ids          | 当前活跃的事务ID集合                             |
| min_trx_id     | 最小活跃事务ID                                   |
| max_trx_id     | 预分配事务D,当前最大事务ID+1(因为事务ID是自增的) |
| creator_trx_id | ReadView创建者的事务ID                           |



![截屏2023-02-25 13.01.59](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/%E6%88%AA%E5%B1%8F2023-02-25%2013.01.59.png)

#### 生成时机

不同的隔离级别，生成Readview的时机不同：

- READ COMMITTED：会在事务中每一次执行快照读时生成ReadView。
- REPEATABLE READ：仅在事务中第一次执行快照读时生成Readview，后续复用该Readview,





## 一致性保证

一致性是事务追求的最终目标，实现一致性的措施包括：

- 保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证.
- 数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等
- 应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致.



### CAP和ACID中的一致性

- CAP定理中的数据一致性，其实是说分布式系统中的各个节点中对于同一数据的拷贝有着相同的值
- ACID中的一致性是指数据库的规则，如果schema中规定了一个值必须是唯一的，那么一致的系统必须确保在所有的操作中，该值都是唯一的。

由此来看CAP和ACID对于一致性的定义有着根本性的区别。



总结事务的ACID四大基本特性是保证数据库能够运行的基石，但是完全保证数据库的ACID，尤其是隔离性会对性能有比较大影响，在实际的使用中我们也会根据业务的需求对隔离性进行调整，除了隔离性，数据库的原子性和持久性相信都是比较好理解的特性，前者保证数据库的事务要么全部执行、要么全部不执行，后者保证了对数据库的写入都是持久存储的、非易失的，而一致性不仅是数据库对本身数据的完整性的要求，同时也对开发者提出了要求-写出逻辑正确并且合理的事务。最后，也是最重要的，当别人在讲一致性的时候，一定要搞清楚他的上下文。

