# 输入集



## 排序数组

以下题目均默认在非严格递增的数组上搜索，如果在非严格递减的数组上搜索，仅需把大于小于号取反，如>=变为<=，<=变为>=

问题列表见右侧TOC目录：



### 在排序数组中查找数字

```java
// in: nums[], target
int pos = searchFirst(0, nums.length - 1, (mid) -> nums[mid] >= target);
return nums[pos] == target? pos: -1;
```



### 在排序数组中查找数字第一个位置

```java
// in: nums[], target
int pos = searchFirst(0, nums.length - 1, (mid) -> nums[mid] >= target);
return nums[pos] == target? pos: -1;
```



### 在排序数组中查找数字插入位置

查找数字插入位置，如果已经存在则返回位置

```java
// in: nums[], target
int pos = searchFirst(0, nums.length - 1, (mid) -> nums[mid] >= target);
return pos;
```



### 在排序数组中查找数字末一个位置

```java
// in: nums[], target
int pos = searchLast(0, nums.length - 1, (mid) -> nums[mid] <= target);
return nums[pos] == target? pos: -1;
```



### 在排序数组中查找数字的范围

```java
// in: nums[], target
int first = searchFirst(0, nums.length - 1, (mid) -> nums[mid] >= target);
int last = searchLast(0, nums.length - 1, (mid) -> nums[mid] <= target);
return nums[first] != target? new int[]{-1, -1}: new int[]{first, last};
```



### 在排序数组中查找数字的个数

```java
// in: nums[], target
int first = searchFirst(0, nums.length - 1, (mid) -> nums[mid] >= target);
int last = searchLast(0, nums.length - 1, (mid) -> nums[mid] <= target);
return nums[first] != target? 0: last - first + 1;
```



### 在排序矩阵中查找数字

```java
// 排序矩阵，每一行从左往右递增，且下一行最小元素比上一行最大元素大
// 二维坐标转换一维坐标
// x, y -> x * m + y
// index -> x = index / m, y = index % m
boolean searchMatrix(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0 ||
        matrix[0] == null || matrix[0].length == 0) {
        return false;
    }
    int ans = searchFirst(0, n * m - 1, (mid) -> get(matrix, mid) >= target)
    
    return get(matrix, start) == target;
}

int get(int[][] matrix, int index) {
    int x = index / matrix[0].length;
    int y = index % matrix[0].length;
    return matrix[x][y];
}
```





## 转序数组



### 山峰数组







### 旋转数组



