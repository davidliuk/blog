# 输入集



## 排序数组

以下题目均默认在非严格递增的数组上搜索，如果在非严格递减的数组上搜索，仅需把大于小于号取反，如>=变为<=，<=变为>=

问题列表见右侧TOC目录：



### 在排序数组中查找数字

```java
// in: nums[], target
int pos = searchFirst(0, nums.length - 1, (mid) -> nums[mid] >= target);
return nums[pos] == target? pos: -1;
```



### 在排序数组中查找数字第一个位置

```java
// in: nums[], target
int pos = searchFirst(0, nums.length - 1, (mid) -> nums[mid] >= target);
return nums[pos] == target? pos: -1;
```



### 在排序数组中查找数字插入位置

查找数字插入位置，如果已经存在则返回位置

```java
// in: nums[], target
// 不需要判断mid==nums.length的原因：searchFirst中mid向下取整，mid永远不会等于末尾
return searchFirst(0, nums.length, (mid) -> nums[mid] >= target);
```



### 在排序数组中查找数字末一个位置

```java
// in: nums[], target
int pos = searchLast(0, nums.length - 1, (mid) -> nums[mid] <= target);
return nums[pos] == target? pos: -1;
```



### 在排序数组中查找数字的范围

```java
// in: nums[], target
int first = searchFirst(0, nums.length - 1, (mid) -> nums[mid] >= target);
int last = searchLast(0, nums.length - 1, (mid) -> nums[mid] <= target);
return nums[first] != target? new int[]{-1, -1}: new int[]{first, last};
```



### 在排序数组中查找数字的个数

```java
// in: nums[], target
int first = searchFirst(0, nums.length - 1, (mid) -> nums[mid] >= target);
int last = searchLast(0, nums.length - 1, (mid) -> nums[mid] <= target);
return nums[first] != target? 0: last - first + 1;
```



### 在排序矩阵中查找数字

```java
// 排序矩阵，每一行从左往右递增，且下一行最小元素比上一行最大元素大
// 二维坐标转换一维坐标
// x, y -> x * m + y
// index -> x = index / m, y = index % m
boolean searchMatrix(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0 ||
        matrix[0] == null || matrix[0].length == 0) {
        return false;
    }
    int ans = searchFirst(0, n * m - 1, (mid) -> get(matrix, mid) >= target)
    
    return get(matrix, start) == target;
}

int get(int[][] matrix, int index) {
    int x = index / matrix[0].length;
    int y = index % matrix[0].length;
    return matrix[x][y];
}
```





## 转序数组



### 山脉数组

#### 数组定义

山脉数组：如果数组 `A` 是一个山脉数组的话，那它满足如下条件：

**首先**，`A.length >= 3`

**其次**，在 `0 < i < A.length - 1` 条件下，存在 `i` 使得：

- `A[0] < A[1] < ... A[i-1] < A[i]`
- `A[i] > A[i+1] > ... > A[A.length - 1]`









### 旋转排序数组

#### 数组定义



