# 动态规划

避免重复计算

动态规划/自底向上 vs 记忆化搜索/备忘录法/自顶向下

动态规划优点：写起来简短且部分问题经过滚动数组优化以后可以节省空间

备忘录法优点：部分问题可以剪枝避免不必要计算（不过大部分问题是不太需要剪枝）

eg. lc397. 整数替换

---


常见问题类型

- 最优值/最值
  - 可以结合第二个状态转移方程来同步计算最值的唯一性
  - 最优子结构
- 方案数/计数
  - 方案总数
  - 概率期望
  - 构造求和
- 可行性/判别/存在

Eg. 背包类问题，可以这三种问题都有对应的题目

其实就是一种可以传递的聚合函数可以考虑是数组的reduce方法

求最值

- dp的值的类型是最优值的类型
- dp[大问题]=max{dp[小问题1]，dp[小问题2]，}
- dp[大问题]=min{dp[小问题]，dp[小问题2]，}

求方案数

- dpl的值的类型是方案数（整数）
- dp[大问题]=sum{dp[小问题1]，dp问题2}

求可行性

- dp[]的值是true/false
- dp[大问题]=or{dp[小问题], dp[小问题2]}
- 代码通常用 for 小问题 if dp[小问题]==true then break 的形式实现

不用dp的场景

- 找具体方案 99%
- 输入数据无序，除背包外，60%
- 暴力算法已经是多项式时间复杂度，80%

动态规划的题必须是求最优值/可行性/方案数这三种情况之一

动态规划的状态依赖必须有方向性，不可以有循环依赖

坐标型动态规划的状态：坐标

坐标型动态规划的方程：上一步坐标

---

### 组成部分

状态、转移、边界、顺序

确定状态

研究最优策略的最后一步
化为子问题

转移方程

根据子问题定义直接得到

初始条件和边界情况

细心，考虑周全

计算顺序

利用之前的计算结果

---


1. 遍历的过程中，所需的状态必须是已经计算出来的。
2. 遍历结束后，存储结果的那个位置必须已经被计算出来。

要素

- 状态：根据题目类型来设计
- 转移/方程
- 边界
  - 起点在哪
  - 第0行第0列

- *顺序*
- *答案*：终点在哪

确定状态

- 研究最优策略的最后一步
- 化为子问题

转移方程

- 根据子问题定义直接得到

初始条件和边界情况

- 细心，考虑周全

计算顺序

- 利用之前的计算结果

---

解题步骤

1. 判断是否DP
2. 判断哪种DP
3. 要素设计

关键词

- 路径一坐标

- 子序列一坐标
- 和一背包

## 状态

动态规划需要开一个状态数组，数组的每个元素或者`f[i]`或者`f[i][j]`代表什么

特殊情况下会有多个状态和多个状态转移方程

确定状态需要两个意识：

- 最后一步，最后一步有哪些方案，如何转移

  - 定义的状态知道最后一步是什么

  - 不然就需要通过额外一重循环来遍历选择空间（一个状态限制选择空间）

    eg. 完全背包

- 子问题

### 最后一步

以石子游戏为例，

虽然我们不知最优策略是什么，但是最优策略肯定是K枚硬币a1,a2,,ak面值加起来是27

所以一定有一枚最后的硬币：ak

除掉这枚硬币，前面硬币的面值加起来是27-ak

1. 关键点1

		我们不关心前面的K-1枚硬币是怎么拼出27-ak的（可能有1种拼法，可能有100种拼法)，而且我们现在甚至还不知道ak和K，但是我们确定前面的硬币拼出了27-ak

2. 关键点2

		因为是最优策略，所以拼出27-ak的硬币数一定要最少，否则这就不是最优策略了

### 状态分类

可以抽象成DAG上的最短路、最长路问题

1. 第一类状态：以当前结点为起点的性质（最优质、方案数、可行性）
2. 第二类状态：以当前结点为终点的性质（最优质、方案数、可行性）

大多数情况下，使用如下：

1. 递归写法，记忆化搜索，只能采用的第一类状态，因为他只能是自顶向下
2. 迭代写法，动态规划，可以第一类、也可以第二类
   1. 第二类状态，最为常用，大多数问题都是采用这种
   2. 第一类状态，
      - 主要是从记忆化搜索翻译过来是采用
      - 或者是博弈问题，因为博弈问题只能从头到尾来算边不可逆，且终点不知

### 常见状态

- 坐标型

  `dp[i]`：到i的性质，本质上就是从起点到i结尾的一条路径就是子序列
  
  - 子序列
  
    `dp[i]`：以i结尾的子序列
  
- 序列型

  - 前序型
  
    `dp[i]`：前i个元素的性质
  
  - 后序型
  
    `dp[i]`：从i开头到结尾的性质
  
- 背包型

  `dp[i][j]`：前i个元素，费用总和为j

  多维费用：`dp[i][j][k]`

  eg. Coin change

- 状态型/离散型

  为每个有意义状态编号（无效状态或非法状态无需编号，其值相当于0不被考虑），各个状态可能有各自不同的转移方程

  eg. 

  最大子数组积，`dp[i][j]`其中j为0/1表示最大值/最小值

  粉刷房子II，i-1位粉刷成什么颜色

  股票买卖，0/1表示是否持有股票

- 状压型

  排列类问题需要状压dp

  本质是各个位置的元素的离散状态压缩成一个2/n进制数

## 转移

### 最值

- dp的值的类型是最优值的类型
- dp[大问题]=max{dp[小问题1]，dp[小问题2]，}
- dp[大问题]=min{dp[小问题1]，dp[小问题2]，}

这类问题有时可以结合单点修改线段树进行优化

#### 博弈型

由于换序，要取反

dp[i]=max{k-dp[i-1]};

### 计数

#### 方案数

- dp的值的类型是方案数
- dp[大问题]=sum{dp[小问题1]，dp问题2}

#### 组合数

dp[大问题]=sum{dp[小问题1]*C(n, i)}

卡特兰数：`f[n]=sum{f[i]f[n-1-i]}`

#### 概率型

### 判别

#### 可行性

- dp的值是true/false
- dp[大问题]=or{dp[小问题], dp[小问题2]}
- 代码通常用 for 小问题 if dp[小问题]==true then break 的形式实现

## 优化

- 空间：滚动数组优化

  一般的：多开一个位置，然后%，可以减少rotate的时间，时间空间优化很大

  如果仅以来于上一层，可以滚动数组都无需开，但是需要注意顺序：

  - 倒序更新，如01背包问题、三角形路径问题

  如果依赖本层和上一层，可以滚动数组都无需开，但是需要注意顺序：

  - 正序更新，如完全背包问题、矩阵路径问题

- 时间

  - 斜率优化
  - 四边形优化
  - 线段树优化（单点修改、区间最值）

动态规划的题目分为两大类，

它们都存在一定的递推性质。

- 一种是求最优解类，典型问题是背包问题，

  递推性质叫做 「最优子结构」 ——即当前问题的最优解取决于子问题的最优解，

- 另一种就是计数类，比如这里的统计方案数的问题，

  当前问题的方案数取决于子问题的方案数。

## 类型

动态规划的题型分类有什么用？

不同题型的动态规划的状态表示方法是不同的
如果成功的找对了题型，就能够解决DP最难的状态表示问题

1. 坐标型动态规划(20%)

  1. 一维

     状态：`dp[i]`表示从起点到**坐标i**的最优值/方案数/可行性

  2. 二维

     状态：`dp[i][j]`表示从起点到**坐标i,j**的最优值/方案数/可行性

     代表题：Triangle, Unique Paths

  3. 子序型/接龙型(5%)

     状态：`dp[i]`表示以**坐标i**结尾的子序列的最优值/方案数/可行性

     - 最长
     - 个数
     
     题目通常会给你个接龙规则：问你最长的龙有多长
     
     状态：`dp[i]`表示以坐标为i的元素结尾的最长龙的长度
     
     方程通常是：`dp[i]=max{dp[j]]+1|ok(j,i)}, j的后面可以接上i`

2. 序列型/前缀型动态规划(20%)

   状态：`f[i]`表示**前i个**元素`a[0],a[1],...,a[i-1]`的某种性质

   - 划分型动态规划(20%)

     `dp[i]`表示**前i个**字符的最优值/方案数/可行性

     `dp[i][j]`表示前i个字符划分为j个部分的最优值/方案数/可行性

     代表题：Word Break, Word Break Ill

   - 匹配型/双序型

     `dp[i][j]`表示第1个字符串的**前i个**学符匹配上第2个字符串的**前j个**字符的最优值/方案数/可行性

     代表题：Longest Common Subsequence, Wildcard Matching
     
   - 背包型动态规划(10%)

     `dp[i][j]`表示**前ⅰ个**物品里选出物品组成和为j的大小的最优值/方案数/可行性

     代表题：Backpack 系列

4. 区间型动态规划(15%)

   `dp[i][j]`表示区间`[i,j]`的最优值/方案数/可行性

   代表题：Stone Game, Burst Balloons, isPalindrome

4. 博弈型动态规划(5%)

   可以结合各类定义：前序型/后序型、区间型、

7. 综合型动态规划(5%)

6. 概率型动态规划

   求概率期望

9. 状压型动态规划

   TSP

10. 树上型动态规划

---

1. 坐标型动态规划(20%)

   - 子序列型动态规划(5%)
     - 最长
     - 个数

2. 序列型动态规划(20%)

3. 前缀型动态规划

   - 划分型动态规划(20%)
   - 匹配型/双序型
   - 背包型动态规划(10%)

4. 区间型动态规划(15%)

6. 博弈型动态规划(5%)

7. 综合型动态规划(5%)

8. 概率型动态规划

9. 状压型动态规划

   TSP

10. 树型动态规划

---

## 特征

- 最优子结构

  最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面状态推导出来。

  注意要确保我们考察了最优解中用到的所有子问题。

  1. 证明问题最优解的第一个组成部分是做出一个选择；
  2. 对于一个给定问题，在其可能的第一步选择中，假定你已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择；
  3. 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；
  4. 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。

  方面：

  1. 原问题的最优解中涉及多少个子问题；
  2. 确定最优解使用哪些子问题时，需要考察多少种选择。

- 无后效性

  已经求解的子问题，不会再受到后续决策的影响。

  - 在推导后面阶段状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步步推导出来的。
  - 某阶段状态一旦确定，就**不受之后阶段的决策影响**。

  无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。

- 重复子问题

  如果有大量的重叠子问题，我们可以用空间将这些子问题的解存储下来，避免重复求解相同的子问题，从而提升效率。

## 常见术语

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

子数组/子串：连续

## 计数和最优DP

可以发现，计数 DP 和最优化 DP 都是在一个范围 ![\Omega](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 内求一个值（大小值、最优值），这个值通过将 ![\Omega](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 中的所有元素做一次处理，再对处理值做一次整合得到。

例如，对于 0-1 背包问题，![\Omega](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 中的元素为背包内的所有物品组成的集合，对于 ![\Omega](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 中的一个方案 ![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)，我们对 ![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 做一次处理，处理得到的结果 ![w(S)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 为 ![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 中物品的总价值，对所有得到的处理值，我们取最大值，得到问题的答案。

对于计数问题，![\Omega](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 中的元素为要计算元素个数的集合 ![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)，它的处理是把所有的 ![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 中元素变为 ![1](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)，然后将这些 ![1](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 通过加法的方式汇总起来，因为每一个 ![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 中元素都对应一个 ![1](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)，所以这样得到的值就是 ![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 中元素个数。

当汇总操作为最大/最小值时，我们可以将 ![\Omega](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 分成任意若干个部分，只需这些部分的并为 ![\Omega](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 即可，无需无交的条件。而计数问题由于不满足这个条件，所以我们需要将 ![\Omega](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 分成若干个部分，这些部分两两无交，这就是与最优化 DP 的区别。
