# Body Animation

- Main Approaches to Animation 
- Motion Editing Techniques 
- Arc Length Parameterization 

### Keyframe

### Animation

Animation=Post(time)

Collections of motion curves

- Single degree of freedom(DOF)
- Single Joint (up to 6 DOF)
  - 3 rotation
  - 3 translation (if root or changing bone lengths)
- Entire body

Motion curve representation

- Usually cubic splines
  - Bezier (Catmul-Rom) splines
  - B-Splines

### Main Approaches to Animation

Keyframe

- Key poses specified at selected points in time

- Spline curves used to interpolate body position and orientation between key poses

Mocap

- motion data representing position of root and joint angles as a function of time
  - No splines -> every frame a key


- Usually generated by capturing a live actor’s performance

Procedural

- IK-based (Ubisoft)

- Optimization-based

- Physically-based (Ragdoll)
  - Motions generated based on the law of physics

---

### Pose Space

### Channels

Many animation systems typically separate the n-dimensional  animation into 1-dimensional curves (one for each DOF) called  “Channels”

- a channel typically stores the value of a scalar function over  some 1D domain (time, distance, health, etc).   
- Can be a joint angle or arbitrary parameter value (such as mass)
- normally refers to “scripted” data for a DOF
  - does not refer to the more general case of a DOF changing over time  due to physics, procedural animation, etc. 


IK can change length of link

Array of channels

- An animation can be stored as an  array of channels

- an animation is  stored as a 2D array of floats  (NumDOFs x NumFrames) 

Array of Poses

- An alternative way to store an  animation is as an array of poses
- This also forms a 2D array of  floats (NumDOFs x NumFrames) 

### Poses vs. Channels

Which is better 

- Array of poses is great for playing back relatively simple  animations that need maximum performance. This is often  the case in many video games 
- Array of channels is used when flexibility is important or  generality is valued over raw performance 

The bottom line: 

- Poses are faster
- Channels are more flexible and can potentially use less memory 

## Main Editing Techniques

- Interactive Posing
- Adding constraints
  - Position
  - Orientation
- Optimizing motion over a sequence of poses

### Warp

**Change Playback speed**

Given motion curve $m(t)$

$t=h(\tau)=s\cdot\tau$

$\tau$ is the new independent variable (i.e. normal time)

$s$ controls the speed of motion 

- To speed up motion adjust time and/or spline knots
  - $t=h(\tau)=s\cdot\tau$ where s > 1
- To slow down motion adjust time and/or spline knots
  - $t=h(\tau)=s\cdot\tau$ where 0 < s < 1 

![image-20241107144808313](https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/image-20241107144808313.png)

### Blending

**blend two animation (lerp)**

Allows two motion curves m1(t) and m2(t) to be interpolated

$m(t_k)=(1-\alpha)m_1(t_k)+\alpha m_2(t_k),\alpha\in[0,1]$

![image-20241107144923215](https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/image-20241107144923215.png)

### Layering (compositing)

![image-20241107145323987](https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/image-20241107145323987.png)

### Cross Dissolve

**transition from one animation to another (lerp)**

> linear blend

$m(t)=(1-\alpha(t))m_1(t)+\alpha(t) m_2(t)$

$\alpha\in[0,1],t\in[t_1,t_2]$

$\alpha(t)=\frac{t-t_1}{t_2-t_1}$

![image-20241107145555875](https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/image-20241107145555875.png)



## Arc Length Parameterization



## Animation Guide

Problem  – After playing an animation with root translation, the root  joint will snap back to the initial position and orientation  after playing the animation   Solution – Add a virtual joint called a “Guide” as a parent of root joint  – As a result, root position and orientation transforms are  now with respect to the guide frame of reference  – At the end of each animation, update the guide joint  position to the current position of the character in the world 

## Foot IK

Allow characters walk over uneven terrain

IK target

Root position

- determine which foot is lower
- Update vertical position of root joint

Foot Position

- use Limb IK with Lfoot_target and Rfoot_target to position feet

## Animation Blending

We can define blending operations that affect poses

A blend operation takes one or more animations/poses  as input and generates one animation/pose as output

Parameters such as speed, direction, angle, height etc.  are used to control the blend 

### Cross Dissolve

The most common and useful pose blend operation is the  ‘cross dissolve’ of two poses p1 and p2  

It is ok for Euler Angles to use Lerp 

 … but quaternions need to use …  Slerp

#### Handling Angles

If a DOF represents an angle, we need to have the interpolation check for crossing the 0/360 boundary

- Always want to take the shortest path
- Assumes angles range from 0 to 360

```c++
if (theta1-theta2 > 180) theta=lerp(theta1-360,theta2,u);
else if (theta2-theta1 > 180) theta=lerp(theta1,theta2-360,u);
else theta=lerp(theta1,theta2,u);
```

#### Quaternions

Same goes for quaternions. Since there are always two solutions, we need to force the interpolation to go the ‘short way’. 

```c++
if (q1 * q2 > 0) q=slerp(q1,q2,u);
else  q=slerp(-q1,q2,u);
```

#### Stand to Walk

Consider a situation where we want a character to blend from a stand animation to a walk animation

![image-20241107150933378](https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/image-20241107150933378.png)



$s_{walk}=Lerp(1,\frac{T_{walk}}{T_{run}},u)$

### Basic Math Blend Operations

- Add
- Subtract
- Scale

### Body Turn

 As an example of math blending operations, consider a  character that walks and turns   One approach to achieving this is to have an underlying walk  animation and ‘layer’ (add) some body turn on top of it   We use a ‘turn_right’ animation and a ‘default’ straight  forward walk animation as building blocks   The subtract blender gives us the difference between the  turn_right and default walk animations at each point in time   We then scale this turning delta and add it on top of the  underlying walk animation. The scale factor value (u) can be  based on how sharply the character should turn (-1…1) 

---

- Bilinear Blend
- Combine Blender
- Mirror Blender 
