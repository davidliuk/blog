# Trace Note

## 项目背景

### 项目介绍

雁过留痕 Trace Note 是一款基于地点的社交 app。用户可以在一个地点开启一个 Trace AR 场景，并在场景中放置 Note 虚拟留言板，不同用户见可以在同一个 Trace 中相互交互评论。Note 留言板提供字体、材质等个性化装饰选项。用户可以通过每日签到打卡获取代币，用来抢购个性化装扮，以提高个性化程度，并作为激励机制提高用户每日的活跃度。

### 人员分工

- 3个同学，1人全职文案和海报，2位开发同学客户端和后端共同负责
- 2人客户端、SwiftUI主要界面、ARKit场景交互页面
- 1人后端、

## 项目开发

### 技术选型

后端：

- Spring Boot 2.8, Spring AOP
- MySQL, Redis, Redisson
- hutool
- RabbitMQ, Spring AMQP
- 文档：knife4j

客户端：

- SwiftUI做的界面
- ARKit做的AR交互

### 系统业务





2022年中国高校计算机大赛-移动应用创新赛全国二等奖 

字节跳动第四届青训营万码奔腾奖(一等奖)

### 项目亮点

1. 利用 AOP 实现注解校验用户登陆状态及用户权限。使用 Redis 实现分布式 Session，解决集群间登录态同步问题；
1. 使用 MD5 + 随机加盐 算法保证用户密码不被泄漏，提高系统的安全性。
2. 使用 Redis 对高频访问 Trace 进行缓存，降低 DB 压力同时提升 90% 的数据查询性能。
3. 使用模版模式实现了通用缓存访问静态方法，并解决了缓存雪崩、缓存穿透和缓存击穿的问题。
4. 使用 Redis 的 Geo 数据结构存储附近 Trace，并使用 Geo Search 命令实现高性能 Trace 查询及按距离排序。
5. 使用 Redis ZSet 数据结构存储用户点赞信息，保证用户只能点赞一次，并可以展示记录点赞的先后排序。
6. 使用 Redis Set 数据结构实现用户关注、共同关注功能，并使用 Redis AOF 持久化防止关注数据丢失。
7. 使用 Redis BitMap 实现用户连续签到统计功能，提高存储的效率并减少内存的占用。
8. 基于推模式实现关注 Feed 流，保证了新 Note 消息的及时可达，并减少用户访问的等待时间。
9. 使用 Lua 脚本实现库存预检解决了超卖问题、实现一人一单。通过 RabbitMQ 实现异步订单创建、超时取消订单。

密码存储：加盐 MD5



由于传统的MD5加密，黑客可以通过查散列值字典（例如彩虹表），得到某用户的密码。因此目前可以用MD5加密配合上随机盐值，可极大的防止密码被破解。

用户系统

- 密码存储：使用 MD5 + 随机加盐 算法保证用户密码不被泄漏，提高系统的安全性。

  和 MD5 摘要值一样

  为什么加盐，随机生成一个 20 位字符串，防止非法用户用字典攻击的方式暴力破解。

- AOF鉴权：

  - 哪些权限
    - 普通用户
    - 内容审核员
    - 区域管理员
    - 超级管理员
    - 封号 ban
  - 什么模型，什么表：RBAC，五张表
  - AOF实现与Filter的区别
    - Filter基于servlet
    - AOF实现更加灵活可以加注解和参数

- 用户关注

  - 使用 Redis Set 数据结构实现用户关注、共同关注功能，只需要集合求交集即可很快的得到两个用户的共同关注。
  - 并使用 Redis AOF 持久化防止关注数据丢失。

- 用户签到

  使用Redis BitMap结构进行存储，每个月





---



列举一些该项目可以扩展的点，有能力的同学可以自己尝试实现（注意，没有自己实现过千万别写到简历上！！！做没做过一问便知）：

1. 使用 Redis + Token 机制实现单点登录（补充到上述第 1 点中）
2. 对 Redis 的所有 key 设置 N + n 的过期时间，从而合理使用内存并防止缓存雪崩；针对热点店铺缓存，使用逻辑过期（或自动续期）机制解决缓存击穿问题，防止数据库宕机。
3. 使用 Redis 的 Geo + Hash 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及按距离排序，实测相对于传统 DB 查询 + 业务层计算的方式，性能提升 xx%。
4. 使用 Redis Set 数据结构实现用户关注、共同关注功能（交集），实测相对于 DB 查询性能提升 xx%，并使用 Redis AOF + 业务层日志防止关注数据丢失。（理解 AOF 和 RDB 持久化机制后再写这点）
5. 基于 Spring Scheduler 实现对热点数据的定期检测和缓存预加载，提升用户的访问体验，并通过 Redisson 分布式锁保证集群中同一时刻的定时任务只执行一次。
6. 关注 Feed 流可以改为推拉结合模式（活跃用户用推、普通用户用拉）
7. 使用哨兵集群来提升 Redis 的读并发量、可用性和稳定性；或者使用 Redis 分片集群来提升 Redis 读写并发量、总存储容量，保障可用性和稳定性。
8. 随着系统用户增多，使用 Redis HyperLogLog 代替 DB 来实现店铺和点评的 UV 统计，提高 xx% 的查询分析性能并解决 xx% 的内存空间。



1. 利用AOP实现注解校验用户登陆状态及用户权限。使用 Redis 实现分布式 Session，解决集群间登录态同步问题；

2. 使用 Redis 对高频访问 Trace 进行缓存，降低 DB 压力同时提升 90% 的数据查询性能。

3. 使用模版模式实现了通用缓存访问静态方法，并解决了缓存雪崩、缓存穿透和缓存击穿的问题。

4. 使用 Redis 的 Geo + Hash 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及按距离排序。

5. 使用 Redis ZSet 数据结构存储用户点赞信息，保证用户只能点赞一次，并基于 ZSet 记录点赞的时间。

6. 使用 Redis Set 数据结构实现用户关注、共同关注功能（交集），实测相对于 DB 查询性能提升 xx%，并使用 Redis AOF + 业务层日志防止关注数据丢失。

7. 使用 Redis BitMap 实现用户连续签到统计功能。

8. 基于推模式实现关注 Feed 流，保证了新点评消息的及时可达，并减少用户访问的等待时间。

9. 个性饰品抢购：使用 Lua 脚本实现库存预检解决了超卖问题、实现一人一单。通过 RabbitMQ 实现异步订单创建，流量削峰。

   使用 Redis + Lua 脚本实现库存预检，并通过 RabbitMQ 实现订单的异步创建，解决了超卖问题、实现一人一单。实现相比传统数据库，秒杀性能提高了 xx%。



再列举一些该项目可以扩展的点，有能力的同学可以自己尝试实现（注意，没有自己实现过千万别写到简历上！！！做没做过一问便知）：



1. 使用 Redis + Token 机制实现单点登录（补充到上述第 1 点中）
2. 对 Redis 的所有 key 设置 N + n 的过期时间，从而合理使用内存并防止缓存雪崩；针对热点店铺缓存，使用逻辑过期（或自动续期）机制解决缓存击穿问题，防止数据库宕机。
3. 使用 Redis 的 Geo + Hash 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及按距离排序，实测相对于传统 DB 查询 + 业务层计算的方式，性能提升 xx%。
4. 使用 Redis Set 数据结构实现用户关注、共同关注功能（交集），实测相对于 DB 查询性能提升 xx%，并使用 Redis AOF + 业务层日志防止关注数据丢失。（理解 AOF 和 RDB 持久化机制后再写这点）
5. 基于 Spring Scheduler 实现对热点数据的定期检测和缓存预加载，提升用户的访问体验，并通过 Redisson 分布式锁保证集群中同一时刻的定时任务只执行一次。
6. 关注 Feed 流可以改为推拉结合模式（活跃用户用推、普通用户用拉）
7. 使用哨兵集群来提升 Redis 的读并发量、可用性和稳定性；或者使用 Redis 分片集群来提升 Redis 读写并发量、总存储容量，保障可用性和稳定性。
8. 随着系统用户增多，使用 Redis HyperLogLog 代替 DB 来实现店铺和点评的 UV 统计，提高 xx% 的查询分析性能并解决 xx% 的内存空间。

---

Id生成器

1. 如何生成
2. 有没有什么问题
   1. 是否会被猜出来

幂等性用订单id
