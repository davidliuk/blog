## 个人

### 自我介绍

面试官您好，我是刘大维。我本科就读于东北大学软件工程，硕士将于宾夕法尼亚大学计算机科学系深造，研究主要是计算机图形学。我将从四个方面来介绍我自己：

首先，我具备良好的学习能力和对技术研发的热爱。在大学期间，我的学业成绩优异，加权平均分为92.8，位列年级前1%。我曾荣获国家奖学金、优秀学生奖学金、优秀学生标兵、优秀毕业生等荣誉。

其次，我积累了丰富的开发经验。在大三暑期，我在京东担任后端开发工程师，参与多个线上项目的研发。此外，我主导开发的项目《雁过留痕》和《仿掘金官网》分别获得了移动应用创新赛国家二等奖和字节跳动青训营一等奖。

第三，我拥有出色的沟通能力和强烈的责任心。在课程项目和科创竞赛中，我常担任团队组长，提前规划工作量，并根据每位成员的优势分配任务，保证项目完成度。

最后，我勤奋好学、善于总结思考。我坚信细致和踏实是掌握知识的关键，因此在学习新技术时，我会反复实践。我习惯于总结学习笔记，并将其发布在个人博客上。

### 未来规划

在硕士期间，我将在宾夕法尼亚大学进修，深入学习GPU编程、GPU架构和分布式系统等相关知识。通过系统的学习和实践，我希望能够掌握这些领域的核心技术，加深我对计算机领域的理解和并行系统的设计和开发能力。

毕业后，我计划回国发展，成为一名后端开发工程师。我希望能够将在硕士阶段所学到的知识和技能运用到实际工作中，为公司的项目开发和优化贡献自己的力量。同时，我也希望能够不断学习和提升自己，成为一名技术精湛、责任心强的后端开发专家，为公司的发展和创新做出贡献。 

### 不留美国

我选择回中国发展而不是留在美国，首先是因为我的亲人都在国内，我的父母年纪已经比较大了，也比较传统，所以我希望能够在他们身边多陪伴他们。

其次，我喜欢国内更加便利的设施和服务，比如便捷的地铁系统、更加高效的外卖和快递等服务。我相信在国内高效、便利的环境中工作和生活，将能够提高我的工作效率和生活质量。  

此外，我认为中国作为一个科技发展迅速的国家，有着丰富的发展机遇和潜力。我希望能够回到中国，深入了解和参与国内科技行业的发展，与优秀人才共同探索和实践，为公司的发展和成长贡献自己的力量。 

## JD.com

后端开发工程师 算法工具研发部

参与言犀AI开发计算平台的基础架构开发、重构与部署；以及领航者营销增长平台活动页面生成服务的重构。

负责重构资源管理服务，使用 ConfigMap 提供自动化和配置化的机器资源拆分方案。

通过 Kubernetes Informer 机制结合观察者模式、异步、丢弃策略等方式提高资源余量计算的效率，峰值性能提升15倍。 

负责优化 CI/CD 工具链，使用 Argo Workflows 构建云原生的 CI 工作流，并通过 GitOps 触发 Argo CD 进行持续部署。 

构建 helm chart 提供平台私有化部署能力，参与为中国建设银行提供平台的私有化部署。 

负责领航者营销增长平台活动页面生成服务的重构，使用策略模式优化代码结构，提高代码复用性。

> 讲一下自己在实习中遇到的一些难点，怎么解决。

helm hook 私有化部署能力

由于服务的种类繁多，且依赖关系复杂，最初版本的helm chart需要install再upgrade一次。比如有的数据库、minIO这样对象存储的服务需要先于应用服务创建。

1. **明确 Hook 类型**：根据需求选择合适的 hook 类型，如 `pre-install`, `post-install`, `pre-delete`, `post-delete` 等。
2. **管理 Hook 资源**：使用 `helm.sh/hook-delete-policy` 注解来管理 hook 执行后资源的删除策略。

通过 Kubernetes Informer 机制结合观察者模式、异步、丢弃策略等方式提高资源余量计算的效率，峰值性能提升15倍。 

本来是按照命名空间来划分，每次informer监听到资源的变化，都会把这个资源所在的命名空间重新计算一边，这样在峰值的时候性能很差，尤其是服务刚启动的时候，刚启动的时候informer相当于做了一次全量复制，我们开发环境里面有9000个pod，一次都加载进来，这里有很多重复的计算

## 雁过留痕

> 问项目，打开共享屏幕讲了之前做的一个项目，讲完之后敲代码。

雁过留痕 Trace Note 是一款基于地点的社交 app。用户可以在一个地点开启一个 Trace AR 场景，并在场景中放置 Note 虚拟留言板，不同用户见可以在同一个 Trace 中相互交互评论。Note 留言板提供字体、材质等个性化装饰选项。用户可以通过每日签到打卡获取代币，用来抢购个性化装扮，以提高个性化程度，并作为激励机制提高用户每日的活跃度。

用户系统

- 密码存储：使用 MD5 + 随机加盐 算法保证用户密码不被泄漏，提高系统的安全性。

  和 MD5 摘要值一样

  由于传统的 MD5 加密，黑客可以用字典攻击（例如彩虹表），得到某用户的密码。因此目前可以用MD5加密配合上随机盐值，可极大的防止密码被破解。

  为什么加盐，随机生成一个 20 位字符串，防止非法用户用字典攻击的方式暴力破解。

- AOF 鉴权：

  - 哪些权限
    - 普通用户
    - 内容审核员
    - 区域管理员
    - 超级管理员
    - 封号 ban
  - 什么模型，什么表：RBAC，五张表
  - AOF实现与Filter的区别
    - Filter 基于 servlet
    - AOF实现更加灵活可以加注解和参数，且各接口的位置更近便于维护

- 用户关注

  - 使用 Redis Set 数据结构实现用户关注、共同关注功能，只需要集合求交集即可很快的得到两个用户的共同关注。
  - 并使用 Redis AOF 持久化防止关注数据丢失。

- 用户签到

  使用Redis BitMap结构进行存储，每个月

博客系统

- Geo Hash

  

- 秒杀：

  redisIdWorker.nextId, orderId

  SECKILL_SCRIPT, 检查呀、库存是否足够、用户是否买过

  先发送延迟队列消息，再发送订单消息；保证订单一定会被砍

- 缓存

  - 雪崩：

    同一时段大量的缓存 key **同时失效**或者 **Redis 服务宕机**，导致大量请求到达数据库，带来巨大压力。

    随机过期时间 N+n

  - 击穿：

    缓存击穿是指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db。

    Set: 逻辑过期

    Query: redis锁，加线程池异步重新设置缓存

  - 穿透：

    客户端请求的数据在缓存中和数据库中**都不存在**，这样缓存永远不会生效，这些请求都会打到数据库。

    缓存空值

## 仿掘金

TrustSVD

冗余存储

帖子表存储点赞数、收藏数

DCL Singleton

双重检测

- 外层if：实例只是被创建一次，当实例已经被创建好了就不要后续操作，直接返回
- 内层if：实例未被创建时，多个线程同时竞争锁，只有一个线程竞争成功并创建实例，其他竞争失败的线程就会阻塞等待，当第一线程释放锁后，这些竞争失败的线程就会继续竞争，但是实例已经创建好了，所以需要再次进行if判断

volatile

- 解决指令重排序，给 instance 成员变量加上 volatile 关键字
- `localRef`的作用是在已经初始化的情况下（即绝大多数情况下），减少读取 volatile 变量的次数（减少了一次），这样大概可以提升 40%的性能。

```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    private static volatile IdGenerator instance;
    private IdGenerator() {}
    public static IdGenerator getInstance() {
        IdGenerator localRef = instance;
        if (localRef == null) {
            synchronized(IdGenerator.class) {
                if (localRef == null) {
                    instance = localRef = new IdGenerator();
                }
            }
        }
        return localRef;
    }
    public long getId() {
        return id.incrementAndGet();
    }
}
```



- 良好 Java 基础、熟悉集合、熟练使用 Java8 特性、熟悉 JUC 并发编程。
- 熟悉 MySQL 的使用、理解锁、事务、索引的原理、了解常见的性能优化的方法。
- 熟悉 Redis 的使用、理解数据结构、线程模型、内存淘汰机制，能够解决缓存穿透、缓存雪崩、缓存击穿、双写一致性问题。 
- 熟悉 RabbitMQ 的使用、了解死信队列、延迟队列的使用、了解消息幂等性、消息可靠性的解决方案。
- 熟悉 Spring 的 IoC、AOP、事务和设计模式。熟悉 Spring Boot、MyBatis 等主流开发框架，可以独立开发业务模块。 
- 熟悉 Git 的使用、熟悉常用 Linux 命令。熟悉 Docker、Kubernetes 的基本应用。熟悉 Helm chart 的开发。

## Java

### Collections

HashMap

ConcurrentHashMap

### Feature

- Stream
- Interface, default static
- functional interface
- Lambda
- Optional
- Date-Time API

### JUC

#### ThreadPool

##### 参数

ThreadPoolExecutor

1. corePoolSize 核心线程数目

   - 最多**保留**的线程数，可以为 0

2. maximumPoolSize 最大线程数目

   - 核心线程 + 救急线程

3. keepAliveTime 生存时间

   针对救急线程，执行完成以后存留的时间的数值，如 20，30 等

4. unit 时间单位

   针对救急线程，执行完成以后存留的时间的单位，如秒、毫秒等

5. workQueue 任务队列上限

   阻塞队列，`ArrayBlockingQueue(100)`

6. threadFactory 线程工厂（optional）

   如可以用来设置线程命名规则、注册统一异常处理器

7. handler 拒绝策略（optional）

   四种，线程池、等待队列、救急线程都满的时候，如何处理

   - AbortPolicy，抛出 `RejectedExecutionException`来拒绝新任务的处理。
   - CallerRunsPolicy，调用者自己去运行这个任务，这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
   - DiscardPolicy，新加入的丢弃掉，直接丢弃掉。
   - DiscardOldestPolicy，把任务队列中等待最久的（最先加入队列的）丢弃掉，然后新任务加入进来。

##### 关闭/任务不丢失

保证未执行完成的任务不丢失，需要在抛出 InterruptedException 异常后，将任务参数保证到 MQ 中；

注意：

1. 尽量不要把未完成的任务保存到本地磁盘，尤其是在经常扩缩容的弹性集群里；
2. 捕获 InterruptedException 异常后，不要做重试等耗时操作；
3. 需要监控任务都发送到 MQ 中的时间，以便调整 kill -9 强制执行前的等待时间。

**使用 MQ 保证任务必须执行完成**

通过上面介绍的两种方式，可以处理大部分正常停止服务丢数据的任务。不过对于极端情况下，比如断电、断网等，需要严格保证任务不丢失的场景还是不能满足业务需要，这种情况下就需要依赖 MQ。

方案是：使用线程池的 submit 方法提交任务，通过 future 获取到任务执行完成再返回给 MQ 消费完成。

#### ThreadLocal

##### 线程关联

ThreadLocal 并不是一个独立的存在，它与 Thread 类是存在耦合的, java.lang.Thread 类针对 ThreadLocal 提供了如下支持：

```java
ThreadLocal.ThreadLocalMap threadLocals = null;
```

`Thread`类有一个类型为`ThreadLocal.ThreadLocalMap`的实例变量`threadLocals`，也就是说每个线程有一个自己的`ThreadLocalMap`。

`ThreadLocalMap`类似`HashMap`的结构，只是`HashMap`是由**数组+链表**实现的，而`ThreadLocalMap`中并没有**链表**结构，采用**线性探测法**解决hash冲突。

##### 内存泄漏

根源：Thread 重复利用，导致 value 强引用链一直存在，从而导致内存泄漏。

**ThreadLocal** 在 **ThreadLocalMap** 中是被 Entry 中的 Key 弱引用的，因此如果 ThreadLocal 没有外部强引用来引用它，那么 ThreadLocal 会在下次 JVM 垃圾收集时被回收。这个时候就会出现 Entry 中 Key 已经被回收，出现一个 null Key 的情况，这样称为 key 过期。

外部读取 ThreadLocalMap 中的元素是无法通过 null Key 来找到 Value 的。因此**如果当前线程的生命周期很长**，一直存在，那么其内部的 ThreadLocalMap 对象也一直生存下来，这些 null key 就存在一条强引用链的关系一直存在：Thread --> ThreadLocalMap-->Entry-->Value，这条强引用链会导致 Entry 不会回收，Value 也不会回收，但 Entry 中的 Key 却已经被回收的情况，造成内存泄漏。

JDK 中存在一些措施来保证 ThreadLocal 尽量不会内存泄漏：

在 ThreadLocal 的 get()、set()、remove()方法调用的时候会清除掉线程 ThreadLocalMap 中所有 Entry 中 Key 为 null 的 Value，并将整个 Entry 设置为 null。

##### 线程脏读

线程复用会产生**脏数据**。由于线程池会重用 Thread 对象，那么与 Thread 绑定的类的静态属性 ThreadLocal 变量也会被重用。如果在实现的线程 run() 方法体中不显式地调用于线程相关的 ThreadLocal 信息，那么倘若下一个线程不调用 set() 设置初始值，就可能 get 到重用的线程信息，包括 ThreadLocal 所关联的线程对象的 value 值。

> 很多web框架底层采用线程池，如tomcat底层用的线程池。

**解决方案**

Threadlocal与线程池一起使用，如何避免脏读问题，就是说因为线程池里面的线程重复使用，上一个任务set到threadlocal里面的值下一个任务用这同一个线程可能错误的读到。如何避免这样的情况发生

在使用ThreadLocal和线程池一起时，为了避免脏读问题，可以在每次任务执行完毕后，显式地调用ThreadLocal的remove方法来清除ThreadLocal中的数据。这样可以确保下一个任务使用的线程不会读取到上一个任务设置的值。

通过finally块去调用remove方法清理对象

##### 变量传递

1. 用线程安全的容器

2. InheritableThreadLocal

3.  TransmittableThreadLocal

#### Lock

### JVM

#### 类加载

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承(Inheritance)的关系来实现的，而是通常使用组合(Composition)关系来复用父加载器的代码。

工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去完成加载。

**JVM 双亲委派模型是一种类加载机制，它的主要作用是**

- **保证 Java 核心库的安全性和稳定性**
- **避免重复加载类**

### 垃圾回收器

![截屏2023-03-31 18.47.04](https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/%E6%88%AA%E5%B1%8F2023-03-31%2018.47.04.png)

## Young Generation

### Serial 收集器

Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

优点：它**简单而高效（与其他收集器的单线程相比）**。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。

缺点：

### ParNew 收集器

**ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。**

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

### Parallel Scavenge 收集器

Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 **那么它有什么特别之处呢？**

```text
-XX:+UseParallelGC 使用 Parallel 收集器+ 老年代串行
-XX:+UseParallelOldGC 使用 Parallel 收集器+ 老年代并行
```

**Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。** Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

## Tenured Generation

### Serial Old 收集器

**Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。

### Parallel Old 收集器

**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

### CMS 收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。

CMS 收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

#### 过程

1. 初始标记(CMS initial mark)
2. 并发标记(CMS concurrent mark)
3. 重新标记(CMS remark)
4. 并发清除(CMS concurrent sweep)

其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快;

并发标记阶段就是从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行;

而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录(详见 3.4.6 节中关于增量更新的讲解)，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短;

最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的 对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一 起工作，所以从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。通过图 3-11 可以比较清楚地看到 CMS 收集器的运作步骤中并发和需要停顿的阶段。

#### 缺点

- CMS 收集器对处理器资源非常敏感。

  向并发设计的程序都对处理器资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程(或者说处理器的计算能力)而导致应用程序变慢，降低总吞吐量。CMS 默认启动的回收线程数是(处理器核心数量+3)/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过 25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。

- 由于 CMS 收集器无法处理“浮动垃圾”(Floating Garbage)，有可能出现“Concurrent Mode Failure”失败进而导致另一次完全“Stop The World”的 Full GC 的产生。

- CMS 是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。

### 混合

### G1 收集器

**G1 (Garbage-First) 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**

首先要有一个思想上的改变，在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代(Minor GC)，要么就是整个老年代(Major GC)，再要么就是整个Java堆(Full GC)。

而 G1可以面向堆内存任何部分来组成回收集(Collection Set，一般简称CSet)进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。

取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器。被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记-清除”算法不同，G1 
  - 从整体来看，基于“标记-整理”算法实现的收集器；
  - 从局部来看，基于“标记-复制”算法实现的收集器。

- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

G1 收集器的运作大致分为以下几个步骤：

![G1 收集器](https://oss.javaguide.cn/github/javaguide/java/jvm/g1-garbage-collector.png)

- **初始标记**：仅仅只是标记一下**GC Roots**能直接关联到的对象，并且修改TAM S 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要 Stop-The-World 停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际 并没有额外的停顿。
- **并发标记**：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段**耗时较长**，但可与用户程序并发执行。当对象图扫描完成以 后，还要重新处理SAT B记录下的在并发时有引用变动的对象。
- **最终标记**：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SAT B记录。
- **筛选回收**：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region 的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

#### 优点

相比 CMS，G1 的优点有很多

- 可以指定最大停顿时间、
- 分 Region 的内存布局、
- 按收益动态确定回收集这些创新性设计带来的红利，

单从最传统的算法理论上看，G1 也更有发展潜力。与 CMS 的“标记-清除”算法不同

- 从整体来看是基于“标记-整理”算法实现的收集器，但从局部(两个 Region 之间)上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着 G1 运作期间**不会产生内存空间碎片**，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。

负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

![img](https://cdn.jsdelivr.net/gh/davidliuk/images@master/blog/format,png.png)

新生代的对象会在经过多次垃圾回收后仍然存活时，被晋升到老年代。一般来说，新生代的对象在经过几次垃圾回收后，如果仍然存活，就会被晋升到老年代。这个次数可以通过 JVM 的参数进行配置，默认15次。

老年代的对象会在进行 Full GC（Full Garbage Collection）时被回收。Full GC 是指对整个 Java 堆进行垃圾回收，包括新生代和老年代。Full GC 一般会比较耗时，因此应该尽量避免 Full GC 的发生。可以通过调整 JVM 的参数、优化代码等方式来减少 Full GC 的发生。

**面向服务端应用，针对具有大内存、多处理器的机器**。(在普通大小的堆里表现并不

惊喜)，最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案

如:在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒; ( G1通过每次只清理一 部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长)

**用来替换掉JDK1.5中的CMS收集器**

在下面的情况时，使用G1可能比CMS好:

- 超过50%的Java堆被活动数据占用;
- 对象分配频率或年代提升频率变化很大;
- GC停顿时间过长(长于0.5至1秒)。

## RabbitMQ

### 幂等性

在RabbitMQ中，幂等性是指在消息传递过程中，无论消息被传递多少次，最终的结果都是一致的。

eg支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣歌，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等

在生产者端，可以通过为每条消息生成一个唯一的ID（比如业务绑定的订单id，或者生成一个唯一id），并将该ID作为消息的一部分发送到RabbitMQ中。当消费者接收到一条消息时，先检查该消息的ID是否已经被处理过，如果已经处理过，则直接忽略该消息，否则执行相应的业务逻辑，并将该消息的ID标记为已处理。

### 消息积压

1. **水平扩展消费者**：消费者数量增多，则可以并行提升消息消费的速度，从而避免消息积压的问题。
2. 优化消费者处理速度：提升消费者的消费速度也可以避免消息积压的问题，它的解决方案有：
   - 优化消费者处理消息的逻辑，减少不必要的计算和 I/O 操作。
   - 对于可以并行处理的任务，使用多线程或异步处理来提高吞吐量。
3. 限流生产者和使用背压机制：
   - 在生产者端实施限流策略，确保消息产生的速度不会超过系统的处理能力。
   - 使用背压机制，即当消息队列达到某个阈值时，通知生产者降低发送速率或暂停发送。
4. **使用死信队列**：在消费者处理消息出现失败或超时的情况下，加入消息重试机制或将异常消息放入死信队列，避免异常消息一直占用队列资源。
5. **监控和告警**：设置合理的告警阈值，当消息积压达到一定程度时及时发出告警，以便快速响应和处理。

### 消息丢失

- 生产者到 RabbitMQ：事务机制、**Confirm 机制**。

  在生产者开启了 confirm 模式之后，每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq之中，rabbitmq 会给你回传一个ack消息，告诉你这个消息发送OK了；如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息失败了，你可以进行重试。而且你可以结合这个机制知道自己在内存里维护每个消息的id，如果超过一定时间还没接收到这个消息的回调，那么你可以进行重发。

- RabbitMQ 自身：**持久化**、集群（普通模式、**镜像模式**）。

  - 持久化处理

    RabbitMQ 的消息默认存放在内存上面，如果不特别声明设置，消息不会持久化保存到硬盘上面的，如果节点重启或者意外 crash 掉，消息就会丢失。

    所以就要对消息进行持久化处理。如何持久化，下面具体说明下：

    要想做到消息持久化，必须满足以下三个条件，缺一不可。

    - Exchange 设置持久化
    - Queue 设置持久化
    - Message 持久化发送：发送消息设置发送模式 deliveryMode=2，代表持久化消息

  - HA，消息会同步到其他节点上，可以设置同步的节点个数，但吞吐量会下降。

- RabbitMQ 到消费者：**basicAck 机制**、死信队列、消息补偿机制。

  使用rabbitmq提供的ack机制，服务端首先关闭rabbitmq的自动ack，然后每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。才把消息从内存删除。

## Redis

### 持久化

AOF

RDB

### 缓存问题

- 雪崩：

  同一时段大量的缓存 key **同时失效**或者 **Redis 服务宕机**，导致大量请求到达数据库，带来巨大压力。

  随机过期时间 N+n

- 击穿：

  缓存击穿是指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db。

  Set: 逻辑过期

  Query: redis锁，加线程池异步重新设置缓存

- 穿透：

  客户端请求的数据在缓存中和数据库中**都不存在**，这样缓存永远不会生效，这些请求都会打到数据库。

  缓存空值

### 双写一致性

Cache Aside Pattern

先操作数据库，再删除缓存

- 更新缓存：每次更新数据库都更新缓存，无效读写多 ，且会不一致
- 操作数据库比操作 redis**慢得多**，所以先操作数据库出现一致性问题的概率更小

缓存延时双删

- 延迟：因为 mysql 和 redis 主从节点数据不是实时同步的，同步数据需要时间。
- 第一次删除为了删除脏读，也有可能提前实现前面操作的最终一致。
- 第二次删除为了最终一致。

缺点：

1. 延时双删，有等待环节，如果系统要求低延时，这种场景就不合适了。
2. 延时双删，不适合“秒杀”这种频繁修改数据和要求数据强一致的场景。
3. 延时双删，延时时间是一个预估值，不能确保 mysql 和 redis 数据在这个时间段内都实时同步或持久化成功了。

**重试机制**

我们可以引入**消息队列**，将第二个操作（删除缓存）要操作的数据先加入到消息队列，由消费者来操作数据。

- 如果**删除缓存失败**，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是**重试机制**。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。
- 如果**删除缓存成功**，就要把数据从消息队列中移除，避免重复操作。

读取 binlog 异步删除缓存

重试删除缓存机制会造成好多业务代码入侵。其实，还可以通过数据库的 binlog 来异步淘汰 key。

### 集群

#### 哈希槽 16384

哈希槽实质就是一个数组，数组[0,2^14-1]形成hash slot空间。

解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽(slot)，用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。

Redis Cluster 通常有 16384 个哈希槽，要计算给定 key 应该分布到哪个哈希槽中，我们只需要先对每个 key 计算 CRC-16（XMODEM） 校验码，然后再对这个校验码对 16384(哈希槽的总数) 取模，得到的值即是 key 对应的哈希槽。

因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。

集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者不建议redis cluster节点数量超过1000个。那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。

#### 不保证强一致性

节点挂了会写丢失

#### 通信 Gossip

- MEET ：在 Redis Cluster 中的某个 Redis 节点上执行 CLUSTER MEET ip port 命令，可以向指定的 Redis 节点发送一条 MEET 信息，用于将其添加进 Redis Cluster 成为新的 Redis 节点。
- PING/PONG ：Redis Cluster 中的节点都会定时地向其他节点发送 PING 消息，来交换各个节点状态信息，检查各个节点状态，包括在线状态、疑似下线状态 PFAIL 和已下线状态 FAIL。
- FAIL ：Redis Cluster 中的节点 A 发现 B 节点 PFAIL ，并且在下线报告的有效期限内集群中半数以上的节点将 B 节点标记为 PFAIL，节点 A 就会向集群广播一条 FAIL 消息，通知其他节点将故障节点 B 标记为 FAIL 。

## MySQL

### 锁

### 索引

### 事务

### 引擎

### 优化

## Network

### HTTP

#### Method

| 方法    | 动作                               | 内容 |
| ------- | ---------------------------------- | ---- |
| GET     | 向服务器请求文档                   | 空   |
| HEAD    | 请求关于文档的信息，而不是文档本身 | 空   |
| PUT     | 从客户端向服务器发送文档           |      |
| POST    | 从客户端向服务器发送一些信息       |      |
| TRACE   | 删除网页                           |      |
| DELETE  | 回送输入的请求                     |      |
| CONNECT | 预留                               |      |
| OPTIONS | 询问有关可用的选项                 | 空   |

#### 状态码

`1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

`2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。

- 「**200 OK**」是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。
- 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

`3xx` 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- 「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

`4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。
- 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。
- 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

`5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
- 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

### HTTPS

#### TLS 握手

1. ClientHello

   Client Random

2. SeverHello

   Server Random

   数字证书

3. 客户端回应

   客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

   `pre-master key`

   **服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」**。

4. 服务器的最后回应

### TCP

建立：syn, ack+syn, ack

关闭：fin, ack, fin, ack 2msl

再来回顾下四次挥手双方发 `FIN` 包的过程，就能理解为什么需要四次了。

- 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，因此是需要四次挥手。

无差错、不丢失、不重复、按序到达。

滑动窗口、重传机制、拥塞控制、拥塞控制

## OS

### 进程

线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。

- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。
- 时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。
- 被终止或结束运行

### IO

#### dma



## 分布式

CAP

BASE

微服务划分原则：

领域检查

领域检查可以为我们的服务划分提供方向性的指导，使服务划分更明确、各有规划性。

依赖DAG检查

DAG在数学上是有向无环图，指从任何一点出发都不会回到这个点，即不存在环路，我们服务的依赖也应如此。服务间要尽量避免双向或循环依赖，否则可能会导致灾难性的后果。质量领域中的业主线下验收就存在一个有向环图，下图中第一个就是业主发起线下申请人出现的有向有环图问题，究其原因就是系统边界划分不清晰导致质量领域事件出现在了验收单领域里，增加了系统间交互的复杂性和系统边界模糊，调用链路复杂等情况发生。经过领域界限上下文重新规划和代码优化之后的教系统交付如下图二，可以看到边界清晰了，系统交互简化了，调用链路也减少了。

分布式事务检查

分布式事务调用的成本很高，服务拆分尽量避免产生跨服务事务

性能分布检查

对于特别耗资源的操作应尽量独立。这部分咱们系统中应该没有类似场景大家知道这方面的范式即可。

稳定（易变）性检查

一个服务中如存在稳定和不稳定的模块，应该将两者拆分。这部分也是暂时没有在咱们的业务场景中遇到，基本上都分别部署的，质量领域中目前验收模版配置是频繁发生的也是单独拆分成子领域迭代，验收模版配置的变更不会影响验收应用层，大家在进行领域划分系统设计的时候关注这方面的影响即可。

## LP

1. Customer Obsession （客户至上）

Leaders start with the customer and work backward. They work vigorously to earn and keep customer trust. Although leaders pay attention to competitors, they obsess over customers.

Who was your most difficult customer? （最刁难的客户？）

Give me an example of a time when you did not meet a clients expectation. What happened, and how did you attempt to rectify the situation? （没有满足客户期望，你怎么改善？）

When youre working with a large number of customers, its tricky to deliver excellent service to them all. How do you go about prioritizing your customers needs? （多个客户的需求，怎么排序？）

Tell the story of the last time you had to apologize to someone. （向别人道歉的例子。）

2. Ownership （主人翁精神）

Leaders are owners. They think long term and dont sacrifice long-term value for short-term results. They act on behalf of the entire company, beyond just their own team. They never say thats not my job.

Tell me about a time when you had to leave a task unfinished. （哪次没完成的工作就离开）

Tell me about a time when you had to work on a project with unclear responsibilities. （缺少清晰职责的项目）

3. Invent and Simplify (创新和简化）

Leaders expect and require innovation and invention from their teams and always find ways to simplify. They are externally aware, look for new ideas from everywhere, and are not limited by not invented here. As we do new things, we accept that we may be misunderstood for long periods of time.

Tell me about a time when you gave a simple solution to a complex problem. （复杂问题的简化方案）

Tell me about a time when you invented something.（创造新事物）

4. Are Right, A lot (决策正确）

Leaders are right a lot. They have strong judgment and good instincts. They seek diverse perspectives and work to disconfirm their beliefs.

Tell me about a time when you were wrong.（判断失误的例子）

Tell me about a time when you had to work with incomplete data or information. （不充分数据和信息，你应该如何写？）

5. Learn and Be Curious (好奇求知）

Leaders are never done learning and always seek to improve themselves. They are curious about new possibilities and act to explore them.

Tell me about a time when you influenced a change by only asking questions. （通过问问题，带来改变）

Tell me about a time when you solved a problem through just superior knowledge or observation.（用知识和观察解决问题）

6. Hire and Develope The Best (招聘和培养最好的人才）

Leaders raise the performance bar with every hire and promotion. They recognize exceptional talent and will move them throughout the organization. Leaders develop leaders and take seriously their role in coaching others. We work on behalf of our people to invent mechanisms for development like Career Choice.

Tell me about a time when you mentored someone. （指导别人的时刻）

Tell me about a time when you made a wrong hire. When did you figure it out and what did you do? （招聘错误员工的例子）

7. Insist on the Highest Standards （高标准原则）

Leaders have relentlessly high standards many people may think these standards are unreasonably high. Leaders are continually raising the bar and driving their teams to deliver high-quality products, services, and processes. Leaders ensure that defects do not get sent down the line and that problems are fixed so they stay fixed.

Tell me about a time when you couldnt meet your own expectations on a project. （工作中没达到自己预期的例子）

Tell me about a time when a team member didnt meet your expectations on a project.（团队成员没有达到你的预期，你应该如何写）

8. Think Big (远见卓识）

Thinking small is a self-fulfilling prophecy. Leaders create and communicate a bold direction that inspires results. They think differently and look around corners for ways to serve customers.

Tell me about your proudest professional achievement. （最骄傲的成绩）

Tell me about a time when you went way beyond the scope of the project and delivered. （工作超出项目范围，并带来好的结果）

9. Bias for Action (行动为王）

Speed matters in business. Many decisions and actions are reversible and do not need extensive study. We value calculated risk taking.

Describe a time when you saw some problem and took the initiative to correct it rather than waiting for someone else to do it. （看到问题并主动解决）

Tell me about a time when you took a calculated risk. （计算并承担可承受的风险，决策行动）

Tell me about a time you needed to get information from someone who wasnt very responsive. What did you do? （别人不睬你，你怎么办）

10. Frugality （节俭有效 足智多谋）

Accomplish more with less. Constraints breed resourcefulness, self-sufficiency, and invention. There are no extra points for growing headcount, budget size or fixed expense.

Tell me about a time when you had to work with limited time or resources. （有限时间和资源）

11. Earn Trust (赢得信任）

Leaders listen attentively, speak candidly, and treat others respectfully. They are vocally self-critical, even when doing so is awkward or embarrassing. Leaders do not believe their or their teams body odour smells of perfume. They benchmark themselves and their teams against the best.

What would you do if you found out that your closest friend at work was stealing? （最好的公司朋友偷窃，你怎么办）

Tell me about a time when you had to tell someone a harsh truth. （怎么告诉别人严酷的事实）

12. Deep Dive （深入理解）

Leaders operate at all levels, stay connected to the details, audit frequently, and are skeptical when metrics and anecdotes differ. No task is beneath them.

Give me two examples of when you did more than what was required in any job experience. （做的比要求的多很多）

Tell me about something that you learned recently in your role. （最近工作学习到的东西）

13. Have Backbone; Disagree and Commit (勇气，敢于说出不同意见，并服从大局）

Leaders are obligated to respectfully challenge decisions when they disagree, even when doing so is uncomfortable or exhausting. Leaders have conviction and are tenacious. They do not compromise for the sake of social cohesion. Once a decision is determined, they commit wholly.

Tell me about a time when you did not accept the status quo. （挑战现状）

Tell me about an unpopular decision of yours. （不受欢迎的决定）

Tell me about a time when you had to step up and disagree with a team members approach. （你如何跳出来，不同意队友的工作方式）

If your direct manager was instructing you to do something you disagreed with, how would you handle it? （和直接老板意见不同，你如何处理）

14. Deliver Results （追求结果）

Leaders focus on the key inputs for their business and deliver them with the right quality and in a timely fashion. Despite setbacks, they rise to the occasion and never settle.

By providing an example, tell me when you have had to handle a variety of assignments. Describe the results. （同时处理多任务）

What is the most difficult situation you have ever faced in your life? How did you handle it? （人生中最难的时候，如何处理)

Give me an example of a time when you were 75% of the way through a project, and you had to pivot strategyhow were you able to make that into a success story? （有了大部分想法，如何让它成功实现）

## OOD

### 设计原则 SOLID

- S – Single responsibility principle 单一责任原则

  一个类应该有且只有一个去改变他的理由，这意味着一个类应该只有一项工作。

- O – Open close principle 开放封闭原则

  对象或实体应该对扩展开放，对修改封闭

  (Open to extension, close to modification)。

- L – Liskov substitution principle 里氏替换原则

  任何一个子类或派生类应该可以替换它们的基类或父类

- I – Interface segregation principle 接口分离原则

  不应该强迫一个类实现它用不上的接口

- D – Dependency inversion principle 依赖反转原则

  抽象不应该依赖于具体实现，具体实现应该依赖于抽象

  High-level 的实体不应该依赖于 low-level 的实体

### 解题法 5C

- Clarify
- Core objects
- Cases
- Classes
- Correctness

Clarify 通过和面试官交流，去除题目中的歧义，确定答题范围

Core objects 确定题目所涉及的类，以及类之间的映射关系

Cases 确定题目中所需要实现的场景和功能

Classes 通过类图的方式，具体填充题目中涉及的类

Correctness 检查自己的设计，是否满足关键点

### Clarify

What

针对题目中的**关键字**来提问，帮助自己更好的确定答题范围。

> 大多数的关键字为名词，通过名词的属性来考虑

How

针对问题主题的规则来提问，帮助自己明确解题方向。

> 此类问题没有标准答案，你可以提出一些解决方法，通过面试官的反应， 选择一个你比较有信心(简单)的方案

### Core Object

为了完成设计，需要哪些类?

- 这是和面试官初步的纸面 contract
- 承上启下，来自于Clarify的结果，成为Use case的依据
- 为画类图打下基础

如何定义Core Object ?

- 以一个Object作为基础，**线性思考**

  有进有出，从哪来到哪去

- 确定Objects之间的映射关系

### Cases

- 什么是 Use case ?

  在你设计的系统中，需要支持哪些功能?

- 为什么要写 Use cases ?

  - 这是你和面试官白纸黑字达成的第二份共识，把你将要实现的功能列在白板上
  - 帮助你在解题过程中，理清条例，一个一个Case实现
  - 作为检查的标准

- 如何写 Use cases ?

  - 利用定义的Core Object, 列举出每个Object对应产生的use case.
  - 每个use case只需要先用一句简单的话来描述即可

### Class

- 什么是类图?

- 为什么要画类图? 

  - 可交付，Minimal Viable Product
  - 节省时间，不容易在 Coding 上挣扎
  - 建立在Use case上，和之前的步骤层层递进，条例清晰，便于交流和修 改
  - 如果时间允许/面试官要求，便于转化成Code

- 怎么画类图?

  - 遍历你所列出的use cases

  - 对于每一个use case，更加详细的描述这个use case在做什么事情

    例如：take external request -> ElevatorSystem takes an external request, and decide to push this request to an appropriate elevator

  - 针对这个描述，在已有的Core objects里填充进所需要的信息


如何知道一个函数，是否成功完成任务？

地下一层电梯关闭，这时有人在地下一层按了向上的按钮，会发生什么?

Use boolean instead of void

成功的话返回true, 否则返回false

如何知道是什么地方出错?

Use exceptions

并行 VS 串行

单线程 VS 多线程

### Correctness

- Validate use cases (检查是否支持所有的 use case)
- Follow good practice (面试当中的加分项，展现一个程序员的经验)
- S.O.L.I.D
- Design pattern

### 预定

**Search criteria** -> Search() -> **`List<Result>`** -> Select() -> **Receipt**

**Search criteria**

- 人数：无拼桌，每张桌子大小相同，不会有超过桌子大小的人数
- 日期：是否允许预定多日以后的? - 允许
- 时间：是否所有时间都允许预定?- 24/7
- Design: FindTableForReservation(Timeslot t)
- Timeslot contains Date and time

`List<Result>` 

- 当选择的时间段可以/不行时，系统应该给出什么反馈?

  Error

- 做法一:

  Result == Timeslot

  - Design: `List<Timeslot> findTableForReservation(Timeslot t)`
  - Possible Challenge: 跟面试官讨论如何获得这个List

- 做法二:

  - 可以预定:直接进入Confirm阶段

  - 不能预定:Throw exception / Show message

  - Design: Pair<Table, Timeslot> findTableForReservation(Time slot) throws NoTableForReservationException

  - Design: void confirmReservation(Pair<Table, Timeslot> reservation)

  为什么我们可以跳过`List<Result>`这个步骤?

  因为 Table 是一样的，用户不用选择也不会知道是订1号桌还是2号桌

