const questions = {
  count: 379,
  list: [
    {
      id: 1469,
      value: 26,
      time: "2022-12-27T07:23:10.215000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1469,
        frontend_question_id: "215",
        question_id: 215,
        title: "数组中的第K个最大元素",
        content:
          "<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code><strong>k</strong></code> 个最大的元素。</p>\n\n<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>[3,2,1,5,6,4] 和</code> k = 2\n<strong>输出:</strong> 5\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>[3,2,3,1,2,4,5,5,6] 和</code> k = 4\n<strong>输出:</strong> 4</pre>\n\n<p> </p>\n\n<p><strong>提示： </strong></p>\n\n<ul>\n\t<li><code>1 <= k <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        level: 2,
        slug_title: "kth-largest-element-in-an-array",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1478,
      value: 23,
      time: "2022-11-16T11:11:18.871000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1478,
        frontend_question_id: "206",
        question_id: 206,
        title: "反转链表",
        content:
          '给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。\n<div class="original__bRMd">\n<div>\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" style="width: 542px; height: 222px;" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5]\n<strong>输出：</strong>[5,4,3,2,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" style="width: 182px; height: 222px;" />\n<pre>\n<strong>输入：</strong>head = [1,2]\n<strong>输出：</strong>[2,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>\n\t<li><code>-5000 <= Node.val <= 5000</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>\n</div>\n</div>\n',
        level: 1,
        slug_title: "reverse-linked-list",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1448,
      value: 21,
      time: "2022-12-22T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1448,
        frontend_question_id: "236",
        question_id: 236,
        title: "二叉树的最近公共祖先",
        content:
          '<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n\n<p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" target="_blank">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" style="width: 200px; height: 190px;" />\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>节点 <code>5 </code>和节点 <code>1 </code>的最近公共祖先是节点 <code>3 。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" style="width: 200px; height: 190px;" />\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>输出：</strong>5\n<strong>解释：</strong>节点 <code>5 </code>和节点 <code>4 </code>的最近公共祖先是节点 <code>5 。</code>因为根据定义最近公共祖先节点可以为节点本身。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2], p = 1, q = 2\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[2, 10<sup>5</sup>]</code> 内。</li>\n\t<li><code>-10<sup>9</sup> <= Node.val <= 10<sup>9</sup></code></li>\n\t<li>所有 <code>Node.val</code> <code>互不相同</code> 。</li>\n\t<li><code>p != q</code></li>\n\t<li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>\n</ul>\n',
        level: 2,
        slug_title: "lowest-common-ancestor-of-a-binary-tree",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1560,
      value: 20,
      time: "2022-05-13T07:20:56.550000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1560,
        frontend_question_id: "124",
        question_id: 124,
        title: "二叉树中的最大路径和",
        content:
          '<p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径<strong> 至少包含一个 </strong>节点，且不一定经过根节点。</p>\n\n<p><strong>路径和</strong> 是路径中各节点值的总和。</p>\n\n<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" style="width: 322px; height: 182px;" />\n<pre>\n<strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" />\n<pre>\n<strong>输入：</strong>root = [-10,9,20,null,null,15,7]\n<strong>输出：</strong>42\n<strong>解释：</strong>最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目范围是 <code>[1, 3 * 10<sup>4</sup>]</code></li>\n\t<li><code>-1000 <= Node.val <= 1000</code></li>\n</ul>\n',
        level: 3,
        slug_title: "binary-tree-maximum-path-sum",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1681,
      value: 18,
      time: "2022-10-26T01:14:22.472000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1681,
        frontend_question_id: "3",
        question_id: 3,
        title: "无重复字符的最长子串",
        content:
          '<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串 </strong>的长度。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = "abcabcbb"\n<strong>输出: </strong>3 \n<strong>解释:</strong> 因为无重复字符的最长子串是 <code>"abc"，所以其</code>长度为 3。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = "bbbbb"\n<strong>输出: </strong>1\n<strong>解释: </strong>因为无重复字符的最长子串是 <code>"b"</code>，所以其长度为 1。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = "pwwkew"\n<strong>输出: </strong>3\n<strong>解释: </strong>因为无重复字符的最长子串是 <code>"wke"</code>，所以其长度为 3。\n     请注意，你的答案必须是 <strong>子串 </strong>的长度，<code>"pwke"</code> 是一个<em>子序列，</em>不是子串。\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = ""\n<strong>输出: </strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= s.length <= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 由英文字母、数字、符号和空格组成</li>\n</ul>\n',
        level: 2,
        slug_title: "longest-substring-without-repeating-characters",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1240,
      value: 18,
      time: "2022-09-21T14:30:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1240,
        frontend_question_id: "450",
        question_id: 450,
        title: "删除二叉搜索树中的节点",
        content:
          "<p>给定一个二叉搜索树的根节点 <strong>root </strong>和一个值 <strong>key</strong>，删除二叉搜索树中的&nbsp;<strong>key&nbsp;</strong>对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>\n\n<p>一般来说，删除节点可分为两个步骤：</p>\n\n<ol>\n\t<li>首先找到需要删除的节点；</li>\n\t<li>如果找到了，删除它。</li>\n</ol>\n\n<p><strong>说明：</strong> 要求算法时间复杂度为&nbsp;O(h)，h 为树的高度。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\n给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n\n    5\n   / \\\n  4   6\n /     \\\n2       7\n\n另一个正确答案是 [5,2,6,null,4,null,7]。\n\n    5\n   / \\\n  2   6\n   \\   \\\n    4   7\n</pre>\n",
        level: 2,
        slug_title: "delete-node-in-a-bst",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1538,
      value: 17,
      time: "2022-10-26T01:14:22.472000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1538,
        frontend_question_id: "146",
        question_id: 146,
        title: "LRU缓存机制",
        content:
          '<div class="title__3Vvk">运用你所掌握的数据结构，设计和实现一个  <a href="https://baike.baidu.com/item/LRU" target="_blank">LRU (最近最少使用) 缓存机制</a> 。</div>\n\n<div class="original__bRMd">\n<div>\n<p>实现 <code>LRUCache</code> 类：</p>\n\n<ul>\n\t<li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</li>\n\t<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>\n\t<li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>\n</ul>\n\n<p> </p>\n</div>\n</div>\n\n<p><strong>进阶</strong>：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n<strong>输出</strong>\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n<strong>解释</strong>\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= capacity <= 3000</code></li>\n\t<li><code>0 <= key <= 10000</code></li>\n\t<li><code>0 <= value <= 10<sup>5</sup></code></li>\n\t<li>最多调用 <code>2 * 10<sup>5</sup></code> 次 <code>get</code> 和 <code>put</code></li>\n</ul>\n',
        level: 2,
        slug_title: "lru-cache",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1387,
      value: 15,
      time: "2022-10-12T03:13:28.049000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1387,
        frontend_question_id: "297",
        question_id: 297,
        title: "二叉树的序列化与反序列化",
        content:
          '<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>\n\n<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>\n\n<p><strong>提示: </strong>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href="/faq/#binary-tree">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" style="width: 442px; height: 324px;" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,null,4,5]\n<strong>输出：</strong>[1,2,3,null,null,4,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中结点数在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-1000 <= Node.val <= 1000</code></li>\n</ul>\n',
        level: 3,
        slug_title: "serialize-and-deserialize-binary-tree",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1631,
      value: 15,
      time: "2022-03-31T14:49:08.936000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1631,
        frontend_question_id: "53",
        question_id: 53,
        title: "最大子序和",
        content:
          "<p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-2,1,-3,4,-1,2,1,-5,4]\n<strong>输出：</strong>6\n<strong>解释：</strong>连续子数组 [4,-1,2,1] 的和最大，为 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1]\n<strong>输出：</strong>-1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-100000]\n<strong>输出：</strong>-100000\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> <= nums[i] <= 10<sup>5</sup></code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>\n",
        level: 1,
        slug_title: "maximum-subarray",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1477,
      value: 14,
      time: "2022-03-16T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1477,
        frontend_question_id: "207",
        question_id: 207,
        title: "课程表",
        content:
          "<p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>\n\n<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> ，表示如果要学习课程 <code>a<sub>i</sub></code> 则 <strong>必须</strong> 先学习课程  <code>b<sub>i</sub></code><sub> </sub>。</p>\n\n<ul>\n\t<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>\n</ul>\n\n<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 2, prerequisites = [[1,0]]\n<strong>输出：</strong>true\n<strong>解释：</strong>总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 2, prerequisites = [[1,0],[0,1]]\n<strong>输出：</strong>false\n<strong>解释：</strong>总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= numCourses <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= prerequisites.length <= 5000</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 <= a<sub>i</sub>, b<sub>i</sub> < numCourses</code></li>\n\t<li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li>\n</ul>\n",
        level: 2,
        slug_title: "course-schedule",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1651,
      value: 12,
      time: "2022-08-25T01:54:27.108000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1651,
        frontend_question_id: "33",
        question_id: 33,
        title: "搜索旋转排序数组",
        content:
          "<p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>\n\n<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 <= k < nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>\n\n<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>4,5,6,7,0,1,2]</code>, target = 0\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>4,5,6,7,0,1,2]</code>, target = 3\n<strong>输出：</strong>-1</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], target = 0\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 5000</code></li>\n\t<li><code>-10^4 <= nums[i] <= 10^4</code></li>\n\t<li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li>\n\t<li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>\n\t<li><code>-10^4 <= target <= 10^4</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(log n)</code> 的解决方案吗？</p>\n",
        level: 2,
        slug_title: "search-in-rotated-sorted-array",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1662,
      value: 11,
      time: "2022-06-21T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1662,
        frontend_question_id: "22",
        question_id: 22,
        title: "括号生成",
        content:
          '<p>数字 <code>n</code>&nbsp;代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的 </strong>括号组合。</p>\n\n<p>有效括号组合需满足：左括号必须以正确的顺序闭合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>["((()))","(()())","(())()","()(())","()()()"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>["()"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n',
        level: 2,
        slug_title: "generate-parentheses",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1680,
      value: 11,
      time: "2022-05-13T07:20:56.550000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1680,
        frontend_question_id: "4",
        question_id: 4,
        title: "寻找两个正序数组的中位数",
        content:
          "<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,3], nums2 = [2]\n<strong>输出：</strong>2.00000\n<strong>解释：</strong>合并数组 = [1,2,3] ，中位数 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2], nums2 = [3,4]\n<strong>输出：</strong>2.50000\n<strong>解释：</strong>合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [0,0], nums2 = [0,0]\n<strong>输出：</strong>0.00000\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [], nums2 = [1]\n<strong>输出：</strong>1.00000\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2], nums2 = []\n<strong>输出：</strong>2.00000\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 <= m <= 1000</code></li>\n\t<li><code>0 <= n <= 1000</code></li>\n\t<li><code>1 <= m + n <= 2000</code></li>\n\t<li><code>-10<sup>6</sup> <= nums1[i], nums2[i] <= 10<sup>6</sup></code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你能设计一个时间复杂度为 <code>O(log (m+n))</code> 的算法解决此问题吗？</p>\n",
        level: 3,
        slug_title: "median-of-two-sorted-arrays",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1636,
      value: 11,
      time: "2022-05-10T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1636,
        frontend_question_id: "48",
        question_id: 48,
        title: "旋转图像",
        content:
          '<p>给定一个 <em>n </em>× <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>\n\n<p>你必须在<strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank"> 原地</a></strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要 </strong>使用另一个矩阵来旋转图像。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" style="width: 642px; height: 242px;" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[[7,4,1],[8,5,2],[9,6,3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" style="width: 800px; height: 321px;" />\n<pre>\n<strong>输入：</strong>matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n<strong>输出：</strong>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1]]\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,2],[3,4]]\n<strong>输出：</strong>[[3,1],[4,2]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>matrix.length == n</code></li>\n\t<li><code>matrix[i].length == n</code></li>\n\t<li><code>1 <= n <= 20</code></li>\n\t<li><code>-1000 <= matrix[i][j] <= 1000</code></li>\n</ul>\n',
        level: 2,
        slug_title: "rotate-image",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1581,
      value: 11,
      time: "2022-04-07T09:47:05.347000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1581,
        frontend_question_id: "103",
        question_id: 103,
        title: "二叉树的锯齿形层次遍历",
        content:
          "<p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>\n\n<p>例如：<br />\n给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>\n\n<pre>\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n\n<p>返回锯齿形层序遍历如下：</p>\n\n<pre>\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n</pre>\n",
        level: 2,
        slug_title: "binary-tree-zigzag-level-order-traversal",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1142,
      value: 10,
      time: "2022-08-24T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1142,
        frontend_question_id: "560",
        question_id: 560,
        title: "和为K的子数组",
        content:
          "<p>给你一个整数数组 <code>nums</code> 和一个整数&nbsp;<code>k</code> ，请你统计并返回该数组中和为&nbsp;<code>k</code><strong>&nbsp;</strong>的连续子数组的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1], k = 2\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], k = 3\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>-10<sup>7</sup> &lt;= k &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        level: 2,
        slug_title: "subarray-sum-equals-k",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1659,
      value: 10,
      time: "2022-08-22T11:28:49.355000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1659,
        frontend_question_id: "25",
        question_id: 25,
        title: "K 个一组翻转链表",
        content:
          '<p>给你一个链表，每 <em>k </em>个节点一组进行翻转，请你返回翻转后的链表。</p>\n\n<p><em>k </em>是一个正整数，它的值小于或等于链表的长度。</p>\n\n<p>如果节点总数不是 <em>k </em>的整数倍，那么请将最后剩余的节点保持原有顺序。</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li>\n\t<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" style="width: 542px; height: 222px;" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 2\n<strong>输出：</strong>[2,1,4,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" style="width: 542px; height: 222px;" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 3\n<strong>输出：</strong>[3,2,1,4,5]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 1\n<strong>输出：</strong>[1,2,3,4,5]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1], k = 1\n<strong>输出：</strong>[1]\n</pre>\n\n<ul>\n</ul>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>列表中节点的数量在范围 <code>sz</code> 内</li>\n\t<li><code>1 <= sz <= 5000</code></li>\n\t<li><code>0 <= Node.val <= 1000</code></li>\n\t<li><code>1 <= k <= sz</code></li>\n</ul>\n',
        level: 3,
        slug_title: "reverse-nodes-in-k-group",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1676,
      value: 10,
      time: "2022-05-10T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1676,
        frontend_question_id: "8",
        question_id: 8,
        title: "字符串转换整数 (atoi)",
        content:
          '<p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p>\n\n<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>\n\n<ul>\n\t<li>读入字符串并丢弃无用的前导空格</li>\n\t<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>\n\t<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>\n\t<li>将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li>\n\t<li>如果整数数超过 32 位有符号整数范围 <code>[−2<sup>31</sup>,  2<sup>31 </sup>− 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−2<sup>31</sup></code> 的整数应该被固定为 <code>−2<sup>31</sup></code> ，大于 <code>2<sup>31 </sup>− 1</code> 的整数应该被固定为 <code>2<sup>31 </sup>− 1</code> 。</li>\n\t<li>返回整数作为最终结果。</li>\n</ul>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>本题中的空白字符只包括空格字符 <code>\' \'</code> 。</li>\n\t<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "42"\n<strong>输出：</strong>42\n<strong>解释：</strong>加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n第 1 步："42"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步："42"（当前没有读入字符，因为这里不存在 \'-\' 或者 \'+\'）\n         ^\n第 3 步："<strong>42</strong>"（读入 "42"）\n           ^\n解析得到整数 42 。\n由于 "42" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 42 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "   -42"\n<strong>输出：</strong>-42\n<strong>解释：</strong>\n第 1 步："<strong>   </strong>-42"（读入前导空格，但忽视掉）\n            ^\n第 2 步："   <strong>-</strong>42"（读入 \'-\' 字符，所以结果应该是负数）\n             ^\n第 3 步："   -<strong>42</strong>"（读入 "42"）\n               ^\n解析得到整数 -42 。\n由于 "-42" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 -42 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "4193 with words"\n<strong>输出：</strong>4193\n<strong>解释：</strong>\n第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 \'-\' 或者 \'+\'）\n         ^\n第 3 步："<strong>4193</strong> with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）\n             ^\n解析得到整数 4193 。\n由于 "4193" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 4193 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "words and 987"\n<strong>输出：</strong>0\n<strong>解释：</strong>\n第 1 步："words and 987"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步："words and 987"（当前没有读入字符，因为这里不存在 \'-\' 或者 \'+\'）\n         ^\n第 3 步："words and 987"（由于当前字符 \'w\' 不是一个数字，所以读入停止）\n         ^\n解析得到整数 0 ，因为没有读入任何数字。\n由于 0 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 0 。</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "-91283472332"\n<strong>输出：</strong>-2147483648\n<strong>解释：</strong>\n第 1 步："-91283472332"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步："<strong>-</strong>91283472332"（读入 \'-\' 字符，所以结果应该是负数）\n          ^\n第 3 步："-<strong>91283472332</strong>"（读入 "91283472332"）\n                     ^\n解析得到整数 -91283472332 。\n由于 -91283472332 小于范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 的下界，最终结果被截断为 -2<sup>31</sup> = -2147483648 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= s.length <= 200</code></li>\n\t<li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>\' \'</code>、<code>\'+\'</code>、<code>\'-\'</code> 和 <code>\'.\'</code> 组成</li>\n</ul>\n',
        level: 2,
        slug_title: "string-to-integer-atoi",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1628,
      value: 10,
      time: "2022-05-05T17:29:16.289000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1628,
        frontend_question_id: "56",
        question_id: 56,
        title: "合并区间",
        content:
          "<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,3],[2,6],[8,10],[15,18]]\n<strong>输出：</strong>[[1,6],[8,10],[15,18]]\n<strong>解释：</strong>区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,4],[4,5]]\n<strong>输出：</strong>[[1,5]]\n<strong>解释：</strong>区间 [1,4] 和 [4,5] 可被视为重叠区间。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= intervals.length <= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 <= start<sub>i</sub> <= end<sub>i</sub> <= 10<sup>4</sup></code></li>\n</ul>\n",
        level: 2,
        slug_title: "merge-intervals",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1669,
      value: 10,
      time: "2022-04-24T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1669,
        frontend_question_id: "15",
        question_id: 15,
        title: "三数之和",
        content:
          "<p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c = </em>0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p>\n\n<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,0,1,2,-1,-4]\n<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= nums.length <= 3000</code></li>\n\t<li><code>-10<sup>5</sup> <= nums[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        level: 2,
        slug_title: "3sum",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1533,
      value: 10,
      time: "2022-03-23T02:44:10.370000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1533,
        frontend_question_id: "151",
        question_id: 151,
        title: "翻转字符串里的单词",
        content:
          '<p>给你一个字符串 <code>s</code> ，逐个翻转字符串中的所有 <strong>单词</strong> 。</p>\n\n<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>\n\n<p>请你返回一个翻转 <code>s</code> 中单词顺序并用单个空格相连的字符串。</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>输入字符串 <code>s</code> 可以在前面、后面或者单词间包含多余的空格。</li>\n\t<li>翻转后单词间应当仅用一个空格分隔。</li>\n\t<li>翻转后的字符串中不应包含额外的空格。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "<code>the sky is blue</code>"\n<strong>输出：</strong>"<code>blue is sky the</code>"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "  hello world  "\n<strong>输出：</strong>"world hello"\n<strong>解释：</strong>输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "a good   example"\n<strong>输出：</strong>"example good a"\n<strong>解释：</strong>如果两个单词间有多余的空格，将翻转后单词间的空格减少到只含一个。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "  Bob    Loves  Alice   "\n<strong>输出：</strong>"Alice Loves Bob"\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "Alice does not even like bob"\n<strong>输出：</strong>"bob like even not does Alice"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 包含英文大小写字母、数字和空格 <code>\' \'</code></li>\n\t<li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li>\n</ul>\n\n<ul>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>请尝试使用 <code><em>O</em>(1)</code> 额外空间复杂度的原地解法。</li>\n</ul>\n',
        level: 2,
        slug_title: "reverse-words-in-a-string",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1679,
      value: 9,
      time: "2022-06-23T02:03:18.074000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1679,
        frontend_question_id: "5",
        question_id: 5,
        title: "最长回文子串",
        content:
          '<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "babad"\n<strong>输出：</strong>"bab"\n<strong>解释：</strong>"aba" 同样是符合题意的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "cbbd"\n<strong>输出：</strong>"bb"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "a"\n<strong>输出：</strong>"a"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "ac"\n<strong>输出：</strong>"a"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li>\n</ul>\n',
        level: 2,
        slug_title: "longest-palindromic-substring",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1484,
      value: 9,
      time: "2022-04-15T07:40:10.197000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1484,
        frontend_question_id: "200",
        question_id: 200,
        title: "岛屿数量",
        content:
          '<p>给你一个由 <code>\'1\'</code>（陆地）和 <code>\'0\'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>\n\n<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>\n\n<p>此外，你可以假设该网格的四条边均被水包围。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [\n  ["1","1","1","1","0"],\n  ["1","1","0","1","0"],\n  ["1","1","0","0","0"],\n  ["0","0","0","0","0"]\n]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [\n  ["1","1","0","0","0"],\n  ["1","1","0","0","0"],\n  ["0","0","1","0","0"],\n  ["0","0","0","1","1"]\n]\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= m, n <= 300</code></li>\n\t<li><code>grid[i][j]</code> 的值为 <code>\'0\'</code> 或 <code>\'1\'</code></li>\n</ul>\n',
        level: 2,
        slug_title: "number-of-islands",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1563,
      value: 8,
      time: "2022-05-28T04:50:57.366000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1563,
        frontend_question_id: "121",
        question_id: 121,
        title: "买卖股票的最佳时机",
        content:
          "<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>\n\n<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>\n\n<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[7,1,5,3,6,4]\n<strong>输出：</strong>5\n<strong>解释：</strong>在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [7,6,4,3,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>在这种情况下, 没有交易完成, 所以最大利润为 0。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= prices.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= prices[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        level: 1,
        slug_title: "best-time-to-buy-and-sell-stock",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1683,
      value: 8,
      time: "2022-04-20T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1683,
        frontend_question_id: "1",
        question_id: 1,
        title: "两数之和",
        content:
          "<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值 </strong><em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>\n\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>\n\n<p>你可以按任意顺序返回答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,7,11,15], target = 9\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,4], target = 6\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3], target = 6\n<strong>输出：</strong>[0,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= target <= 10<sup>9</sup></code></li>\n\t<li><strong>只会存在一个有效答案</strong></li>\n</ul>\n\n<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n<sup>2</sup>)</code> 的算法吗？</p>\n",
        level: 1,
        slug_title: "two-sum",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1586,
      value: 8,
      time: "2022-03-20T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1586,
        frontend_question_id: "98",
        question_id: 98,
        title: "验证二叉搜索树",
        content:
          '<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>\n\n<p><strong>有效</strong> 二叉搜索树定义如下：</p>\n\n<ul>\n\t<li>节点的左子树只包含<strong> 小于 </strong>当前节点的数。</li>\n\t<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>\n\t<li>所有左子树和右子树自身必须也是二叉搜索树。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" style="width: 302px; height: 182px;" />\n<pre>\n<strong>输入：</strong>root = [2,1,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" style="width: 422px; height: 292px;" />\n<pre>\n<strong>输入：</strong>root = [5,1,4,null,null,3,6]\n<strong>输出：</strong>false\n<strong>解释：</strong>根节点的值是 5 ，但是右子节点的值是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目范围在<code>[1, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n',
        level: 2,
        slug_title: "validate-binary-search-tree",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1652,
      value: 8,
      time: "2022-03-11T06:59:07.144000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1652,
        frontend_question_id: "32",
        question_id: 32,
        title: "最长有效括号",
        content:
          '<p>给你一个只包含 <code>\'(\'</code> 和 <code>\')\'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>\n\n<p> </p>\n\n<div class="original__bRMd">\n<div>\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "(()"\n<strong>输出：</strong>2\n<strong>解释：</strong>最长有效括号子串是 "()"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = ")()())"\n<strong>输出：</strong>4\n<strong>解释：</strong>最长有效括号子串是 "()()"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = ""\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= s.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>\'(\'</code> 或 <code>\')\'</code></li>\n</ul>\n</div>\n</div>\n',
        level: 3,
        slug_title: "longest-valid-parentheses",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1590,
      value: 8,
      time: "2022-03-08T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1590,
        frontend_question_id: "94",
        question_id: 94,
        title: "二叉树的中序遍历",
        content:
          '<p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" style="width: 202px; height: 324px;" />\n<pre>\n<strong>输入：</strong>root = [1,null,2,3]\n<strong>输出：</strong>[1,3,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" style="width: 202px; height: 202px;" />\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>[2,1]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" style="width: 202px; height: 202px;" />\n<pre>\n<strong>输入：</strong>root = [1,null,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n\t<li><code>-100 <= Node.val <= 100</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>\n',
        level: 1,
        slug_title: "binary-tree-inorder-traversal",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1638,
      value: 7,
      time: "2022-12-19T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1638,
        frontend_question_id: "46",
        question_id: 46,
        title: "全排列",
        content:
          "<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>[[0,1],[1,0]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 6</code></li>\n\t<li><code>-10 <= nums[i] <= 10</code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n",
        level: 2,
        slug_title: "permutations",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1663,
      value: 7,
      time: "2022-09-27T09:40:53.899000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1663,
        frontend_question_id: "21",
        question_id: 21,
        title: "合并两个有序链表",
        content:
          '<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" style="width: 662px; height: 302px;" />\n<pre>\n<strong>输入：</strong>l1 = [1,2,4], l2 = [1,3,4]\n<strong>输出：</strong>[1,1,2,3,4,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [], l2 = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [], l2 = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>\n\t<li><code>-100 <= Node.val <= 100</code></li>\n\t<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>\n</ul>\n',
        level: 1,
        slug_title: "merge-two-sorted-lists",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1612,
      value: 7,
      time: "2022-09-19T14:58:53.230000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1612,
        frontend_question_id: "72",
        question_id: 72,
        title: "编辑距离",
        content:
          "<p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code><em> </em>所使用的最少操作数 。</p>\n\n<p>你可以对一个单词进行如下三种操作：</p>\n\n<ul>\n\t<li>插入一个字符</li>\n\t<li>删除一个字符</li>\n\t<li>替换一个字符</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"horse\", word2 = \"ros\"\n<strong>输出：</strong>3\n<strong>解释：</strong>\nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"intention\", word2 = \"execution\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\nintention -> inention (删除 't')\ninention -> enention (将 'i' 替换为 'e')\nenention -> exention (将 'n' 替换为 'x')\nexention -> exection (将 'n' 替换为 'c')\nexection -> execution (插入 'u')\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= word1.length, word2.length <= 500</code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>\n</ul>\n",
        level: 3,
        slug_title: "edit-distance",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1591,
      value: 7,
      time: "2022-09-19T05:48:17.642000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1591,
        frontend_question_id: "93",
        question_id: 93,
        title: "复原IP地址",
        content:
          '<p>给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 <code>s</code> 获得的 <strong>有效 IP 地址 </strong>。你可以按任何顺序返回答案。</p>\n\n<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>\'.\'</code> 分隔。</p>\n\n<p>例如："0.1.2.201" 和 "192.168.1.1" 是 <strong>有效</strong> IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 <strong>无效</strong> IP 地址。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "25525511135"\n<strong>输出：</strong>["255.255.11.135","255.255.111.35"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "0000"\n<strong>输出：</strong>["0.0.0.0"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "1111"\n<strong>输出：</strong>["1.1.1.1"]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "010010"\n<strong>输出：</strong>["0.10.0.10","0.100.1.0"]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "101023"\n<strong>输出：</strong>["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= s.length <= 3000</code></li>\n\t<li><code>s</code> 仅由数字组成</li>\n</ul>\n',
        level: 2,
        slug_title: "restore-ip-addresses",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1643,
      value: 7,
      time: "2022-04-25T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1643,
        frontend_question_id: "41",
        question_id: 41,
        title: "缺失的第一个正数",
        content:
          "<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>\n请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,0]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,-1,1]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,8,9,11,12]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 5 * 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        level: 3,
        slug_title: "first-missing-positive",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1543,
      value: 7,
      time: "2022-04-24T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1543,
        frontend_question_id: "141",
        question_id: 141,
        title: "环形链表",
        content:
          '<p>给定一个链表，判断链表中是否有环。</p>\n\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>\n\n<p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" style="height: 97px; width: 300px;"></p>\n\n<pre><strong>输入：</strong>head = [3,2,0,-4], pos = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" style="height: 74px; width: 141px;"></p>\n\n<pre><strong>输入：</strong>head = [1,2], pos = 0\n<strong>输出：</strong>true\n<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" style="height: 45px; width: 45px;"></p>\n\n<pre><strong>输入：</strong>head = [1], pos = -1\n<strong>输出：</strong>false\n<strong>解释：</strong>链表中没有环。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围是 <code>[0, 10<sup>4</sup>]</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>\n</ul>\n',
        level: 1,
        slug_title: "linked-list-cycle",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1664,
      value: 7,
      time: "2022-04-14T08:21:09.067000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1664,
        frontend_question_id: "20",
        question_id: 20,
        title: "有效的括号",
        content:
          "<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>\n\n<p>有效字符串需满足：</p>\n\n<ol>\n\t<li>左括号必须用相同类型的右括号闭合。</li>\n\t<li>左括号必须以正确的顺序闭合。</li>\n</ol>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"()\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"()[]{}\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(]\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"([)]\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"{[]}\"\n<strong>输出：</strong>true</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 仅由括号 <code>'()[]{}'</code> 组成</li>\n</ul>\n",
        level: 1,
        slug_title: "valid-parentheses",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1474,
      value: 7,
      time: "2022-04-12T07:05:08.168000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1474,
        frontend_question_id: "210",
        question_id: 210,
        title: "课程表 II",
        content:
          '<p>现在你总共有 <code>numCourses</code> 门课需要选，记为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>numCourses - 1</code>。给你一个数组&nbsp;<code>prerequisites</code> ，其中 <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> ，表示在选修课程 <code>a<sub>i</sub></code> 前 <strong>必须</strong> 先选修&nbsp;<code>b<sub>i</sub></code> 。</p>\n\n<ul>\n\t<li>例如，想要学习课程 <code>0</code> ，你需要先完成课程&nbsp;<code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。</li>\n</ul>\n\n<p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 2, prerequisites = [[1,0]]\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 <code>[0,1] 。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n<strong>输出：</strong>[0,2,1,3]\n<strong>解释：</strong>总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。\n因此，一个正确的课程顺序是&nbsp;<code>[0,1,2,3]</code> 。另一个正确的排序是&nbsp;<code>[0,2,1,3]</code> 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 1, prerequisites = []\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n<strong>提示：</strong>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>所有<code>[a<sub>i</sub>, b<sub>i</sub>]</code> 匹配 <strong>互不相同</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>拓展：</strong></p>\n\n<ul>\n\t<li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li>\n\t<li><a href="https://www.coursera.org/specializations/algorithms" target="_blank">通过 DFS 进行拓扑排序</a> - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li>\n\t<li>\n\t<p>拓扑排序也可以通过&nbsp;<a href="https://baike.baidu.com/item/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/5224802?fr=aladdin&amp;fromid=2148012&amp;fromtitle=%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank">BFS</a>&nbsp;完成。</p>\n\t</li>\n</ul>\n',
        level: 2,
        slug_title: "course-schedule-ii",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1444,
      value: 7,
      time: "2022-04-08T22:37:19.316000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1444,
        frontend_question_id: "240",
        question_id: 240,
        title: "搜索二维矩阵 II",
        content:
          '<p>编写一个高效的算法来搜索&nbsp;<code><em>m</em>&nbsp;x&nbsp;<em>n</em></code>&nbsp;矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>\n\n<ul>\n\t<li>每行的元素从左到右升序排列。</li>\n\t<li>每列的元素从上到下升序排列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" />\n<pre>\n<b>输入：</b>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n<b>输出：</b>true\n</pre>\n\n<p><b>示例 2：</b></p>\n<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg" />\n<pre>\n<b>输入：</b>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n<b>输出：</b>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 300</code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>\n\t<li>每行的所有元素从左到右升序排列</li>\n\t<li>每列的所有元素从上到下升序排列</li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n',
        level: 2,
        slug_title: "search-a-2d-matrix-ii",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1645,
      value: 7,
      time: "2022-03-31T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1645,
        frontend_question_id: "39",
        question_id: 39,
        title: "组合总和",
        content:
          "<p>给定一个<strong>无重复元素</strong>的正整数数组 <code>candidates</code> 和一个正整数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为目标数 <code>target</code> 的唯一组合。</p>\n\n<p><code>candidates</code> 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 </p>\n\n<p>对于给定的输入，保证和为 <code>target</code> 的唯一组合数少于 <code>150</code> 个。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = <code>[2,3,6,7], </code>target = <code>7</code>\n<strong>输出: </strong>[[7],[2,2,3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = [2,3,5]<code>, </code>target = 8\n<strong>输出: </strong>[[2,2,2,2],[2,3,3],[3,5]]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = <code>[2], </code>target = 1\n<strong>输出: </strong>[]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = <code>[1], </code>target = <code>1</code>\n<strong>输出: </strong>[[1]]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = <code>[1], </code>target = <code>2</code>\n<strong>输出: </strong>[[1,1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= candidates.length <= 30</code></li>\n\t<li><code>1 <= candidates[i] <= 200</code></li>\n\t<li><code>candidate</code> 中的每个元素都是独一无二的。</li>\n\t<li><code>1 <= target <= 500</code></li>\n</ul>\n",
        level: 2,
        slug_title: "combination-sum",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1516,
      value: 7,
      time: "2022-03-13T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1516,
        frontend_question_id: "168",
        question_id: 168,
        title: "Excel表列名称",
        content:
          '<p>给你一个整数 <code>columnNumber</code> ，返回它在 Excel 表中相对应的列名称。</p>\n\n<p>例如：</p>\n\n<pre>\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n</pre>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>columnNumber = 1\n<strong>输出：</strong>"A"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>columnNumber = 28\n<strong>输出：</strong>"AB"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>columnNumber = 701\n<strong>输出：</strong>"ZY"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>columnNumber = 2147483647\n<strong>输出：</strong>"FXSHRXW"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= columnNumber <= 2<sup>31</sup> - 1</code></li>\n</ul>\n',
        level: 1,
        slug_title: "excel-sheet-column-title",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1637,
      value: 7,
      time: "2022-02-21T02:50:33.567000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1637,
        frontend_question_id: "47",
        question_id: 47,
        title: "全排列 II",
        content:
          "<p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2]\n<strong>输出：</strong>\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 8</code></li>\n\t<li><code>-10 <= nums[i] <= 10</code></li>\n</ul>\n",
        level: 2,
        slug_title: "permutations-ii",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1156,
      value: 7,
      time: "2022-01-26T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1156,
        frontend_question_id: "543",
        question_id: 543,
        title: "二叉树的直径",
        content:
          "<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 :</strong><br>\n给定二叉树</p>\n\n<pre>          1\n         / \\\n        2   3\n       / \\     \n      4   5    \n</pre>\n\n<p>返回&nbsp;<strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者&nbsp;[5,2,1,3]。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p>\n",
        level: 1,
        slug_title: "diameter-of-binary-tree",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1593,
      value: 7,
      time: "2021-12-08T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1593,
        frontend_question_id: "91",
        question_id: 91,
        title: "解码方法",
        content:
          '<p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p>\n\n<pre>\n\'A\' -> 1\n\'B\' -> 2\n...\n\'Z\' -> 26\n</pre>\n\n<p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>"11106"</code> 可以映射为：</p>\n\n<ul>\n\t<li><code>"AAJF"</code> ，将消息分组为 <code>(1 1 10 6)</code></li>\n\t<li><code>"KJF"</code> ，将消息分组为 <code>(11 10 6)</code></li>\n</ul>\n\n<p>注意，消息不能分组为  <code>(1 11 06)</code> ，因为 <code>"06"</code> 不能映射为 <code>"F"</code> ，这是由于 <code>"6"</code> 和 <code>"06"</code> 在映射中并不等价。</p>\n\n<p>给你一个只含数字的 <strong>非空 </strong>字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p>\n\n<p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "12"\n<strong>输出：</strong>2\n<strong>解释：</strong>它可以解码为 "AB"（1 2）或者 "L"（12）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "226"\n<strong>输出：</strong>3\n<strong>解释：</strong>它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "0"\n<strong>输出：</strong>0\n<strong>解释：</strong>没有字符映射到以 0 开头的数字。\n含有 0 的有效映射是 \'J\' -> "10" 和 \'T\'-> "20" 。\n由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "06"\n<strong>输出：</strong>0\n<strong>解释：</strong>"06" 不能映射到 "F" ，因为字符串含有前导 0（<code>"6"</code> 和 <code>"06"</code> 在映射中并不等价）。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code> 只包含数字，并且可能包含前导零。</li>\n</ul>\n',
        level: 2,
        slug_title: "decode-ways",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1574,
      value: 6,
      time: "2022-12-19T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1574,
        frontend_question_id: "110",
        question_id: 110,
        title: "平衡二叉树",
        content:
          '<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>\n\n<p>本题中，一棵高度平衡二叉树定义为：</p>\n\n<blockquote>\n<p>一个二叉树<em>每个节点 </em>的左右两个子树的高度差的绝对值不超过 1 。</p>\n</blockquote>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" style="width: 342px; height: 221px;" />\n<pre>\n<strong>输入：</strong>root = [3,9,20,null,null,15,7]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" style="width: 452px; height: 301px;" />\n<pre>\n<strong>输入：</strong>root = [1,2,2,3,3,null,null,4,4]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>\n\t<li><code>-10<sup>4</sup> <= Node.val <= 10<sup>4</sup></code></li>\n</ul>\n',
        level: 1,
        slug_title: "balanced-binary-tree",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1650,
      value: 6,
      time: "2022-09-06T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1650,
        frontend_question_id: "34",
        question_id: 34,
        title: "在排序数组中查找元素的第一个和最后一个位置",
        content:
          "<p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>\n\n<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题吗？</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>5,7,7,8,8,10]</code>, target = 8\n<strong>输出：</strong>[3,4]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>5,7,7,8,8,10]</code>, target = 6\n<strong>输出：</strong>[-1,-1]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [], target = 0\n<strong>输出：</strong>[-1,-1]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\n\t<li><code>nums</code> 是一个非递减数组</li>\n\t<li><code>-10<sup>9</sup> <= target <= 10<sup>9</sup></code></li>\n</ul>\n",
        level: 2,
        slug_title: "find-first-and-last-position-of-element-in-sorted-array",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1532,
      value: 6,
      time: "2022-05-23T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1532,
        frontend_question_id: "152",
        question_id: 152,
        title: "乘积最大子数组",
        content:
          "<p>给你一个整数数组 <code>nums</code>&nbsp;，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [2,3,-2,4]\n<strong>输出:</strong> <code>6</code>\n<strong>解释:</strong>&nbsp;子数组 [2,3] 有最大乘积 6。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> [-2,0,-1]\n<strong>输出:</strong> 0\n<strong>解释:</strong>&nbsp;结果不能为 2, 因为 [-2,-1] 不是子数组。</pre>\n",
        level: 2,
        slug_title: "maximum-product-subarray",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1445,
      value: 6,
      time: "2022-05-19T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1445,
        frontend_question_id: "239",
        question_id: 239,
        title: "滑动窗口最大值",
        content:
          "<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code><em> </em>的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>\n\n<p>返回滑动窗口中的最大值。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3,-1,-3,5,3,6,7], k = 3\n<b>输出：</b>[3,3,5,5,6,7]\n<b>解释：</b>\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1], k = 1\n<b>输出：</b>[1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,-1], k = 1\n<b>输出：</b>[1,-1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [9,11], k = 2\n<b>输出：</b>[11]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,-2], k = 2\n<b>输出：</b>[4]</pre>\n\n<p> </p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= k <= nums.length</code></li>\n</ul>\n",
        level: 3,
        slug_title: "sliding-window-maximum",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1914,
      value: 6,
      time: "2022-04-28T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1914,
        frontend_question_id: "补充题12",
        question_id: 99990012,
        title: "二叉树的下一个节点",
        content: null,
        level: 2,
        slug_title: "https://mp.weixin.qq.com/s/yewlHvHSilMsrUMFIO8WAA",
        expand: true,
      },
      comment_count: 0,
    },
    {
      id: 1542,
      value: 6,
      time: "2022-04-24T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1542,
        frontend_question_id: "142",
        question_id: 142,
        title: "环形链表 II",
        content:
          '<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>\n\n<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p>\n\n<p><strong>说明：</strong>不允许修改给定的链表。</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你是否可以使用 <code>O(1)</code> 空间解决此题？</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" style="height: 97px; width: 300px;" /></p>\n\n<pre>\n<strong>输入：</strong>head = [3,2,0,-4], pos = 1\n<strong>输出：</strong>返回索引为 1 的链表节点\n<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" style="height: 74px; width: 141px;" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], pos = 0\n<strong>输出：</strong>返回索引为 0 的链表节点\n<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" style="height: 45px; width: 45px;" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1], pos = -1\n<strong>输出：</strong>返回 null\n<strong>解释：</strong>链表中没有环。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-10<sup>5</sup> <= Node.val <= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>\n</ul>\n',
        level: 2,
        slug_title: "linked-list-cycle-ii",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1269,
      value: 6,
      time: "2022-04-20T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1269,
        frontend_question_id: "415",
        question_id: 415,
        title: "字符串相加",
        content:
          '<p>给定两个字符串形式的非负整数&nbsp;<code>num1</code> 和<code>num2</code>&nbsp;，计算它们的和并同样以字符串形式返回。</p>\n\n<p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>），&nbsp;也不能直接将输入的字符串转换为整数形式。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = "11", num2 = "123"\n<strong>输出：</strong>"134"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = "456", num2 = "77"\n<strong>输出：</strong>"533"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = "0", num2 = "0"\n<strong>输出：</strong>"0"\n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1.length, num2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>num1</code> 和<code>num2</code> 都只包含数字&nbsp;<code>0-9</code></li>\n\t<li><code>num1</code> 和<code>num2</code> 都不包含任何前导零</li>\n</ul>\n',
        level: 1,
        slug_title: "add-strings",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 964,
      value: 6,
      time: "2022-03-07T11:42:28.306000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 964,
        frontend_question_id: "752",
        question_id: 753,
        title: "打开转盘锁",
        content:
          '<p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： <code>\'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\'</code> 。每个拨轮可以自由旋转：例如把 <code>\'9\'</code> 变为 <code>\'0\'</code>，<code>\'0\'</code> 变为 <code>\'9\'</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p>\n\n<p>锁的初始数字为 <code>\'0000\'</code> ，一个代表四个拨轮的数字的字符串。</p>\n\n<p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>\n\n<p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>deadends = ["0201","0101","0102","1212","2002"], target = "0202"\n<strong>输出：</strong>6\n<strong>解释：</strong>\n可能的移动序列为 "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202"。\n注意 "0000" -> "0001" -> "0002" -> "0102" -> "0202" 这样的序列是不能解锁的，\n因为当拨动到 "0102" 时这个锁就会被锁定。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> deadends = ["8888"], target = "0009"\n<strong>输出：</strong>1\n<strong>解释：</strong>\n把最后一位反向旋转一次即可 "0000" -> "0009"。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"\n<strong>输出：</strong>-1\n<strong>解释：\n</strong>无法旋转到目标数字且不被锁定。\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre>\n<strong>输入:</strong> deadends = ["0000"], target = "8888"\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= deadends.length <= 500</code></li>\n\t<li><code><font face="monospace">deadends[i].length == 4</font></code></li>\n\t<li><code><font face="monospace">target.length == 4</font></code></li>\n\t<li><code>target</code> <strong>不在</strong> <code>deadends</code> 之中</li>\n\t<li><code>target</code> 和 <code>deadends[i]</code> 仅由若干位数字组成</li>\n</ul>\n',
        level: 2,
        slug_title: "open-the-lock",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1546,
      value: 6,
      time: "2022-01-25T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1546,
        frontend_question_id: "138",
        question_id: 138,
        title: "复制带随机指针的链表",
        content:
          '<p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>\n\n<p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin" target="_blank">深拷贝</a></strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点 </strong>。</p>\n\n<p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --> Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --> y</code> 。</p>\n\n<p>返回复制链表的头节点。</p>\n\n<p>用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>\n\n<ul>\n\t<li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li>\n\t<li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。</li>\n</ul>\n\n<p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" style="height: 138px; width: 680px;" /></p>\n\n<pre>\n<strong>输入：</strong>head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n<strong>输出：</strong>[[7,null],[13,0],[11,4],[10,2],[1,0]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" style="height: 111px; width: 680px;" /></p>\n\n<pre>\n<strong>输入：</strong>head = [[1,1],[2,1]]\n<strong>输出：</strong>[[1,1],[2,1]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" style="height: 119px; width: 680px;" /></strong></p>\n\n<pre>\n<strong>输入：</strong>head = [[3,null],[3,0],[3,null]]\n<strong>输出：</strong>[[3,null],[3,0],[3,null]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n<strong>解释：</strong>给定的链表为空（空指针），因此返回 null。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= n <= 1000</code></li>\n\t<li><code>-10000 <= Node.val <= 10000</code></li>\n\t<li><code>Node.random</code> 为空（null）或指向链表中的节点。</li>\n</ul>\n',
        level: 2,
        slug_title: "copy-list-with-random-pointer",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1222,
      value: 6,
      time: "2022-01-24T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1222,
        frontend_question_id: "468",
        question_id: 468,
        title: "验证IP地址",
        content:
          "<p>编写一个函数来验证输入的字符串是否是有效的 IPv4 或&nbsp;IPv6 地址。</p>\n\n<ul>\n\t<li>如果是有效的 IPv4 地址，返回 <code>&quot;IPv4&quot;</code> ；</li>\n\t<li>如果是有效的 IPv6 地址，返回 <code>&quot;IPv6&quot;</code> ；</li>\n\t<li>如果不是上述类型的 IP 地址，返回 <code>&quot;Neither&quot;</code> 。</li>\n</ul>\n\n<p><strong>IPv4</strong>&nbsp;地址由十进制数和点来表示，每个地址包含 4 个十进制数，其范围为&nbsp;0 -&nbsp;255，&nbsp;用(&quot;.&quot;)分割。比如，<code>172.16.254.1</code>；</p>\n\n<p>同时，IPv4 地址内的数不会以 0 开头。比如，地址&nbsp;<code>172.16.254.01</code> 是不合法的。</p>\n\n<p><strong>IPv6</strong>&nbsp;地址由 8 组 16 进制的数字来表示，每组表示&nbsp;16 比特。这些组数字通过 (&quot;:&quot;)分割。比如,&nbsp;&nbsp;<code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code> 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以，&nbsp;<code>2001:db8:85a3:0:0:8A2E:0370:7334</code> 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。</p>\n\n<p>然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。&nbsp;比如，&nbsp;<code>2001:0db8:85a3::8A2E:0370:7334</code> 是无效的 IPv6 地址。</p>\n\n<p>同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如，&nbsp;<code>02001:0db8:85a3:0000:0000:8a2e:0370:7334</code> 是无效的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>IP = &quot;172.16.254.1&quot;\n<strong>输出：</strong>&quot;IPv4&quot;\n<strong>解释：</strong>有效的 IPv4 地址，返回 &quot;IPv4&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>IP = &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;\n<strong>输出：</strong>&quot;IPv6&quot;\n<strong>解释：</strong>有效的 IPv6 地址，返回 &quot;IPv6&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>IP = &quot;256.256.256.256&quot;\n<strong>输出：</strong>&quot;Neither&quot;\n<strong>解释：</strong>既不是 IPv4 地址，又不是 IPv6 地址\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>IP = &quot;2001:0db8:85a3:0:0:8A2E:0370:7334:&quot;\n<strong>输出：</strong>&quot;Neither&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>IP = &quot;1e1.4.5.6&quot;\n<strong>输出：</strong>&quot;Neither&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>IP</code> 仅由英文字母，数字，字符 <code>&#39;.&#39;</code> 和 <code>&#39;:&#39;</code> 组成。</li>\n</ul>\n",
        level: 2,
        slug_title: "validate-ip-address",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1620,
      value: 6,
      time: "2022-01-20T05:48:50.082000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1620,
        frontend_question_id: "64",
        question_id: 64,
        title: "最小路径和",
        content:
          '<p>给定一个包含非负整数的 <code><em>m</em> x <em>n</em></code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>\n\n<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" style="width: 242px; height: 242px;" />\n<pre>\n<strong>输入：</strong>grid = [[1,3,1],[1,5,1],[4,2,1]]\n<strong>输出：</strong>7\n<strong>解释：</strong>因为路径 1→3→1→1→1 的总和最小。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,2,3],[4,5,6]]\n<strong>输出：</strong>12\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= m, n <= 200</code></li>\n\t<li><code>0 <= grid[i][j] <= 100</code></li>\n</ul>\n',
        level: 2,
        slug_title: "minimum-path-sum",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1460,
      value: 6,
      time: "2021-09-09T06:14:52.350000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1460,
        frontend_question_id: "224",
        question_id: 224,
        title: "基本计算器",
        content:
          "<p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1 + 1\"\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \" 2-1 + 2 \"\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(1+(4+5+2)-3)+(6+8)\"\n<strong>输出：</strong>23\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由数字、<code>'+'</code>、<code>'-'</code>、<code>'('</code>、<code>')'</code>、和 <code>' '</code> 组成</li>\n\t<li><code>s</code> 表示一个有效的表达式</li>\n</ul>\n",
        level: 3,
        slug_title: "basic-calculator",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1411,
      value: 5,
      time: "2022-05-17T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1411,
        frontend_question_id: "273",
        question_id: 273,
        title: "整数转换英文表示",
        content:
          '<p>将非负整数 <code>num</code> 转换为其对应的英文表示。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 123\n<strong>输出：</strong>"One Hundred Twenty Three"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 12345\n<strong>输出：</strong>"Twelve Thousand Three Hundred Forty Five"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 1234567\n<strong>输出：</strong>"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 1234567891\n<strong>输出：</strong>"One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= num <= 2<sup>31</sup> - 1</code></li>\n</ul>\n',
        level: 3,
        slug_title: "integer-to-english-words",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 98,
      value: 5,
      time: "2022-05-09T09:16:50.120000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 98,
        frontend_question_id: "剑指 Offer 51",
        question_id: 100318,
        title: "数组中的逆序对",
        content:
          "<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入</strong>: [7,5,6,4]\n<strong>输出</strong>: 5</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= 数组长度 &lt;= 50000</code></p>\n",
        level: 3,
        slug_title: "shu-zu-zhong-de-ni-xu-dui-lcof",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1531,
      value: 5,
      time: "2022-04-23T06:35:03.077000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1531,
        frontend_question_id: "153",
        question_id: 153,
        title: "寻找旋转排序数组中的最小值",
        content:
          "已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：\n<ul>\n\t<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>\n\t<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>\n</ul>\n\n<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>\n\n<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,5,1,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,5,6,7,0,1,2]\n<strong>输出：</strong>0\n<strong>解释：</strong>原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [11,13,15,17]\n<strong>输出：</strong>11\n<strong>解释：</strong>原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 <= n <= 5000</code></li>\n\t<li><code>-5000 <= nums[i] <= 5000</code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n\t<li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>\n</ul>\n",
        level: 2,
        slug_title: "find-minimum-in-rotated-sorted-array",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1608,
      value: 5,
      time: "2022-04-21T15:48:25.053000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1608,
        frontend_question_id: "76",
        question_id: 76,
        title: "最小覆盖子串",
        content:
          '<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>""</code> 。</p>\n\n<p> </p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>\n\t<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "ADOBECODEBANC", t = "ABC"\n<strong>输出：</strong>"BANC"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "a", t = "a"\n<strong>输出：</strong>"a"\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = "a", t = "aa"\n<strong>输出:</strong> ""\n<strong>解释:</strong> t 中两个字符 \'a\' 均应包含在 s 的子串中，\n因此没有符合条件的子字符串，返回空字符串。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length, t.length <= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>\n</ul>\n\n<p> </p>\n<strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？',
        level: 3,
        slug_title: "minimum-window-substring",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1389,
      value: 5,
      time: "2022-03-19T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1389,
        frontend_question_id: "295",
        question_id: 295,
        title: "数据流的中位数",
        content:
          "<p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>\n\n<p>例如，</p>\n\n<p>[2,3,4]&nbsp;的中位数是 3</p>\n\n<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>\n\n<p>设计一个支持以下两种操作的数据结构：</p>\n\n<ul>\n\t<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>\n\t<li>double findMedian() - 返回目前所有元素的中位数。</li>\n</ul>\n\n<p><strong>示例：</strong></p>\n\n<pre>addNum(1)\naddNum(2)\nfindMedian() -&gt; 1.5\naddNum(3) \nfindMedian() -&gt; 2</pre>\n\n<p><strong>进阶:</strong></p>\n\n<ol>\n\t<li>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？</li>\n\t<li>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</li>\n</ol>\n",
        level: 3,
        slug_title: "find-median-from-data-stream",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1536,
      value: 5,
      time: "2022-03-06T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1536,
        frontend_question_id: "148",
        question_id: 148,
        title: "排序链表",
        content:
          '<p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>\n\n<p><b>进阶：</b></p>\n\n<ul>\n\t<li>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" style="width: 302px; "/>\n<pre>\n<b>输入：</b>head = [4,2,1,3]\n<b>输出：</b>[1,2,3,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" style="width: 402px; " />\n<pre>\n<b>输入：</b>head = [-1,5,3,4,0]\n<b>输出：</b>[-1,0,3,4,5]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>head = []\n<b>输出：</b>[]\n</pre>\n\n<p> </p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[0, 5 * 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-10<sup>5</sup> <= Node.val <= 10<sup>5</sup></code></li>\n</ul>\n',
        level: 2,
        slug_title: "sort-list",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1615,
      value: 5,
      time: "2022-02-27T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1615,
        frontend_question_id: "69",
        question_id: 69,
        title: "x 的平方根",
        content:
          "<p>给你一个非负整数 <code>x</code> ，计算并返回&nbsp;<code>x</code>&nbsp;的 <strong>平方根</strong> 。</p>\n\n<p>由于返回类型是整数，结果只保留 <strong>整数部分 </strong>，小数部分将被 <strong>舍去 。</strong></p>\n\n<p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 4\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 8\n<strong>输出：</strong>2\n<strong>解释：</strong>8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= x &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        level: 1,
        slug_title: "sqrtx",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1511,
      value: 5,
      time: "2022-02-21T14:21:44.178000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1511,
        frontend_question_id: "173",
        question_id: 173,
        title: "二叉搜索树迭代器",
        content:
          '实现一个二叉搜索树迭代器类<code>BSTIterator</code> ，表示一个按中序遍历二叉搜索树（BST）的迭代器：\n<div class="original__bRMd">\n<div>\n<ul>\n\t<li><code>BSTIterator(TreeNode root)</code> 初始化 <code>BSTIterator</code> 类的一个对象。BST 的根节点 <code>root</code> 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</li>\n\t<li><code>boolean hasNext()</code> 如果向指针右侧遍历存在数字，则返回 <code>true</code> ；否则返回 <code>false</code> 。</li>\n\t<li><code>int next()</code>将指针向右移动，然后返回指针处的数字。</li>\n</ul>\n\n<p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 <code>next()</code> 的首次调用将返回 BST 中的最小元素。</p>\n</div>\n</div>\n\n<p>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 的中序遍历中至少存在一个下一个数字。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" style="width: 189px; height: 178px;" />\n<pre>\n<strong>输入</strong>\n["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n<strong>输出</strong>\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n<strong>解释</strong>\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // 返回 3\nbSTIterator.next();    // 返回 7\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 9\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 15\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 20\nbSTIterator.hasNext(); // 返回 False\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>0 <= Node.val <= 10<sup>6</sup></code></li>\n\t<li>最多调用 <code>10<sup>5</sup></code> 次 <code>hasNext</code> 和 <code>next</code> 操作</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以设计一个满足下述条件的解决方案吗？<code>next()</code> 和 <code>hasNext()</code> 操作均摊时间复杂度为 <code>O(1)</code> ，并使用 <code>O(h)</code> 内存。其中 <code>h</code> 是树的高度。</li>\n</ul>\n',
        level: 2,
        slug_title: "binary-search-tree-iterator",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1579,
      value: 5,
      time: "2022-01-16T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1579,
        frontend_question_id: "105",
        question_id: 105,
        title: "从前序与中序遍历序列构造二叉树",
        content:
          '<p>给定一棵树的前序遍历 <code>preorder</code> 与中序遍历  <code>inorder</code>。请构造二叉树并返回其根节点。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" />\n<pre>\n<strong>Input:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n<strong>Output:</strong> [3,9,20,null,null,15,7]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> preorder = [-1], inorder = [-1]\n<strong>Output:</strong> [-1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 <= preorder.length <= 3000</code></li>\n\t<li><code>inorder.length == preorder.length</code></li>\n\t<li><code>-3000 <= preorder[i], inorder[i] <= 3000</code></li>\n\t<li><code>preorder</code> 和 <code>inorder</code> 均无重复元素</li>\n\t<li><code>inorder</code> 均出现在 <code>preorder</code></li>\n\t<li><code>preorder</code> 保证为二叉树的前序遍历序列</li>\n\t<li><code>inorder</code> 保证为二叉树的中序遍历序列</li>\n</ul>\n',
        level: 2,
        slug_title: "construct-binary-tree-from-preorder-and-inorder-traversal",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1630,
      value: 4,
      time: "2022-09-19T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1630,
        frontend_question_id: "54",
        question_id: 54,
        title: "螺旋矩阵",
        content:
          '<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" style="width: 242px; height: 242px;" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" style="width: 322px; height: 242px;" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n<strong>输出：</strong>[1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 10</code></li>\n\t<li><code>-100 <= matrix[i][j] <= 100</code></li>\n</ul>\n',
        level: 2,
        slug_title: "spiral-matrix",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1401,
      value: 4,
      time: "2022-09-19T13:25:10.595000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1401,
        frontend_question_id: "283",
        question_id: 283,
        title: "移动零",
        content:
          "<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> <code>[0,1,0,3,12]</code>\n<strong>输出:</strong> <code>[1,3,12,0,0]</code></pre>\n\n<p><strong>说明</strong>:</p>\n\n<ol>\n\t<li>必须在原数组上操作，不能拷贝额外的数组。</li>\n\t<li>尽量减少操作次数。</li>\n</ol>\n",
        level: 1,
        slug_title: "move-zeroes",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1457,
      value: 4,
      time: "2022-09-19T06:13:09.644000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1457,
        frontend_question_id: "227",
        question_id: 227,
        title: "基本计算器 II",
        content:
          "<p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>\n\n<p>整数除法仅保留整数部分。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"3+2*2\"\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \" 3/2 \"\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \" 3+5 / 2 \"\n<strong>输出：</strong>5\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由整数和算符 <code>('+', '-', '*', '/')</code> 组成，中间由一些空格隔开</li>\n\t<li><code>s</code> 表示一个 <strong>有效表达式</strong></li>\n\t<li>表达式中的所有整数都是非负整数，且在范围 <code>[0, 2<sup>31</sup> - 1]</code> 内</li>\n\t<li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li>\n</ul>\n</div>\n</div>\n",
        level: 2,
        slug_title: "basic-calculator-ii",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1337,
      value: 4,
      time: "2022-08-28T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1337,
        frontend_question_id: "347",
        question_id: 347,
        title: "前 K 个高频元素",
        content:
          "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>nums = [1,1,1,2,2,3], k = 2\n<strong>输出: </strong>[1,2]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>nums = [1], k = 1\n<strong>输出: </strong>[1]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li>\n\t<li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code><em> </em>是数组大小。</p>\n",
        level: 2,
        slug_title: "top-k-frequent-elements",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1915,
      value: 4,
      time: "2022-08-22T06:57:41.848000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1915,
        frontend_question_id: "补充题13",
        question_id: 99990013,
        title: "中文数字转阿拉伯数字",
        content: null,
        level: 2,
        slug_title: null,
        expand: true,
      },
      comment_count: 0,
    },
    {
      id: 1653,
      value: 4,
      time: "2022-08-01T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1653,
        frontend_question_id: "31",
        question_id: 31,
        title: "下一个排列",
        content:
          '<p>实现获取 <strong>下一个排列</strong> 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。</p>\n\n<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>\n\n<p>必须<strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank"> 原地 </a></strong>修改，只允许使用额外常数空间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[1,3,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1]\n<strong>输出：</strong>[1,2,3]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,5]\n<strong>输出：</strong>[1,5,1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n',
        level: 2,
        slug_title: "next-permutation",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 140,
      value: 4,
      time: "2022-05-09T11:38:13.671000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 140,
        frontend_question_id: "剑指 Offer 04",
        question_id: 100276,
        title: "二维数组中的查找",
        content:
          '<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n\n<p> </p>\n\n<p><strong>示例:</strong></p>\n\n<p>现有矩阵 matrix 如下：</p>\n\n<pre>\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n</pre>\n\n<p>给定 target = <code>5</code>，返回 <code>true</code>。</p>\n\n<p>给定 target = <code>20</code>，返回 <code>false</code>。</p>\n\n<p> </p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 <= n <= 1000</code></p>\n\n<p><code>0 <= m <= 1000</code></p>\n\n<p> </p>\n\n<p><strong>注意：</strong>本题与主站 240 题相同：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">https://leetcode-cn.com/problems/search-a-2d-matrix-ii/</a></p>\n',
        level: 1,
        slug_title: "er-wei-shu-zu-zhong-de-cha-zhao-lcof",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1661,
      value: 4,
      time: "2022-05-05T17:29:16.289000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1661,
        frontend_question_id: "23",
        question_id: 23,
        title: "合并K个排序链表",
        content:
          "<p>给你一个链表数组，每个链表都已经按升序排列。</p>\n\n<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>lists = [[1,4,5],[1,3,4],[2,6]]\n<strong>输出：</strong>[1,1,2,3,4,4,5,6]\n<strong>解释：</strong>链表数组如下：\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\n将它们合并到一个有序链表中得到。\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>lists = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>lists = [[]]\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>k == lists.length</code></li>\n\t<li><code>0 &lt;= k &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n\t<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>\n\t<li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>\n\t<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>\n</ul>\n",
        level: 3,
        slug_title: "merge-k-sorted-lists",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 101,
      value: 4,
      time: "2022-04-27T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 101,
        frontend_question_id: "剑指 Offer 33",
        question_id: 100315,
        title: "二叉搜索树的后序遍历序列",
        content:
          "<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>\n\n<p>&nbsp;</p>\n\n<p>参考以下这颗二叉搜索树：</p>\n\n<pre>     5\n    / \\\n   2   6\n  / \\\n 1   3</pre>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入: </strong>[1,6,3,2,5]\n<strong>输出: </strong>false</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入: </strong>[1,3,2,6,5]\n<strong>输出: </strong>true</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>数组长度 &lt;= 1000</code></li>\n</ol>\n",
        level: 2,
        slug_title: "er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1476,
      value: 4,
      time: "2022-04-21T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1476,
        frontend_question_id: "208",
        question_id: 208,
        title: "实现 Trie (前缀树)",
        content:
          '<p><strong><a href="https://baike.baidu.com/item/字典树/9825209?fr=aladdin" target="_blank">Trie</a></strong>（发音类似 "try"）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>\n\n<p>请你实现 Trie 类：</p>\n\n<ul>\n\t<li><code>Trie()</code> 初始化前缀树对象。</li>\n\t<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>\n\t<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>\n\t<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n["Trie", "insert", "search", "search", "startsWith", "insert", "search"]\n[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]\n<strong>输出</strong>\n[null, null, true, false, true, null, true]\n\n<strong>解释</strong>\nTrie trie = new Trie();\ntrie.insert("apple");\ntrie.search("apple");   // 返回 True\ntrie.search("app");     // 返回 False\ntrie.startsWith("app"); // 返回 True\ntrie.insert("app");\ntrie.search("app");     // 返回 True\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word.length, prefix.length <= 2000</code></li>\n\t<li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>\n\t<li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 10<sup>4</sup></code> 次</li>\n</ul>\n',
        level: 2,
        slug_title: "implement-trie-prefix-tree",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1529,
      value: 4,
      time: "2022-04-07T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1529,
        frontend_question_id: "155",
        question_id: 155,
        title: "最小栈",
        content:
          "<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>\n\n<ul>\n\t<li><code>push(x)</code> &mdash;&mdash; 将元素 x 推入栈中。</li>\n\t<li><code>pop()</code>&nbsp;&mdash;&mdash; 删除栈顶的元素。</li>\n\t<li><code>top()</code>&nbsp;&mdash;&mdash; 获取栈顶元素。</li>\n\t<li><code>getMin()</code> &mdash;&mdash; 检索栈中的最小元素。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n<strong>输出：</strong>\n[null,null,null,null,-3,null,0,-2]\n\n<strong>解释：</strong>\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --&gt; 返回 -3.\nminStack.pop();\nminStack.top();      --&gt; 返回 0.\nminStack.getMin();   --&gt; 返回 -2.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li>\n</ul>\n",
        level: 1,
        slug_title: "min-stack",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1592,
      value: 4,
      time: "2022-03-26T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1592,
        frontend_question_id: "92",
        question_id: 92,
        title: "反转链表 II",
        content:
          '给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left <= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" style="width: 542px; height: 222px;" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], left = 2, right = 4\n<strong>输出：</strong>[1,4,3,2,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [5], left = 1, right = 1\n<strong>输出：</strong>[5]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数目为 <code>n</code></li>\n\t<li><code>1 <= n <= 500</code></li>\n\t<li><code>-500 <= Node.val <= 500</code></li>\n\t<li><code>1 <= left <= right <= n</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong> 你可以使用一趟扫描完成反转吗？</p>\n',
        level: 2,
        slug_title: "reverse-linked-list-ii",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1495,
      value: 4,
      time: "2022-03-22T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1495,
        frontend_question_id: "189",
        question_id: 189,
        title: "轮转数组",
        content:
          "<p>给定一个数组，将数组中的元素向右移动 <code>k</code><em> </em>个位置，其中 <code>k</code><em> </em>是非负数。</p><p> </p><p><strong>进阶：</strong></p><ul>\t<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>\t<li>你可以使用空间复杂度为 O(1) 的 <strong>原地 </strong>算法解决这个问题吗？</li></ul><p> </p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> nums = [1,2,3,4,5,6,7], k = 3<strong>输出:</strong> <code>[5,6,7,1,2,3,4]</code><strong>解释:</strong>向右旋转 1 步: <code>[7,1,2,3,4,5,6]</code>向右旋转 2 步: <code>[6,7,1,2,3,4,5]</code>向右旋转 3 步: <code>[5,6,7,1,2,3,4]</code></pre><p><strong>示例 2:</strong></p><pre><strong>输入：</strong>nums = [-1,-100,3,99], k = 2<strong>输出：</strong>[3,99,-1,-100]<strong>解释:</strong> 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]</pre><p> </p><p><strong>提示：</strong></p><ul>\t<li><code>1 <= nums.length <= 2 * 10<sup>4</sup></code></li>\t<li><code>-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1</code></li>\t<li><code>0 <= k <= 10<sup>5</sup></code></li></ul><ul></ul>",
        level: 2,
        slug_title: "rotate-array",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 952,
      value: 4,
      time: "2022-03-15T15:31:08.484000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 952,
        frontend_question_id: "428",
        question_id: 765,
        title: "序列化和反序列化 N 叉树",
        content: "该题是 Leetcode Plus 会员题",
        level: 3,
        slug_title: "serialize-and-deserialize-n-ary-tree",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1660,
      value: 4,
      time: "2022-03-10T00:52:29.943000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1660,
        frontend_question_id: "24",
        question_id: 24,
        title: "两两交换链表中的节点",
        content:
          '<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>\n\n<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" style="width: 422px; height: 222px;" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4]\n<strong>输出：</strong>[2,1,4,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>\n\t<li><code>0 <= Node.val <= 100</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）</p>\n',
        level: 2,
        slug_title: "swap-nodes-in-pairs",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1298,
      value: 4,
      time: "2022-03-10T00:52:29.943000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1298,
        frontend_question_id: "386",
        question_id: 386,
        title: "字典序排数",
        content:
          "<p>给定一个整数&nbsp;<em>n</em>, 返回从&nbsp;<em>1&nbsp;</em>到&nbsp;<em>n&nbsp;</em>的字典顺序。</p>\n\n<p>例如，</p>\n\n<p>给定 <em>n</em> =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。</p>\n\n<p>请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据&nbsp;<em>n&nbsp;</em>小于等于&nbsp;5,000,000。</p>\n",
        level: 2,
        slug_title: "lexicographical-numbers",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1596,
      value: 4,
      time: "2022-02-27T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1596,
        frontend_question_id: "88",
        question_id: 88,
        title: "合并两个有序数组",
        content:
          "<p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组&nbsp;<code>nums1</code><em> </em>和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p>\n\n<p>请你 <strong>合并</strong> <code>nums2</code><em> </em>到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p>\n\n<p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n<strong>输出：</strong>[1,2,2,3,5,6]\n<strong>解释：</strong>需要合并 [1,2,3] 和 [2,5,6] 。\n合并结果是 [<em><strong>1</strong></em>,<em><strong>2</strong></em>,2,<em><strong>3</strong></em>,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1], m = 1, nums2 = [], n = 0\n<strong>输出：</strong>[1]\n<strong>解释：</strong>需要合并 [1] 和 [] 。\n合并结果是 [1] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [0], m = 0, nums2 = [1], n = 1\n<strong>输出：</strong>[1]\n<strong>解释：</strong>需要合并的数组是 [] 和 [1] 。\n合并结果是 [1] 。\n注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m + n</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计实现一个时间复杂度为 <code>O(m + n)</code> 的算法解决此问题吗？</p>\n",
        level: 1,
        slug_title: "merge-sorted-array",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1595,
      value: 4,
      time: "2022-02-20T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1595,
        frontend_question_id: "89",
        question_id: 89,
        title: "格雷编码",
        content:
          "<p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p>\n\n<p>给定一个代表编码总位数的非负整数<em> n</em>，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。</p>\n\n<p>格雷编码序列必须以 0 开头。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;2\n<strong>输出:</strong>&nbsp;<code>[0,1,3,2]</code>\n<strong>解释:</strong>\n00 - 0\n01 - 1\n11 - 3\n10 - 2\n\n对于给定的&nbsp;<em>n</em>，其格雷编码序列并不唯一。\n例如，<code>[0,2,3,1]</code>&nbsp;也是一个有效的格雷编码序列。\n\n00 - 0\n10 - 2\n11 - 3\n01 - 1</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong>&nbsp;0\n<strong>输出:</strong>&nbsp;<code>[0]\n<strong>解释:</strong> 我们定义</code>格雷编码序列必须以 0 开头。<code>\n&nbsp;    给定</code>编码总位数为<code> <em>n</em> 的格雷编码序列，其长度为 2<sup>n</sup></code>。<code>当 <em>n</em> = 0 时，长度为 2<sup>0</sup> = 1。\n&nbsp;    因此，当 <em>n</em> = 0 时，其格雷编码序列为 [0]。</code>\n</pre>\n",
        level: 2,
        slug_title: "gray-code",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1300,
      value: 4,
      time: "2022-02-20T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1300,
        frontend_question_id: "384",
        question_id: 384,
        title: "打乱数组",
        content:
          '<p>给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。</p>\n\n<p>实现 <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution(int[] nums)</code> 使用整数数组 <code>nums</code> 初始化对象</li>\n\t<li><code>int[] reset()</code> 重设数组到它的初始状态并返回</li>\n\t<li><code>int[] shuffle()</code> 返回数组随机打乱后的结果</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n["Solution", "shuffle", "reset", "shuffle"]\n[[[1, 2, 3]], [], [], []]\n<strong>输出</strong>\n[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n\n<strong>解释</strong>\nSolution solution = new Solution([1, 2, 3]);\nsolution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]\nsolution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]\nsolution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 200</code></li>\n\t<li><code>-10<sup>6</sup> <= nums[i] <= 10<sup>6</sup></code></li>\n\t<li><code>nums</code> 中的所有元素都是 <strong>唯一的</strong></li>\n\t<li>最多可以调用 <code>5 * 10<sup>4</sup></code> 次 <code>reset</code> 和 <code>shuffle</code></li>\n</ul>\n',
        level: 2,
        slug_title: "shuffle-an-array",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1524,
      value: 4,
      time: "2022-02-08T09:27:25.958000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1524,
        frontend_question_id: "160",
        question_id: 160,
        title: "相交链表",
        content:
          '<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>\n\n<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>\n\n<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" style="height: 130px; width: 400px;" /></a></p>\n\n<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>\n\n<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" style="height: 130px; width: 400px;" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n<strong>输出：</strong>Intersected at \'8\'\n<strong>解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" style="height: 136px; width: 350px;" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>输出：</strong>Intersected at \'2\'\n<strong>解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" style="height: 126px; width: 200px;" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>输出：</strong>null\n<strong>解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>listA</code> 中节点数目为 <code>m</code></li>\n\t<li><code>listB</code> 中节点数目为 <code>n</code></li>\n\t<li><code>0 <= m, n <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= Node.val <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= skipA <= m</code></li>\n\t<li><code>0 <= skipB <= n</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>\n',
        level: 1,
        slug_title: "intersection-of-two-linked-lists",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1622,
      value: 4,
      time: "2022-01-28T13:22:14.990000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1622,
        frontend_question_id: "62",
        question_id: 62,
        title: "不同路径",
        content:
          '<p>一个机器人位于一个 <code>m x n</code><em> </em>网格的左上角 （起始点在下图中标记为 “Start” ）。</p>\n\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>\n\n<p>问总共有多少条不同的路径？</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" />\n<pre>\n<strong>输入：</strong>m = 3, n = 7\n<strong>输出：</strong>28</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向下\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 7, n = 3\n<strong>输出：</strong>28\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 3\n<strong>输出：</strong>6</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li>题目数据保证答案小于等于 <code>2 * 10<sup>9</sup></code></li>\n</ul>\n',
        level: 2,
        slug_title: "unique-paths",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 152,
      value: 4,
      time: "2022-01-16T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 152,
        frontend_question_id: "面试题 08.12",
        question_id: 100233,
        title: "八皇后",
        content:
          "<p>设计一种算法，打印 N 皇后在 N &times; N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的&ldquo;对角线&rdquo;指的是所有的对角线，不只是平分整个棋盘的那两条对角线。</p>\n\n<p><strong>注意：</strong>本题相对原题做了扩展</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong> 输入</strong>：4\n<strong> 输出</strong>：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]\n<strong> 解释</strong>: 4 皇后问题存在如下两个不同的解法。\n[\n&nbsp;[&quot;.Q..&quot;, &nbsp;// 解法 1\n&nbsp; &quot;...Q&quot;,\n&nbsp; &quot;Q...&quot;,\n&nbsp; &quot;..Q.&quot;],\n\n&nbsp;[&quot;..Q.&quot;, &nbsp;// 解法 2\n&nbsp; &quot;Q...&quot;,\n&nbsp; &quot;...Q&quot;,\n&nbsp; &quot;.Q..&quot;]\n]\n</pre>\n",
        level: 3,
        slug_title: "eight-queens-lcci",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1908,
      value: 4,
      time: "2021-11-03T07:05:31.669000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1908,
        frontend_question_id: "补充题6",
        question_id: 99990006,
        title: "手撕堆排序",
        content:
          "<p>给你一个整数数组&nbsp;<code>nums</code>，请你将该数组升序排列。</p><p>&nbsp;</p><ol></ol><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>nums = [5,2,3,1]<strong>输出：</strong>[1,2,3,5]</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>nums = [5,1,1,2,0,0]<strong>输出：</strong>[0,0,1,1,2,5]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ol>\t<li><code>1 &lt;= nums.length &lt;= 50000</code></li>\t<li><code>-50000 &lt;= nums[i] &lt;= 50000</code></li></ol>",
        level: 2,
        slug_title: "sort-an-array",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1602,
      value: 3,
      time: "2022-09-24T07:14:04.786000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1602,
        frontend_question_id: "82",
        question_id: 82,
        title: "删除排序链表中的重复元素 II",
        content:
          '<p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 <strong>没有重复出现</strong><em> </em>的数字。</p>\n\n<p>返回同样按升序排列的结果链表。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" style="width: 500px; height: 142px;" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,3,4,4,5]\n<strong>输出：</strong>[1,2,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg" style="width: 500px; height: 205px;" />\n<pre>\n<strong>输入：</strong>head = [1,1,1,2,3]\n<strong>输出：</strong>[2,3]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>\n\t<li><code>-100 <= Node.val <= 100</code></li>\n\t<li>题目数据保证链表已经按升序排列</li>\n</ul>\n',
        level: 2,
        slug_title: "remove-duplicates-from-sorted-list-ii",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1135,
      value: 3,
      time: "2022-09-19T03:25:31.502000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1135,
        frontend_question_id: "567",
        question_id: 567,
        title: "字符串的排列",
        content:
          '<p>给你两个字符串&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code><strong>&nbsp;</strong>的排列。</p>\n\n<p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = "ab" s2 = "eidbaooo"\n<strong>输出：</strong>true\n<strong>解释：</strong>s2 包含 s1 的排列之一 ("ba").\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1= "ab" s2 = "eidboaoo"\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li>\n</ul>\n',
        level: 2,
        slug_title: "permutation-in-string",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1580,
      value: 3,
      time: "2022-09-18T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1580,
        frontend_question_id: "104",
        question_id: 104,
        title: "二叉树的最大深度",
        content:
          "<p>给定一个二叉树，找出其最大深度。</p>\n\n<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n\n<p><strong>说明:</strong>&nbsp;叶子节点是指没有子节点的节点。</p>\n\n<p><strong>示例：</strong><br>\n给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7</pre>\n\n<p>返回它的最大深度&nbsp;3 。</p>\n",
        level: 1,
        slug_title: "maximum-depth-of-binary-tree",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1916,
      value: 3,
      time: "2022-08-14T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1916,
        frontend_question_id: "补充题14",
        question_id: 99990014,
        title: "阿拉伯数字转中文数字",
        content: null,
        level: 2,
        slug_title: null,
        expand: true,
      },
      comment_count: 0,
    },
    {
      id: 1027,
      value: 3,
      time: "2022-07-20T03:30:07.958000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1027,
        frontend_question_id: "679",
        question_id: 679,
        title: "24 点游戏",
        content:
          "<p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过&nbsp;<code>*</code>，<code>/</code>，<code>+</code>，<code>-</code>，<code>(</code>，<code>)</code>&nbsp;的运算得到 24。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [4, 1, 8, 7]\n<strong>输出:</strong> True\n<strong>解释:</strong> (8-4) * (7-1) = 24\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> [1, 2, 1, 2]\n<strong>输出:</strong> False\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>除法运算符&nbsp;<code>/</code>&nbsp;表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。</li>\n\t<li>每个运算符对两个数进行运算。特别是我们不能用&nbsp;<code>-</code>&nbsp;作为一元运算符。例如，<code>[1, 1, 1, 1]</code>&nbsp;作为输入时，表达式&nbsp;<code>-1 - 1 - 1 - 1</code>&nbsp;是不允许的。</li>\n\t<li>你不能将数字连接在一起。例如，输入为&nbsp;<code>[1, 2, 1, 2]</code>&nbsp;时，不能写成 12 + 12 。</li>\n</ol>\n",
        level: 3,
        slug_title: "24-game",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 999,
      value: 3,
      time: "2022-05-20T07:25:39.661000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 999,
        frontend_question_id: "718",
        question_id: 718,
        title: "最长重复子数组",
        content:
          "<p>给两个整数数组&nbsp;<code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;，返回两个数组中公共的、长度最长的子数组的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>\nA: [1,2,3,2,1]\nB: [3,2,1,4,7]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n长度最长的公共子数组是 [3, 2, 1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= len(A), len(B) &lt;= 1000</code></li>\n\t<li><code>0 &lt;= A[i], B[i] &lt; 100</code></li>\n</ul>\n",
        level: 2,
        slug_title: "maximum-length-of-repeated-subarray",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1486,
      value: 3,
      time: "2022-05-17T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1486,
        frontend_question_id: "198",
        question_id: 198,
        title: "打家劫舍",
        content:
          "<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>\n\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong> 不触动警报装置的情况下 </strong>，一夜之内能够偷窃到的最高金额。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,3,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[2,7,9,3,1]\n<strong>输出：</strong>12\n<strong>解释：</strong>偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 100</code></li>\n\t<li><code>0 <= nums[i] <= 400</code></li>\n</ul>\n",
        level: 2,
        slug_title: "house-robber",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1505,
      value: 3,
      time: "2022-05-09T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1505,
        frontend_question_id: "179",
        question_id: 179,
        title: "最大数",
        content:
          '<p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>\n\n<p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入<code>：</code></strong><code>nums = [10,2]</code>\n<strong>输出：</strong><code>"210"</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入<code>：</code></strong><code>nums = [3,30,34,5,9]</code>\n<strong>输出：</strong><code>"9534330"</code>\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入<code>：</code></strong>nums = [1]\n<strong>输出：</strong>"1"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入<code>：</code></strong>nums = [10]\n<strong>输出：</strong>"10"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 100</code></li>\n\t<li><code>0 <= nums[i] <= 10<sup>9</sup></code></li>\n</ul>\n',
        level: 2,
        slug_title: "largest-number",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1561,
      value: 3,
      time: "2022-04-06T16:36:36.506000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1561,
        frontend_question_id: "123",
        question_id: 123,
        title: "买卖股票的最佳时机 III",
        content:
          "<p>给定一个数组，它的第<em> </em><code>i</code> 个元素是一支给定的股票在第 <code>i</code><em> </em>天的价格。</p>\n\n<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔 </strong>交易。</p>\n\n<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [3,3,5,0,0,3,1,4]\n<strong>输出：</strong>6\n<strong>解释：</strong>在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\n     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [1,2,3,4,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   \n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   \n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [7,6,4,3,1] \n<strong>输出：</strong>0 \n<strong>解释：</strong>在这个情况下, 没有交易完成, 所以最大利润为 0。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [1]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= prices.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= prices[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        level: 3,
        slug_title: "best-time-to-buy-and-sell-stock-iii",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1290,
      value: 3,
      time: "2022-04-01T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1290,
        frontend_question_id: "394",
        question_id: 394,
        title: "字符串解码",
        content:
          "<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>\n\n<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <em>encoded_string</em> 正好重复 <em>k</em> 次。注意 <em>k</em> 保证为正整数。</p>\n\n<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>\n\n<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <em>k</em> ，例如不会出现像&nbsp;<code>3a</code>&nbsp;或&nbsp;<code>2[4]</code>&nbsp;的输入。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;3[a]2[bc]&quot;\n<strong>输出：</strong>&quot;aaabcbc&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;3[a2[c]]&quot;\n<strong>输出：</strong>&quot;accaccacc&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;2[abc]3[cd]ef&quot;\n<strong>输出：</strong>&quot;abcabccdcdcdef&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abc3[cd]xyz&quot;\n<strong>输出：</strong>&quot;abccdcdcdxyz&quot;\n</pre>\n",
        level: 2,
        slug_title: "decode-string",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1644,
      value: 3,
      time: "2022-03-31T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1644,
        frontend_question_id: "40",
        question_id: 40,
        title: "组合总和 II",
        content:
          "<p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>\n\n<p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>\n\n<p><strong>注意：</strong>解集不能包含重复的组合。 </p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> candidates = <code>[10,1,2,7,6,1,5]</code>, target = <code>8</code>,\n<strong>输出:</strong>\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> candidates = [2,5,2,1,2], target = 5,\n<strong>输出:</strong>\n[\n[1,2,2],\n[5]\n]</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 <= candidates.length <= 100</code></li>\n\t<li><code>1 <= candidates[i] <= 50</code></li>\n\t<li><code>1 <= target <= 30</code></li>\n</ul>\n",
        level: 2,
        slug_title: "combination-sum-ii",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 781,
      value: 3,
      time: "2022-03-31T02:57:52.109000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 781,
        frontend_question_id: "907",
        question_id: 943,
        title: "子数组的最小值之和",
        content:
          "<p>给定一个整数数组 <code>arr</code>，找到 <code>min(b)</code> 的总和，其中 <code>b</code> 的范围为 <code>arr</code> 的每个（连续）子数组。</p>\n\n<p>由于答案可能很大，因此<strong> 返回答案模 <code>10^9 + 7</code></strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,1,2,4]\n<strong>输出：</strong>17\n<strong>解释：\n</strong>子数组为<strong> </strong>[3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 \n最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [11,81,94,43,3]\n<strong>输出：</strong>444\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= arr[i] <= 3 * 10<sup>4</sup></code></li>\n</ul>\n\n<p> </p>\n",
        level: 2,
        slug_title: "sum-of-subarray-minimums",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1362,
      value: 3,
      time: "2022-03-30T04:45:06.413000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1362,
        frontend_question_id: "322",
        question_id: 322,
        title: "零钱兑换",
        content:
          "<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>\n\n<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>\n\n<p>你可以认为每种硬币的数量是无限的。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = <code>[1, 2, 5]</code>, amount = <code>11</code>\n<strong>输出：</strong><code>3</code> \n<strong>解释：</strong>11 = 5 + 5 + 1</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = <code>[2]</code>, amount = <code>3</code>\n<strong>输出：</strong>-1</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 0\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 2\n<strong>输出：</strong>2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= coins.length <= 12</code></li>\n\t<li><code>1 <= coins[i] <= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 <= amount <= 10<sup>4</sup></code></li>\n</ul>\n",
        level: 2,
        slug_title: "coin-change",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1588,
      value: 3,
      time: "2022-03-28T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1588,
        frontend_question_id: "96",
        question_id: 96,
        title: "不同的二叉搜索树",
        content:
          '<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" style="width: 600px; height: 148px;" />\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 19</code></li>\n</ul>\n',
        level: 2,
        slug_title: "unique-binary-search-trees",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1541,
      value: 3,
      time: "2022-03-26T06:06:34.162000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1541,
        frontend_question_id: "143",
        question_id: 143,
        title: "重排链表",
        content:
          '<p>给定一个单链表 <code>L</code><em> </em>的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>\n\n<p><code> L<sub>0 </sub>→ L<sub>1 </sub>→ … → L<sub>n-1 </sub>→ L<sub>n </sub></code><br />\n请将其重新排列后变为：</p>\n\n<p><code>L<sub>0 </sub>→ L<sub>n </sub>→ L<sub>1 </sub>→ L<sub>n-1 </sub>→ L<sub>2 </sub>→ L<sub>n-2 </sub>→ …</code></p>\n\n<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt="" src="https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png" style="width: 240px; " /></p>\n\n<pre>\n<strong>输入: </strong>head = [1,2,3,4]\n<strong>输出: </strong>[1,4,2,3]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt="" src="https://pic.leetcode-cn.com/1626420320-YUiulT-image.png" style="width: 320px; " /></p>\n\n<pre>\n<strong>输入: </strong>head = [1,2,3,4,5]\n<strong>输出: </strong>[1,5,2,4,3]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的长度范围为 <code>[1, 5 * 10<sup>4</sup>]</code></li>\n\t<li><code>1 <= node.val <= 1000</code></li>\n</ul>\n',
        level: 2,
        slug_title: "reorder-list",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1575,
      value: 3,
      time: "2022-03-22T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1575,
        frontend_question_id: "109",
        question_id: 109,
        title: "有序链表转换二叉搜索树",
        content:
          "<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>\n\n<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点&nbsp;</em>的左右两个子树的高度差的绝对值不超过 1。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>给定的有序链表： [-10, -3, 0, 5, 9],\n\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n</pre>\n",
        level: 2,
        slug_title: "convert-sorted-list-to-binary-search-tree",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 413,
      value: 3,
      time: "2022-03-22T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 413,
        frontend_question_id: "1233",
        question_id: 1350,
        title: "删除子文件夹",
        content:
          "<p>你是一位系统管理员，手里有一份文件夹列表 <code>folder</code>，你的任务是要删除该列表中的所有 <strong>子文件夹</strong>，并以 <strong>任意顺序</strong> 返回剩下的文件夹。</p>\n\n<p>我们这样定义「子文件夹」：</p>\n\n<ul>\n\t<li>如果文件夹&nbsp;<code>folder[i]</code>&nbsp;位于另一个文件夹&nbsp;<code>folder[j]</code>&nbsp;下，那么&nbsp;<code>folder[i]</code>&nbsp;就是&nbsp;<code>folder[j]</code>&nbsp;的子文件夹。</li>\n</ul>\n\n<p>文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：</p>\n\n<ul>\n\t<li><code>/</code>&nbsp;后跟一个或者多个小写英文字母。</li>\n</ul>\n\n<p>例如，<code>/leetcode</code>&nbsp;和&nbsp;<code>/leetcode/problems</code>&nbsp;都是有效的路径，而空字符串和&nbsp;<code>/</code>&nbsp;不是。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>folder = [&quot;/a&quot;,&quot;/a/b&quot;,&quot;/c/d&quot;,&quot;/c/d/e&quot;,&quot;/c/f&quot;]\n<strong>输出：</strong>[&quot;/a&quot;,&quot;/c/d&quot;,&quot;/c/f&quot;]\n<strong>解释：</strong>&quot;/a/b/&quot; 是 &quot;/a&quot; 的子文件夹，而 &quot;/c/d/e&quot; 是 &quot;/c/d&quot; 的子文件夹。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>folder = [&quot;/a&quot;,&quot;/a/b/c&quot;,&quot;/a/b/d&quot;]\n<strong>输出：</strong>[&quot;/a&quot;]\n<strong>解释：</strong>文件夹 &quot;/a/b/c&quot; 和 &quot;/a/b/d/&quot; 都会被删除，因为它们都是 &quot;/a&quot; 的子文件夹。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>folder = [&quot;/a/b/c&quot;,&quot;/a/b/d&quot;,&quot;/a/b/ca&quot;]\n<strong>输出：</strong>[&quot;/a/b/c&quot;,&quot;/a/b/ca&quot;,&quot;/a/b/d&quot;]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= folder.length&nbsp;&lt;= 4 * 10^4</code></li>\n\t<li><code>2 &lt;= folder[i].length &lt;= 100</code></li>\n\t<li><code>folder[i]</code>&nbsp;只包含小写字母和 <code>/</code></li>\n\t<li><code>folder[i]</code>&nbsp;总是以字符 <code>/</code>&nbsp;起始</li>\n\t<li>每个文件夹名都是唯一的</li>\n</ul>\n",
        level: 2,
        slug_title: "remove-sub-folders-from-the-filesystem",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1545,
      value: 3,
      time: "2022-03-20T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1545,
        frontend_question_id: "139",
        question_id: 139,
        title: "单词拆分",
        content:
          "<p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict</em>，判定&nbsp;<em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>拆分时可以重复使用字典中的单词。</li>\n\t<li>你可以假设字典中没有重复的单词。</li>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:</strong> s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]\n<strong>输出:</strong> true\n<strong>解释:</strong> 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入:</strong> s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]\n<strong>输出:</strong> true\n<strong>解释:</strong> 返回 true 因为 <code>&quot;</code>applepenapple<code>&quot;</code> 可以被拆分成 <code>&quot;</code>apple pen apple<code>&quot;</code>。\n&nbsp;    注意你可以重复使用字典中的单词。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]\n<strong>输出:</strong> false\n</pre>\n",
        level: 2,
        slug_title: "word-break",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1282,
      value: 3,
      time: "2022-03-18T07:59:53.675000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1282,
        frontend_question_id: "402",
        question_id: 402,
        title: "移掉K位数字",
        content:
          '<p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code><em> </em>位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>\n \n\n<p><strong>示例 1 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = "1432219", k = 3\n<strong>输出：</strong>"1219"\n<strong>解释：</strong>移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = "10200", k = 1\n<strong>输出：</strong>"200"\n<strong>解释：</strong>移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。\n</pre>\n\n<p><strong>示例 3 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = "10", k = 2\n<strong>输出：</strong>"0"\n<strong>解释：</strong>从原数字移除所有的数字，剩余为空就是 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= num.length <= 10<sup>5</sup></code></li>\n\t<li><code>num</code> 仅由若干位数字（0 - 9）组成</li>\n\t<li>除了 <strong>0</strong> 本身之外，<code>num</code> 不含任何前导零</li>\n</ul>\n',
        level: 2,
        slug_title: "remove-k-digits",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1518,
      value: 3,
      time: "2022-03-13T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1518,
        frontend_question_id: "166",
        question_id: 166,
        title: "分数到小数",
        content:
          '<p>给定两个整数，分别表示分数的分子 <code>numerator</code> 和分母 <code>denominator</code>，以 <strong>字符串形式返回小数</strong> 。</p>\n\n<p>如果小数部分为循环小数，则将循环的部分括在括号内。</p>\n\n<p class="MachineTrans-lang-zh-CN">如果存在多个答案，只需返回 <strong>任意一个</strong> 。</p>\n\n<p class="MachineTrans-lang-zh-CN">对于所有给定的输入，<strong>保证</strong> 答案字符串的长度小于 <code>10<sup>4</sup></code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>numerator = 1, denominator = 2\n<strong>输出：</strong>"0.5"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>numerator = 2, denominator = 1\n<strong>输出：</strong>"2"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>numerator = 2, denominator = 3\n<strong>输出：</strong>"0.(6)"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>numerator = 4, denominator = 333\n<strong>输出：</strong>"0.(012)"\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>numerator = 1, denominator = 5\n<strong>输出：</strong>"0.2"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> <= numerator, denominator <= 2<sup>31</sup> - 1</code></li>\n\t<li><code>denominator != 0</code></li>\n</ul>\n',
        level: 2,
        slug_title: "fraction-to-recurring-decimal",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 713,
      value: 3,
      time: "2022-03-07T13:10:41.227000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 713,
        frontend_question_id: "974",
        question_id: 1016,
        title: "和可被 K 整除的子数组",
        content:
          "<p>给定一个整数数组 <code>A</code>，返回其中元素之和可被 <code>K</code>&nbsp;整除的（连续、非空）子数组的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>A = [4,5,0,-2,-3,1], K = 5\n<strong>输出：</strong>7\n<strong>解释：\n</strong>有 7 个子数组满足其元素之和可被 K = 5 整除：\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;= 30000</code></li>\n\t<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>\n\t<li><code>2 &lt;= K &lt;= 10000</code></li>\n</ol>\n",
        level: 2,
        slug_title: "subarray-sums-divisible-by-k",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1674,
      value: 3,
      time: "2022-03-07T11:37:21.201000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1674,
        frontend_question_id: "10",
        question_id: 10,
        title: "正则表达式匹配",
        content:
          '<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>\'.\'</code> 和 <code>\'*\'</code> 的正则表达式匹配。</p>\n\n<ul>\n\t<li><code>\'.\'</code> 匹配任意单个字符</li>\n\t<li><code>\'*\'</code> 匹配零个或多个前面的那一个元素</li>\n</ul>\n\n<p>所谓匹配，是要涵盖 <strong>整个 </strong>字符串 <code>s</code>的，而不是部分字符串。</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "aa" p = "a"\n<strong>输出：</strong>false\n<strong>解释：</strong>"a" 无法匹配 "aa" 整个字符串。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "aa" p = "a*"\n<strong>输出：</strong>true\n<strong>解释：</strong>因为 \'*\' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 \'a\'。因此，字符串 "aa" 可被视为 \'a\' 重复了一次。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "ab" p = ".*"\n<strong>输出：</strong>true\n<strong>解释：</strong>".*" 表示可匹配零个或多个（\'*\'）任意字符（\'.\'）。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "aab" p = "c*a*b"\n<strong>输出：</strong>true\n<strong>解释：</strong>因为 \'*\' 表示零个或多个，这里 \'c\' 为 0 个, \'a\' 被重复一次。因此可以匹配字符串 "aab"。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = "mississippi" p = "mis*is*p*."\n<strong>输出：</strong>false</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= s.length <= 20</code></li>\n\t<li><code>0 <= p.length <= 30</code></li>\n\t<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>\n\t<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>\n\t<li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li>\n</ul>\n',
        level: 3,
        slug_title: "regular-expression-matching",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1432,
      value: 3,
      time: "2022-03-06T14:31:52.376000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1432,
        frontend_question_id: "252",
        question_id: 252,
        title: "会议室",
        content: "该题是 Leetcode Plus 会员题",
        level: 1,
        slug_title: "meeting-rooms",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1641,
      value: 3,
      time: "2022-03-01T07:41:26.933000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1641,
        frontend_question_id: "43",
        question_id: 43,
        title: "字符串相乘",
        content:
          "<p>给定两个以字符串形式表示的非负整数&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>，返回&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>&nbsp;的乘积，它们的乘积也表示为字符串形式。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> num1 = &quot;2&quot;, num2 = &quot;3&quot;\n<strong>输出:</strong> &quot;6&quot;</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> num1 = &quot;123&quot;, num2 = &quot;456&quot;\n<strong>输出:</strong> &quot;56088&quot;</pre>\n\n<p><strong>说明：</strong></p>\n\n<ol>\n\t<li><code>num1</code>&nbsp;和&nbsp;<code>num2</code>&nbsp;的长度小于110。</li>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code> 只包含数字&nbsp;<code>0-9</code>。</li>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code>&nbsp;均不以零开头，除非是数字 0 本身。</li>\n\t<li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li>\n</ol>\n",
        level: 2,
        slug_title: "multiply-strings",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 167,
      value: 3,
      time: "2022-02-20T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 167,
        frontend_question_id: "面试题 02.05",
        question_id: 100188,
        title: "链表求和",
        content:
          "<p>给定两个用链表表示的整数，每个节点包含一个数位。</p>\n\n<p>这些数位是反向存放的，也就是个位排在链表首部。</p>\n\n<p>编写函数对这两个整数求和，并用链表形式返回结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295\n<strong>输出：</strong>2 -&gt; 1 -&gt; 9，即912\n</pre>\n\n<p><strong>进阶：</strong>思考一下，假设这些数位是正向存放的，又该如何解决呢?</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>(6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5)，即617 + 295\n<strong>输出：</strong>9 -&gt; 1 -&gt; 2，即912\n</pre>\n",
        level: 2,
        slug_title: "sum-lists-lcci",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 90,
      value: 3,
      time: "2022-02-10T12:04:43.599000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 90,
        frontend_question_id: "剑指 Offer 52",
        question_id: 100326,
        title: "两个链表的第一个公共节点",
        content:
          '<p>输入两个链表，找出它们的第一个公共节点。</p>\n\n<p>如下面的两个链表<strong>：</strong></p>\n\n<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" style="height: 130px; width: 400px;"></a></p>\n\n<p>在节点 c1 开始相交。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" style="height: 130px; width: 400px;"></a></p>\n\n<pre><strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n<strong>输出：</strong>Reference of the node with value = 8\n<strong>输入解释：</strong>相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" style="height: 136px; width: 350px;"></a></p>\n\n<pre><strong>输入：</strong>intersectVal&nbsp;= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>输出：</strong>Reference of the node with value = 2\n<strong>输入解释：</strong>相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" style="height: 126px; width: 200px;"></a></p>\n\n<pre><strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>输出：</strong>null\n<strong>输入解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n<strong>解释：</strong>这两个链表不相交，因此返回 null。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>如果两个链表没有交点，返回 <code>null</code>.</li>\n\t<li>在返回结果后，两个链表仍须保持原有的结构。</li>\n\t<li>可假定整个链表结构中没有循环。</li>\n\t<li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li>\n\t<li>本题与主站 160 题相同：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></li>\n</ul>\n',
        level: 1,
        slug_title: "liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1347,
      value: 3,
      time: "2022-02-09T08:52:08.506000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1347,
        frontend_question_id: "337",
        question_id: 337,
        title: "打家劫舍 III",
        content:
          "<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为&ldquo;根&rdquo;。 除了&ldquo;根&rdquo;之外，每栋房子有且只有一个&ldquo;父&ldquo;房子与之相连。一番侦察之后，聪明的小偷意识到&ldquo;这个地方的所有房屋的排列类似于一棵二叉树&rdquo;。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>\n\n<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入: </strong>[3,2,3,null,3,null,1]\n\n     <strong>3</strong>\n    / \\\n   2   3\n    \\   \\ \n     <strong>3</strong>   <strong>1</strong>\n\n<strong>输出:</strong> 7 \n<strong>解释:</strong>&nbsp;小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = <strong>7</strong>.</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入: </strong>[3,4,5,1,3,null,1]\n\n&nbsp;    3\n    / \\\n   <strong>4</strong>   <strong>5</strong>\n  / \\   \\ \n 1   3   1\n\n<strong>输出:</strong> 9\n<strong>解释:</strong>&nbsp;小偷一晚能够盗取的最高金额&nbsp;= <strong>4</strong> + <strong>5</strong> = <strong>9</strong>.\n</pre>\n",
        level: 2,
        slug_title: "house-robber-iii",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1384,
      value: 3,
      time: "2022-01-24T15:53:07.755000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1384,
        frontend_question_id: "300",
        question_id: 300,
        title: "最长上升子序列",
        content:
          "<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>\n\n<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,9,2,5,3,7,101,18]\n<strong>输出：</strong>4\n<strong>解释：</strong>最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,0,3,2,3]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,7,7,7,7,7,7]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 2500</code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n\n<p> </p>\n\n<p><b>进阶：</b></p>\n\n<ul>\n\t<li>你可以设计时间复杂度为 <code>O(n<sup>2</sup>)</code> 的解决方案吗？</li>\n\t<li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li>\n</ul>\n",
        level: 2,
        slug_title: "longest-increasing-subsequence",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1397,
      value: 3,
      time: "2022-01-08T07:39:02.437000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1397,
        frontend_question_id: "287",
        question_id: 287,
        title: "寻找重复数",
        content:
          "<p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>1</code> 到 <code>n</code><em> </em>之间（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>\n\n<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，找出 <strong>这个重复的数</strong> 。</p>\n\n<p>你设计的解决方案必须不修改数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,4,2,2]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,3,4,2]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>nums.length == n + 1</code></li>\n\t<li><code>1 <= nums[i] <= n</code></li>\n\t<li><code>nums</code> 中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 <strong>一次</strong></li>\n</ul>\n\n<p> </p>\n\n<p><b>进阶：</b></p>\n\n<ul>\n\t<li>如何证明 <code>nums</code> 中至少存在一个重复的数字?</li>\n\t<li>你可以设计一个线性级时间复杂度 <code>O(n)</code> 的解决方案吗？</li>\n</ul>\n",
        level: 2,
        slug_title: "find-the-duplicate-number",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1330,
      value: 3,
      time: "2021-12-13T14:42:17.541000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1330,
        frontend_question_id: "354",
        question_id: 354,
        title: "俄罗斯套娃信封问题",
        content:
          "<p>给你一个二维整数数组 <code>envelopes</code> ，其中 <code>envelopes[i] = [w<sub>i</sub>, h<sub>i</sub>]</code> ，表示第 <code>i</code> 个信封的宽度和高度。</p>\n\n<p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>\n\n<p>请计算 <strong>最多能有多少个</strong> 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>\n\n<p><strong>注意</strong>：不允许旋转信封。</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>envelopes = [[5,4],[6,4],[6,7],[2,3]]\n<strong>输出：</strong>3\n<strong>解释：</strong>最多信封的个数为 <code>3, 组合为: </code>[2,3] => [5,4] => [6,7]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>envelopes = [[1,1],[1,1],[1,1]]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= envelopes.length <= 5000</code></li>\n\t<li><code>envelopes[i].length == 2</code></li>\n\t<li><code>1 <= w<sub>i</sub>, h<sub>i</sub> <= 10<sup>4</sup></code></li>\n</ul>\n",
        level: 3,
        slug_title: "russian-doll-envelopes",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1605,
      value: 3,
      time: "2021-12-05T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1605,
        frontend_question_id: "79",
        question_id: 79,
        title: "单词搜索",
        content:
          '<p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" style="width: 322px; height: 242px;" />\n<pre>\n<strong>输入：</strong>board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" style="width: 322px; height: 242px;" />\n<pre>\n<strong>输入：</strong>board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" style="width: 322px; height: 242px;" />\n<pre>\n<strong>输入：</strong>board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n = board[i].length</code></li>\n\t<li><code>1 <= m, n <= 6</code></li>\n\t<li><code>1 <= word.length <= 15</code></li>\n\t<li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你可以使用搜索剪枝的技术来优化解决方案，使其在 <code>board</code> 更大的情况下可以更快解决问题？</p>\n',
        level: 2,
        slug_title: "word-search",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1241,
      value: 3,
      time: "2021-11-11T07:20:06.323000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1241,
        frontend_question_id: "449",
        question_id: 449,
        title: "序列化和反序列化二叉搜索树",
        content:
          "<p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p>\n\n<p>设计一个算法来序列化和反序列化<strong> 二叉搜索树</strong> 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p>\n\n<p><strong>编码的字符串应尽可能紧凑。</strong></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,3]\n<strong>输出：</strong>[2,1,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数范围是 <code>[0, 10<sup>4</sup>]</code></li>\n\t<li><code>0 <= Node.val <= 10<sup>4</sup></code></li>\n\t<li>题目数据 <strong>保证</strong> 输入的树是一棵二叉搜索树。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>注意</strong>：不要使用类成员/全局/静态变量来存储状态。 你的序列化和反序列化算法应该是无状态的。</p>\n",
        level: 2,
        slug_title: "serialize-and-deserialize-bst",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 547,
      value: 3,
      time: "2021-11-07T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 547,
        frontend_question_id: "1095",
        question_id: 1185,
        title: "山脉数组中查找目标值",
        content:
          '<p>（这是一个 <strong>交互式问题&nbsp;</strong>）</p>\n\n<p>给你一个 <strong>山脉数组</strong>&nbsp;<code>mountainArr</code>，请你返回能够使得&nbsp;<code>mountainArr.get(index)</code>&nbsp;<strong>等于</strong>&nbsp;<code>target</code>&nbsp;<strong>最小</strong>&nbsp;的下标 <code>index</code>&nbsp;值。</p>\n\n<p>如果不存在这样的下标 <code>index</code>，就请返回&nbsp;<code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p>何为山脉数组？如果数组&nbsp;<code>A</code> 是一个山脉数组的话，那它满足如下条件：</p>\n\n<p><strong>首先</strong>，<code>A.length &gt;= 3</code></p>\n\n<p><strong>其次</strong>，在&nbsp;<code>0 &lt; i&nbsp;&lt; A.length - 1</code>&nbsp;条件下，存在 <code>i</code> 使得：</p>\n\n<ul>\n\t<li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li>\n\t<li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>你将&nbsp;<strong>不能直接访问该山脉数组</strong>，必须通过&nbsp;<code>MountainArray</code>&nbsp;接口来获取数据：</p>\n\n<ul>\n\t<li><code>MountainArray.get(k)</code>&nbsp;- 会返回数组中索引为<code>k</code>&nbsp;的元素（下标从 0 开始）</li>\n\t<li><code>MountainArray.length()</code>&nbsp;- 会返回该数组的长度</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<p>对&nbsp;<code>MountainArray.get</code>&nbsp;发起超过 <code>100</code> 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p>\n\n<p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 &ldquo;<strong>答案</strong>&rdquo;：<a href="https://leetcode-cn.com/playground/RKhe3ave" target="_blank">https://leetcode-cn.com/playground/RKhe3ave</a>，请注意这 <strong>不是一个正确答案</strong>。</p>\n\n<ol>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>array = [1,2,3,4,5,3,1], target = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>array = [0,1,2,4,2,1], target = 3\n<strong>输出：</strong>-1\n<strong>解释：</strong>3 在数组中没有出现，返回 -1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= mountain_arr.length() &lt;= 10000</code></li>\n\t<li><code>0 &lt;= target &lt;= 10^9</code></li>\n\t<li><code>0 &lt;= mountain_arr.get(index) &lt;=&nbsp;10^9</code></li>\n</ul>\n',
        level: 3,
        slug_title: "find-in-mountain-array",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1462,
      value: 3,
      time: "2021-11-03T07:22:28.650000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1462,
        frontend_question_id: "222",
        question_id: 222,
        title: "完全二叉树的节点个数",
        content:
          '<p>给你一棵<strong> 完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>\n\n<p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2<sup>h</sup></code> 个节点。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" style="width: 372px; height: 302px;" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,6]\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目范围是<code>[0, 5 * 10<sup>4</sup>]</code></li>\n\t<li><code>0 <= Node.val <= 5 * 10<sup>4</sup></code></li>\n\t<li>题目数据保证输入的树是 <strong>完全二叉树</strong></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>遍历树来统计节点是一种时间复杂度为 <code>O(n)</code> 的简单解决方案。你可以设计一个更快的算法吗？</p>\n',
        level: 2,
        slug_title: "count-complete-tree-nodes",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 900,
      value: 3,
      time: "2021-09-22T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 900,
        frontend_question_id: "706",
        question_id: 817,
        title: "设计哈希映射",
        content:
          '<p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p>\n\n<p>实现 <code>MyHashMap</code> 类：</p>\n\n<ul>\n\t<li><code>MyHashMap()</code> 用空映射初始化对象</li>\n\t<li><code>void put(int key, int value)</code> 向 HashMap 插入一个键值对 <code>(key, value)</code> 。如果 <code>key</code> 已经存在于映射中，则更新其对应的值 <code>value</code> 。</li>\n\t<li><code>int get(int key)</code> 返回特定的 <code>key</code> 所映射的 <code>value</code> ；如果映射中不包含 <code>key</code> 的映射，返回 <code>-1</code> 。</li>\n\t<li><code>void remove(key)</code> 如果映射中存在 <code>key</code> 的映射，则移除 <code>key</code> 和它所对应的 <code>value</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>：\n["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\n<strong>输出</strong>：\n[null, null, null, 1, -1, null, 1, null, -1]\n\n<strong>解释</strong>：\nMyHashMap myHashMap = new MyHashMap();\nmyHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]\nmyHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]\nmyHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]\nmyHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]\nmyHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）\nmyHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]\nmyHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]\nmyHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= key, value <= 10<sup>6</sup></code></li>\n\t<li>最多调用 <code>10<sup>4</sup></code> 次 <code>put</code>、<code>get</code> 和 <code>remove</code> 方法</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你能否不使用内置的 HashMap 库解决此问题？</p>\n',
        level: 1,
        slug_title: "design-hashmap",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1647,
      value: 3,
      time: "2021-08-22T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1647,
        frontend_question_id: "37",
        question_id: 37,
        title: "解数独",
        content:
          '<p>编写一个程序，通过填充空格来解决数独问题。</p>\n\n<p>数独的解法需<strong> 遵循如下规则</strong>：</p>\n\n<ol>\n\t<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>\n\t<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>\n\t<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li>\n</ol>\n\n<p>数独部分空格内已填入了数字，空白格用 <code>\'.\'</code> 表示。</p>\n\n<p> </p>\n\n<div class="top-view__1vxA">\n<div class="original__bRMd">\n<div>\n<p><strong>示例：</strong></p>\n<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" style="height:250px; width:250px" />\n<pre>\n<strong>输入：</strong>board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]\n<strong>输出：</strong>[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]\n<strong>解释：</strong>输入的数独如上图所示，唯一有效的解决方案如下所示：\n\n<img src=" https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714_solutionsvg.png" style="height:250px; width:250px" />\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board.length == 9</code></li>\n\t<li><code>board[i].length == 9</code></li>\n\t<li><code>board[i][j]</code> 是一位数字或者 <code>\'.\'</code></li>\n\t<li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li>\n</ul>\n</div>\n</div>\n</div>\n',
        level: 3,
        slug_title: "sudoku-solver",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1648,
      value: 3,
      time: "2021-03-05T04:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1648,
        frontend_question_id: "36",
        question_id: 36,
        title: "有效的数独",
        content:
          '<p>请你判断一个 <code>9x9</code> 的数独是否有效。只需要<strong> 根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p>\n\n<ol>\n\t<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>\n\t<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>\n\t<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li>\n</ol>\n\n<p>数独部分空格内已填入了数字，空白格用 <code>\'.\'</code> 表示。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>一个有效的数独（部分已被填充）不一定是可解的。</li>\n\t<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" style="height:250px; width:250px" />\n<pre>\n<strong>输入：</strong>board = \n[["5","3",".",".","7",".",".",".","."]\n,["6",".",".","1","9","5",".",".","."]\n,[".","9","8",".",".",".",".","6","."]\n,["8",".",".",".","6",".",".",".","3"]\n,["4",".",".","8",".","3",".",".","1"]\n,["7",".",".",".","2",".",".",".","6"]\n,[".","6",".",".",".",".","2","8","."]\n,[".",".",".","4","1","9",".",".","5"]\n,[".",".",".",".","8",".",".","7","9"]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = \n[["8","3",".",".","7",".",".",".","."]\n,["6",".",".","1","9","5",".",".","."]\n,[".","9","8",".",".",".",".","6","."]\n,["8",".",".",".","6",".",".",".","3"]\n,["4",".",".","8",".","3",".",".","1"]\n,["7",".",".",".","2",".",".",".","6"]\n,[".","6",".",".",".",".","2","8","."]\n,[".",".",".","4","1","9",".",".","5"]\n,[".",".",".",".","8",".",".","7","9"]]\n<strong>输出：</strong>false\n<strong>解释：</strong>除了第一行的第一个数字从<strong> 5</strong> 改为 <strong>8 </strong>以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board.length == 9</code></li>\n\t<li><code>board[i].length == 9</code></li>\n\t<li><code>board[i][j]</code> 是一位数字或者 <code>\'.\'</code></li>\n</ul>\n',
        level: 2,
        slug_title: "valid-sudoku",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1522,
      value: 3,
      time: "2021-03-05T04:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1522,
        frontend_question_id: "162",
        question_id: 162,
        title: "寻找峰值",
        content:
          "<p>峰值元素是指其值严格大于左右相邻值的元素。</p>\n\n<p>给你一个整数数组&nbsp;<code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p>\n\n<p>你可以假设&nbsp;<code>nums[-1] = nums[n] = -∞</code> 。</p>\n\n<p>你必须实现时间复杂度为 <code>O(log n)</code><em> </em>的算法来解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = <code>[1,2,3,1]</code>\n<strong>输出：</strong>2\n<strong>解释：</strong>3 是峰值元素，你的函数应该返回其索引 2。</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = <code>[</code>1,2,1,3,5,6,4]\n<strong>输出：</strong>1 或 5 \n<strong>解释：</strong>你的函数可以返回索引 1，其峰值元素为 2；\n&nbsp;    或者返回索引 5， 其峰值元素为 6。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>对于所有有效的 <code>i</code> 都有 <code>nums[i] != nums[i + 1]</code></li>\n</ul>\n",
        level: 2,
        slug_title: "find-peak-element",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1519,
      value: 2,
      time: "2022-09-19T03:02:09.641000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1519,
        frontend_question_id: "165",
        question_id: 165,
        title: "比较版本号",
        content:
          '<p>给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们。</p>\n\n<p>版本号由一个或多个修订号组成，各修订号由一个 <code>\'.\'</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p>\n\n<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 <code>1</code> 和修订号 <code>001</code> <strong>相等 </strong>。如果版本号没有指定某个下标处的修订号，则该修订号视为 <code>0</code> 。例如，版本 <code>1.0</code> 小于版本 <code>1.1</code> ，因为它们下标为 <code>0</code> 的修订号相同，而下标为 <code>1</code> 的修订号分别为 <code>0</code> 和 <code>1</code> ，<code>0 < 1</code> 。</p>\n\n<p>返回规则如下：</p>\n\n<ul>\n\t<li>如果 <code><em>version1 </em>> <em>version2</em></code> 返回 <code>1</code>，</li>\n\t<li>如果 <code><em>version1 </em>< <em>version2</em></code> 返回 <code>-1</code>，</li>\n\t<li>除此之外返回 <code>0</code>。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = "1.01", version2 = "1.001"\n<strong>输出：</strong>0\n<strong>解释：</strong>忽略前导零，"01" 和 "001" 都表示相同的整数 "1"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = "1.0", version2 = "1.0.0"\n<strong>输出：</strong>0\n<strong>解释：</strong>version1 没有指定下标为 2 的修订号，即视为 "0"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = "0.1", version2 = "1.1"\n<strong>输出：</strong>-1\n<strong>解释：</strong>version1 中下标为 0 的修订号是 "0"，version2 中下标为 0 的修订号是 "1" 。0 < 1，所以 version1 < version2\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = "1.0.1", version2 = "1"\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = "7.5.2.4", version2 = "7.5.3"\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= version1.length, version2.length <= 500</code></li>\n\t<li><code>version1</code> 和 <code>version2</code> 仅包含数字和 <code>\'.\'</code></li>\n\t<li><code>version1</code> 和 <code>version2</code> 都是 <strong>有效版本号</strong></li>\n\t<li><code>version1</code> 和 <code>version2</code> 的所有修订号都可以存储在 <strong>32 位整数</strong> 中</li>\n</ul>\n',
        level: 2,
        slug_title: "compare-version-numbers",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1255,
      value: 2,
      time: "2022-09-11T06:47:17.044000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1255,
        frontend_question_id: "435",
        question_id: 435,
        title: "无重叠区间",
        content:
          "<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>可以认为区间的终点总是大于它的起点。</li>\n\t<li>区间 [1,2] 和 [2,3] 的边界相互&ldquo;接触&rdquo;，但没有相互重叠。</li>\n</ol>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> [ [1,2], [2,3], [3,4], [1,3] ]\n\n<strong>输出:</strong> 1\n\n<strong>解释:</strong> 移除 [1,3] 后，剩下的区间没有重叠。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> [ [1,2], [1,2], [1,2] ]\n\n<strong>输出:</strong> 2\n\n<strong>解释:</strong> 你需要移除两个 [1,2] 来使剩下的区间没有重叠。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> [ [1,2], [2,3] ]\n\n<strong>输出:</strong> 0\n\n<strong>解释:</strong> 你不需要移除任何区间，因为它们已经是无重叠的了。\n</pre>\n",
        level: 2,
        slug_title: "non-overlapping-intervals",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 624,
      value: 2,
      time: "2022-09-08T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 624,
        frontend_question_id: "1035",
        question_id: 1105,
        title: "不相交的线",
        content:
          '<p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p>\n\n<p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足满足：</p>\n\n<ul>\n\t<li> <code>nums1[i] == nums2[j]</code></li>\n\t<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>\n</ul>\n\n<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>\n\n<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/28/142.png" style="height: 72px; width: 100px;" /></strong>\n\n<pre>\n<strong>输入：</strong>nums1 = <span id="example-input-1-1">[1,4,2]</span>, nums2 = <span id="example-input-1-2">[1,2,4]</span>\n<strong>输出：</strong><span id="example-output-1">2</span>\n<strong>解释：</strong>可以画出两条不交叉的线，如上图所示。 \n但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。\n</pre>\n\n<div>\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = <span id="example-input-2-1">[2,5,1,2,5]</span>, nums2 = <span id="example-input-2-2">[10,5,2,1,5,2]</span>\n<strong>输出：</strong><span id="example-output-2">3</span>\n</pre>\n\n<div>\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = <span id="example-input-3-1">[1,3,7,1,7,5]</span>, nums2 = <span id="example-input-3-2">[1,9,2,5,1]</span>\n<strong>输出：</strong><span id="example-output-3">2</span></pre>\n\n<p> </p>\n</div>\n</div>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums1.length <= 500</code></li>\n\t<li><code>1 <= nums2.length <= 500</code></li>\n\t<li><code><font face="monospace">1 <= nums1[i], nums2[i] <= 2000</font></code></li>\n</ul>\n\n<p> </p>\n',
        level: 2,
        slug_title: "uncrossed-lines",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1604,
      value: 2,
      time: "2022-09-07T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1604,
        frontend_question_id: "80",
        question_id: 80,
        title: "删除排序数组中的重复项 II",
        content:
          '<p>给你一个有序数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>最多出现两次</strong> ，返回删除后数组的新长度。</p>\n\n<p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank">原地 </a>修改输入数组 </strong>并在使用 O(1) 额外空间的条件下完成。</p>\n\n<p> </p>\n\n<p><strong>说明：</strong></p>\n\n<p>为什么返回数值是整数，但输出的答案是数组呢？</p>\n\n<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>\n\n<p>你可以想象内部操作如下:</p>\n\n<pre>\n// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中<strong> 该长度范围内</strong> 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n</pre>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,2,2,3]\n<strong>输出：</strong>5, nums = [1,1,2,2,3]\n<strong>解释：</strong>函数应返回新长度 length = <strong><code>5</code></strong>, 并且原数组的前五个元素被修改为 <strong><code>1, 1, 2, 2,</code></strong> <strong>3 </strong>。 不需要考虑数组中超出新长度后面的元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,1,1,1,1,2,3,3]\n<strong>输出：</strong>7, nums = [0,0,1,1,2,3,3]\n<strong>解释：</strong>函数应返回新长度 length = <strong><code>7</code></strong>, 并且原数组的前五个元素被修改为 <strong><code>0</code></strong>, <strong>0</strong>, <strong>1</strong>, <strong>1</strong>, <strong>2</strong>, <strong>3</strong>, <strong>3 。</strong> 不需要考虑数组中超出新长度后面的元素。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 已按升序排列</li>\n</ul>\n',
        level: 2,
        slug_title: "remove-duplicates-from-sorted-array-ii",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1629,
      value: 2,
      time: "2022-08-24T06:05:54.105000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1629,
        frontend_question_id: "55",
        question_id: 55,
        title: "跳跃游戏",
        content:
          "<p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>\n\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n\n<p>判断你是否能够到达最后一个下标。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,1,1,4]\n<strong>输出：</strong>true\n<strong>解释：</strong>可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1,0,4]\n<strong>输出：</strong>false\n<strong>解释：</strong>无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 <= nums[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        level: 2,
        slug_title: "jump-game",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1206,
      value: 2,
      time: "2022-07-19T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1206,
        frontend_question_id: "486",
        question_id: 486,
        title: "预测赢家",
        content:
          "<p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，&hellip;&hellip; 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p>\n\n<p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[1, 5, 2]\n<strong>输出：</strong>False\n<strong>解释：</strong>一开始，玩家1可以从1和2中进行选择。\n如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。\n所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。\n因此，玩家 1 永远不会成为赢家，返回 False 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[1, 5, 233, 7]\n<strong>输出：</strong>True\n<strong>解释：</strong>玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。\n     最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>1 &lt;= 给定的数组长度&nbsp;&lt;= 20.</li>\n\t<li>数组里所有分数都为非负数且不会大于 10000000 。</li>\n\t<li>如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。</li>\n</ul>\n",
        level: 2,
        slug_title: "predict-the-winner",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1649,
      value: 2,
      time: "2022-07-05T00:57:38.770000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1649,
        frontend_question_id: "35",
        question_id: 35,
        title: "搜索插入位置",
        content:
          "<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n\n<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 5\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 2\n<strong>输出:</strong> 1\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 7\n<strong>输出:</strong> 4\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 0\n<strong>输出:</strong> 0\n</pre>\n\n<p><strong>示例 5:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1], target = 0\n<strong>输出:</strong> 0\n</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 为<strong>无重复元素</strong>的<strong>升序</strong>排列数组</li>\n\t<li><code>-10<sup>4</sup> <= target <= 10<sup>4</sup></code></li>\n</ul>\n",
        level: 1,
        slug_title: "search-insert-position",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1610,
      value: 2,
      time: "2022-06-30T08:56:39.528000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1610,
        frontend_question_id: "74",
        question_id: 74,
        title: "搜索二维矩阵",
        content:
          '<p>编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>\n\n<ul>\n\t<li>每行中的整数从左到右按升序排列。</li>\n\t<li>每行的第一个整数大于前一行的最后一个整数。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" style="width: 322px; height: 242px;" />\n<pre>\n<strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg" style="width: 322px; height: 242px;" />\n<pre>\n<strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li><code>-10<sup>4</sup> <= matrix[i][j], target <= 10<sup>4</sup></code></li>\n</ul>\n',
        level: 2,
        slug_title: "search-a-2d-matrix",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1253,
      value: 2,
      time: "2022-05-23T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1253,
        frontend_question_id: "437",
        question_id: 437,
        title: "路径总和 III",
        content:
          '<p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>\n\n<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" style="width: 452px; " /></p>\n\n<pre>\n<strong>输入：</strong>root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n<strong>输出：</strong>3\n<strong>解释：</strong>和等于 8 的路径有 3 条，如图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,1000]</code></li>\n\t<li><meta charset="UTF-8" /><code>-10<sup>9</sup> <= Node.val <= 10<sup>9</sup></code> </li>\n\t<li><code>-1000 <= targetSum <= 1000</code> </li>\n</ul>\n',
        level: 2,
        slug_title: "path-sum-iii",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1248,
      value: 2,
      time: "2022-05-13T15:20:07.586000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1248,
        frontend_question_id: "442",
        question_id: 442,
        title: "数组中重复的数据",
        content:
          "<p>给定一个整数数组 a，其中1 &le; a[i] &le; <em>n</em> （<em>n</em>为数组长度）, 其中有些元素出现<strong>两次</strong>而其他元素出现<strong>一次</strong>。</p>\n\n<p>找到所有出现<strong>两次</strong>的元素。</p>\n\n<p>你可以不用到任何额外空间并在O(<em>n</em>)时间复杂度内解决这个问题吗？</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入:</strong>\n[4,3,2,7,8,2,3,1]\n\n<strong>输出:</strong>\n[2,3]\n</pre>\n",
        level: 2,
        slug_title: "find-all-duplicates-in-an-array",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1549,
      value: 2,
      time: "2022-05-11T08:38:50.659000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1549,
        frontend_question_id: "135",
        question_id: 135,
        title: "分发糖果",
        content:
          "<p>老师想给孩子们分发糖果，有 <em>N</em> 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>\n\n<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>\n\n<ul>\n\t<li>每个孩子至少分配到 1 个糖果。</li>\n\t<li>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</li>\n</ul>\n\n<p>那么这样下来，老师至少需要准备多少颗糖果呢？</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,0,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>你可以分别给这三个孩子分发 2、1、2 颗糖果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>你可以分别给这三个孩子分发 1、2、1 颗糖果。\n     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</pre>\n",
        level: 3,
        slug_title: "candy",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 720,
      value: 2,
      time: "2022-05-09T06:43:04.605000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 720,
        frontend_question_id: "968",
        question_id: 1008,
        title: "监控二叉树",
        content:
          '<p>给定一个二叉树，我们在树的节点上安装摄像头。</p>\n\n<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>\n\n<p>计算监控树的所有节点所需的最小摄像头数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" style="height: 163px; width: 138px;"></p>\n\n<pre><strong>输入：</strong>[0,0,null,0,0]\n<strong>输出：</strong>1\n<strong>解释：</strong>如图所示，一台摄像头足以监控所有节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png" style="height: 312px; width: 139px;"></p>\n\n<pre><strong>输入：</strong>[0,0,null,0,null,0,null,null,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。\n</pre>\n\n<p><br>\n<strong>提示：</strong></p>\n\n<ol>\n\t<li>给定树的节点数的范围是&nbsp;<code>[1, 1000]</code>。</li>\n\t<li>每个节点的值都是 0。</li>\n</ol>\n',
        level: 3,
        slug_title: "binary-tree-cameras",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1887,
      value: 2,
      time: "2022-05-04T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1887,
        frontend_question_id: "1494",
        question_id: 1587,
        title: "并行课程 II",
        content:
          '<p>给你一个整数&nbsp;<code>n</code>&nbsp;表示某所大学里课程的数目，编号为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;，数组&nbsp;<code>dependencies</code>&nbsp;中，&nbsp;<code>dependencies[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp; 表示一个先修课的关系，也就是课程&nbsp;<code>x<sub>i</sub></code>&nbsp;必须在课程&nbsp;<code>y<sub>i</sub></code><sub>&nbsp;</sub>之前上。同时你还有一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>在一个学期中，你 <strong>最多</strong>&nbsp;可以同时上 <code>k</code>&nbsp;门课，前提是这些课的先修课在之前的学期里已经上过了。</p>\n\n<p>请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/27/leetcode_parallel_courses_1.png" style="height: 164px; width: 300px;"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, dependencies = [[2,1],[3,1],[1,4]], k = 2\n<strong>输出：</strong>3 \n<strong>解释：</strong>上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ，第三个学期上课程 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/27/leetcode_parallel_courses_2.png" style="height: 234px; width: 300px;"></strong></p>\n\n<pre><strong>输入：</strong>n = 5, dependencies = [[2,1],[3,1],[4,1],[1,5]], k = 2\n<strong>输出：</strong>4 \n<strong>解释：</strong>上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课程 1 ，第四学期上课程 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 11, dependencies = [], k = 2\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 15</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n\t<li><code>0 &lt;=&nbsp;dependencies.length &lt;= n * (n-1) / 2</code></li>\n\t<li><code>dependencies[i].length == 2</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= n</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li>所有先修关系都是不同的，也就是说&nbsp;<code>dependencies[i] != dependencies[j]</code>&nbsp;。</li>\n\t<li>题目输入的图是个有向无环图。</li>\n</ul>\n',
        level: 3,
        slug_title: "parallel-courses-ii",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1277,
      value: 2,
      time: "2022-04-29T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1277,
        frontend_question_id: "407",
        question_id: 407,
        title: "接雨水 II",
        content:
          '<p>给你一个&nbsp;<code>m x n</code>&nbsp;的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg" /></p>\n\n<pre>\n<strong>输入:</strong> heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg" /></p>\n\n<pre>\n<strong>输入:</strong> heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\n<strong>输出:</strong> 10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>m == heightMap.length</code></li>\n\t<li><code>n == heightMap[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= heightMap[i][j] &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n',
        level: 3,
        slug_title: "trapping-rain-water-ii",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 1450,
      value: 2,
      time: "2022-04-21T16:00:00Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 1450,
        frontend_question_id: "234",
        question_id: 234,
        title: "回文链表",
        content:
          '<p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" style="width: 422px; height: 62px;" />\n<pre>\n<strong>输入：</strong>head = [1,2,2,1]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" style="width: 182px; height: 62px;" />\n<pre>\n<strong>输入：</strong>head = [1,2]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数目在范围<code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能否用&nbsp;<code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p>\n',
        level: 1,
        slug_title: "palindrome-linked-list",
        expand: false,
      },
      comment_count: 0,
    },
    {
      id: 933,
      value: 2,
      time: "2022-04-15T06:55:25.232000Z",
      status: false,
      note_status: false,
      rate: 0,
      leetcode: {
        id: 933,
        frontend_question_id: "701",
        question_id: 784,
        title: "二叉搜索树中的插入操作",
        content:
          '<p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>\n\n<p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" style="width: 752px; height: 221px;" />\n<pre>\n<strong>输入：</strong>root = [4,2,7,1,3], val = 5\n<strong>输出：</strong>[4,2,7,1,3,5]\n<strong>解释：</strong>另一个满足题目要求可以通过的树是：\n<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/bst.jpg" style="width: 352px; height: 301px;" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [40,20,60,10,30,50,70], val = 25\n<strong>输出：</strong>[40,20,60,10,30,50,70,null,null,25]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n<strong>输出：</strong>[4,2,7,1,3,5]\n</pre>\n\n<p> </p>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定的树上的节点数介于 <code>0</code> 和 <code>10^4</code> 之间</li>\n\t<li>每个节点都有一个唯一整数值，取值范围从 <code>0</code> 到 <code>10^8</code></li>\n\t<li><code>-10^8 <= val <= 10^8</code></li>\n\t<li>新值和原始二叉搜索树中的任意节点值都不同</li>\n</ul>\n',
        level: 2,
        slug_title: "insert-into-a-binary-search-tree",
        expand: false,
      },
      comment_count: 0,
    },
  ],
};

console.log('题号, 名称, 频次, 类型')
questions.list.forEach((question) => {
    let id = question.leetcode.frontend_question_id
    let name = question.leetcode.title
    let value = question.value
    let content = question.leetcode.content
    console.log(id + ',' + name + ',' + value + ',')
})