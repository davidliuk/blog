# 类加载

## 类的生命周期

类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：

- 加载（Loading）
- 连接（Linking）
  - 验证（Verification）
  - 准备（Preparation）
  - 解析（Resolution）
- 初始化（Initialization）
- 使用（Using）
- 卸载（Unloading）

加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始， 这是为了支持 Java 语言的运行时绑定特性(也称为动态绑定或晚期绑定)。

> 是按部就班地“开始”，而不是按部就班地“进行”或按部就班地“完成”，强调这点是因为这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。

## 类加载时机

### 主动引用

主动引用**一定会**触发类加载（实例化（两种）、调用静态方法或变量、

主动引用的场景：

1. 当虚拟机启动时，用户需要指定一个要执行的**主类**(包含 main()方法的那个类)，虚拟机会先初始化这个主类。

2. 遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。

   能够生成这四条指令的典型 Java 代码场景有：

   - 使用 new 关键字实例化对象的时候。

   - 读取或设置一个类型的静态字段的时候。

     被 final 修饰、已在编译期把结果放入**常量池**的静态字段除外

   - 调用一个类型的静态方法的时候。

2. 当初始化类的时候，如果发现其**父类**还没有进行过初始化，则需要先触发其父类的初始化。

3. 当一个接口中定义了 JDK 8 新加入的默认方法(被 default 关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

5. 使用 java.lang.reflect 包的方法对类型进行**反射**调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。

6. 当使用 JDK 7 新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。

这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用

### 被动引用

被动引用**不会**触发类加载

- 通过**子类引用父类的静态字段**，不会导致子类初始化（父类会初始化）
- 通过**数组**定义来引用类，不会触发此类的初始化
- **常量**在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类
