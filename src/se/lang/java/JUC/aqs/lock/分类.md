# 锁的分类

悲观锁：每次操作前都加锁

乐观锁：CAS或版本号机制



一般来说，MySQL中的行锁、表锁

行锁会发生死锁，表锁不会



## 乐观锁

代表：AtomicInteger，使用cas（Unsafe）来保证原子性

- 核心是：无需加锁，每次只有一个线程能够成功修改共享变量，其他失败的线程不需要停止，不断重复直至成功
- 由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换
- 它需要多核cpu支持，且核心数不应超过cpu核数

问题：ABA问题

解决：时间戳/版本号，如AtomicStampedReference

缺点：

- 只能保证一个变量的原子操作



## 悲观锁

代表：synchronized和Lock

- 核心是：线程占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待
- 线程从运行到阻塞，再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能
- 实际上，线程在获取synchronized和Lock锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会



### synchronized

是可重入锁。

`synchronized` 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

在 Java 早期版本中，`synchronized` 属于 **重量级锁**，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 `Mutex Lock` 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。

不过，在 Java 6 之后， `synchronized` 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 `synchronized` 锁的效率提升了很多。因此， `synchronized` 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 `synchronized` 。



#### 基本原理

对象头中包含两部分：MarkWord 和 类型指针。如果是数组对象的话，对象头还有一部分是存储数组的长度。

多线程下 synchronized 的加锁就是对同一个对象的对象头中的 MarkWord 中的变量进行CAS操作。



#### 锁升级

Java6对synchronized进行了优化。

级别从低到高依次是：

1. 无锁状态
2. 偏向锁状态
3. 轻量级锁状态
4. 重量级锁状态



##### 偏向锁

适合：一个线程对一个锁的多次获取的情况

偏向锁是针对于一个线程而言的，线程获得锁之后就不会再有解锁等操作了，这样可以省略很多开销。假如有两个线程来竞争该锁话，那么偏向锁就失效了，进而升级成轻量级锁了。



##### 轻量级锁

适合：锁执行体比较简单(即减少锁粒度或时间), 自旋一会儿就可以成功获取锁的情况。

之所以是轻量级，是因为它仅仅使用 CAS 进行操作，实现获取锁。

如果线程发现对象头中Mark Word已经存在指向自己栈帧的指针，即线程已经获得轻量级锁，那么只需要将0存储在自己的栈帧中（此过程称为递归加锁）；在解锁的时候，如果发现锁记录的内容为0， 那么只需要移除栈帧中的锁记录即可，而不需要更新Mark Word。

线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录（`Lock Record`）的指针， 如上图所示。如果成功，当前线程获得轻量级锁，如果失败，虚拟机先检查当前对象头的 Mark Word 是否指向当前线程的栈帧，如果指向，则说明当前线程已经拥有这个对象的锁，则可以直接进入同步块 执行操作，否则表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。当竞争线程的自旋次数 达到界限值（`threshold`），轻量级锁将会膨胀为重量级锁。



##### 重量级锁

重量级锁（`heavy weight lock`），是使用操作系统互斥量（`mutex`）来实现的传统锁。 当所有对锁的优化都失效时，将退回到重量级锁。它与轻量级锁不同竞争的线程不再通过自旋来竞争线程， 而是直接进入堵塞状态，此时不消耗CPU，然后等拥有锁的线程释放锁后，唤醒堵塞的线程， 然后线程再次竞争锁。但是注意，当锁膨胀（`inflate`）为重量锁时，就不能再退回到轻量级锁。



### ReentrantReadWriteLock

#### 读锁、写锁

写锁：独占锁 WLock

读锁：共享锁 RLock



#### 死锁

读锁死锁的场景：

![截屏2023-02-02 21.57.01](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-02 21.57.01.png)

写锁死锁的场景：

![截屏2023-02-02 22.00.01](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/截屏2023-02-02 22.00.01.png)

读的时候不能些，写的时候可以读

#### 锁降级

获取写锁 -> 获取读锁 -> 释放写锁 -> 释放读锁


