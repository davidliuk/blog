# 原理

Spring AOP（面向切面编程）是Spring框架提供的一个功能，用于在运行时动态地将通用的横切关注点（例如日志记录、性能监控、事务管理等）插入到应用程序的代码中。

Spring AOP的原理基于动态代理和反射机制，其主要实现方式包括两种：

**基于代理的AOP**：

- Spring AOP通过为目标对象生成一个代理对象，实现对目标对象的方法调用进行拦截和增强。
- 当目标对象实现了接口时，Spring AOP会使用基于JDK的动态代理来创建代理对象。
- 当目标对象没有实现接口时，Spring AOP会使用基于CGLIB的动态代理来创建代理对象，CGLIB是一个强大的字节码生成库，能够在运行时动态生成类的子类，实现对目标对象的代理。

---

Spring AOP 是 Spring 框架提供的一个面向切面编程的功能，它可以将与业务无关的功能（例如日志、安全、事务等）从业务代码中分离出来，从而提高代码的可重用性和可维护性。

Spring AOP 的实现原理是基于动态代理和字节码操作的。

在编译时，Spring 会使用 **AspectJ** 编译器将切面代码编译成字节码文件。

在运行时，Spring 会根据切面配置使用**JDK动态代理**或**CGLIB代理**生成代理类，这些代理类会在目标对象方法执行前后插入切面代码，从而实现 AOP 的功能。

具体来说，Spring AOP 的实现原理可以分为以下几个步骤：

1. **切面定义**：使用 AspectJ 语法定义切面，包括切入点、通知方法等。
2. **切面编译**：使用 AspectJ 编译器将切面代码编译成字节码文件。
3. **代理生成**：Spring 会根据切面配置生成代理类，这些代理类会在目标对象方法执行前后插入切面代码。
4. **目标对象替换**：Spring 会将代理类替换为目标对象，从而使切面代码能够在目标对象方法执行前后执行。

Spring AOP 支持两种动态代理方式：JDK 动态代理和 CGLIB 动态代理。

- **JDK 动态代理**：JDK 动态代理是基于 Java 反射机制实现的，它只能对实现了接口的目标对象进行代理。
- **CGLIB 动态代理**：CGLIB 动态代理是基于字节码操作技术实现的，它可以对任何目标对象进行代理，包括没有实现接口的目标对象。

Spring AOP 默认使用 JDK 动态代理，如果目标对象没有实现接口，则会使用 CGLIB 动态代理。

[原理详解](https://juejin.cn/post/7221333917080813623#heading-3)

### JDK Proxy

`Proxy.newProxyInstance`

`ReflectiveMethodInvocation`

```java
public class JdkDynamicAopProxy implements AopProxy, InvocationHandler {

    private final AdvisedSupport advised;

    public JdkDynamicAopProxy(AdvisedSupport advised) {
        this.advised = advised;
    }

    @Override
    public Object getProxy() {
        return Proxy.newProxyInstance(
                getClass().getClassLoader(),
                advised.getTargetSource().getInterfaces(),
                this
        );
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        MethodInterceptor methodInterceptor = advised.getMethodInterceptor();
        MethodInvocation methodInvocation = new ReflectiveMethodInvocation(
                advised.getTargetSource().getTarget(),
                method,
                args,
                methodInterceptor,
                advised.getTargetSource().getTargetClass()
        );
        return methodInvocation.proceed();
    }
}
```

### CGLIB

- `Enhancer`
- `setSuperclass`
- `setCallback`
- `CglibMethodInvocation`

```java
public class CglibAopProxy implements AopProxy {

    private final AdvisedSupport advised;

    public CglibAopProxy(AdvisedSupport advised) {
        this.advised = advised;
    }

    @Override
    public Object getProxy() {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(advised.getTargetSource().getTargetClass());
        enhancer.setCallback(new DynamicAdvisedInterceptor(advised));
        return enhancer.create();
    }

    private static class DynamicAdvisedInterceptor implements MethodInterceptor {

        private final AdvisedSupport advised;

        public DynamicAdvisedInterceptor(AdvisedSupport advised) {
            this.advised = advised;
        }

        @Override
        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
            MethodInvocation methodInvocation = new CglibMethodInvocation(
                    advised.getTargetSource().getTarget(),
                    method,
                    args,
                    proxy,
                    advised.getMethodInterceptor(),
                    advised.getTargetSource().getTargetClass()
            );
            return methodInvocation.proceed();
        }
    }
}
```