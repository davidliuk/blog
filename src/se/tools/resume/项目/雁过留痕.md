# Trace Note

### 技术选型

后端：

- Spring Boot 2.8, Spring AOP
- MySQL, Redis, Redisson
- hutool
- RabbitMQ, Spring AMQP
- 文档：knife4j

前端：

- SwiftUI
- ARKit

### 系统业务



### 人员分工

- 3个同学，1人全职文案和海报，2位开发同学客户端和后端共同负责
- 2人客户端、SwiftUI主要界面、ARKit场景交互页面
- 2人后端、



### 项目亮点

1. 利用AOP实现注解校验用户登陆状态及用户权限。使用 Redis 实现分布式 Session，解决集群间登录态同步问题；
2. 使用 Redis 对高频访问 Trace 进行缓存，降低 DB 压力同时提升 90% 的数据查询性能。
3. 使用模版模式实现了通用缓存访问静态方法，并解决了缓存雪崩、缓存穿透和缓存击穿的问题。
4. 使用 Redis 的 Geo 数据结构存储附近 Trace，并使用 Geo Search 命令实现高性能 Trace 查询及按距离排序。
5. 使用 Redis ZSet 数据结构存储用户点赞信息，保证用户只能点赞一次，并可以展示记录点赞的先后排序。
6. 使用 Redis Set 数据结构实现用户关注、共同关注功能，并使用 Redis AOF 持久化防止关注数据丢失。
7. 使用 Redis BitMap 实现用户连续签到统计功能，提高存储的效率并减少内存的占用。
8. 基于推模式实现关注 Feed 流，保证了新点评消息的及时可达，并减少用户访问的等待时间。
9. 使用 Lua 脚本实现库存预检解决了超卖问题、实现一人一单。通过 RabbitMQ 实现异步订单创建、超时取消订单。



列举一些该项目可以扩展的点，有能力的同学可以自己尝试实现（注意，没有自己实现过千万别写到简历上！！！做没做过一问便知）：

1. 使用 Redis + Token 机制实现单点登录（补充到上述第 1 点中）
2. 对 Redis 的所有 key 设置 N + n 的过期时间，从而合理使用内存并防止缓存雪崩；针对热点店铺缓存，使用逻辑过期（或自动续期）机制解决缓存击穿问题，防止数据库宕机。
3. 使用 Redis 的 Geo + Hash 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及按距离排序，实测相对于传统 DB 查询 + 业务层计算的方式，性能提升 xx%。
4. 使用 Redis Set 数据结构实现用户关注、共同关注功能（交集），实测相对于 DB 查询性能提升 xx%，并使用 Redis AOF + 业务层日志防止关注数据丢失。（理解 AOF 和 RDB 持久化机制后再写这点）
5. 基于 Spring Scheduler 实现对热点数据的定期检测和缓存预加载，提升用户的访问体验，并通过 Redisson 分布式锁保证集群中同一时刻的定时任务只执行一次。
6. 关注 Feed 流可以改为推拉结合模式（活跃用户用推、普通用户用拉）
7. 使用哨兵集群来提升 Redis 的读并发量、可用性和稳定性；或者使用 Redis 分片集群来提升 Redis 读写并发量、总存储容量，保障可用性和稳定性。
8. 随着系统用户增多，使用 Redis HyperLogLog 代替 DB 来实现店铺和点评的 UV 统计，提高 xx% 的查询分析性能并解决 xx% 的内存空间。



1. 利用AOP实现注解校验用户登陆状态及用户权限。使用 Redis 实现分布式 Session，解决集群间登录态同步问题；

2. 使用 Redis 对高频访问 Trace 进行缓存，降低 DB 压力同时提升 90% 的数据查询性能。

3. 使用模版模式实现了通用缓存访问静态方法，并解决了缓存雪崩、缓存穿透和缓存击穿的问题。

4. 使用 Redis 的 Geo + Hash 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及按距离排序。

5. 使用 Redis ZSet 数据结构存储用户点赞信息，保证用户只能点赞一次，并基于 ZSet 记录点赞的时间。

6. 使用 Redis Set 数据结构实现用户关注、共同关注功能（交集），实测相对于 DB 查询性能提升 xx%，并使用 Redis AOF + 业务层日志防止关注数据丢失。

7. 使用 Redis BitMap 实现用户连续签到统计功能。

8. 基于推模式实现关注 Feed 流，保证了新点评消息的及时可达，并减少用户访问的等待时间。

9. 个性饰品抢购：使用 Lua 脚本实现库存预检解决了超卖问题、实现一人一单。通过 RabbitMQ 实现异步订单创建，流量削峰。

   使用 Redis + Lua 脚本实现库存预检，并通过 RabbitMQ 实现订单的异步创建，解决了超卖问题、实现一人一单。实现相比传统数据库，秒杀性能提高了 xx%。



再列举一些该项目可以扩展的点，有能力的同学可以自己尝试实现（注意，没有自己实现过千万别写到简历上！！！做没做过一问便知）：



1. 使用 Redis + Token 机制实现单点登录（补充到上述第 1 点中）
2. 对 Redis 的所有 key 设置 N + n 的过期时间，从而合理使用内存并防止缓存雪崩；针对热点店铺缓存，使用逻辑过期（或自动续期）机制解决缓存击穿问题，防止数据库宕机。
3. 使用 Redis 的 Geo + Hash 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及按距离排序，实测相对于传统 DB 查询 + 业务层计算的方式，性能提升 xx%。
4. 使用 Redis Set 数据结构实现用户关注、共同关注功能（交集），实测相对于 DB 查询性能提升 xx%，并使用 Redis AOF + 业务层日志防止关注数据丢失。（理解 AOF 和 RDB 持久化机制后再写这点）
5. 基于 Spring Scheduler 实现对热点数据的定期检测和缓存预加载，提升用户的访问体验，并通过 Redisson 分布式锁保证集群中同一时刻的定时任务只执行一次。
6. 关注 Feed 流可以改为推拉结合模式（活跃用户用推、普通用户用拉）
7. 使用哨兵集群来提升 Redis 的读并发量、可用性和稳定性；或者使用 Redis 分片集群来提升 Redis 读写并发量、总存储容量，保障可用性和稳定性。
8. 随着系统用户增多，使用 Redis HyperLogLog 代替 DB 来实现店铺和点评的 UV 统计，提高 xx% 的查询分析性能并解决 xx% 的内存空间。

